/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/tsd.d.ts" />
	var RamlWrapper = __webpack_require__(3);
	var parserWrapper = __webpack_require__(1);
	var expander = __webpack_require__(4);
	var Opt = __webpack_require__(5);
	var jsyaml = __webpack_require__(6);
	var hlimpl = __webpack_require__(7);
	var javaParserGen = __webpack_require__(8);
	var json = __webpack_require__(9);
	var javaPathResolver = __webpack_require__(2);
	var path = __webpack_require__(11);
	var apiType = __webpack_require__(10)("RAML10").type("Api");
	function run() {
	    var func = function (apiPath) {
	        return loadApi(apiPath).getOrElse(null);
	    };
	    parserWrapper.setCreateApi(func);
	    var gc = function (sv, rootPackage) {
	        var hlNode = sv.toHighlevel();
	        var def = hlNode.definition();
	        var obj = json.serialize(sv.lowLevel());
	        if (typeof obj != 'object') {
	            obj = {};
	        }
	        return {
	            valueName: sv.valueName(),
	            data: JSON.stringify(obj, null, 2),
	            classes: javaParserGen.generateClasses(def, rootPackage)
	        };
	    };
	    parserWrapper.setGenerateClasses(gc);
	}
	function loadApi(apiPath) {
	    var api = null;
	    var projectRoot = path.dirname(apiPath);
	    var p = new jsyaml.Project(projectRoot, {
	        content: function (path) {
	            return javaPathResolver.content(path);
	        },
	        list: function (path) {
	            return javaPathResolver.list(path);
	        }
	    });
	    var result;
	    p.units().forEach(function (x) {
	        if (path.basename(x.path()) == path.basename(apiPath)) {
	            api = new RamlWrapper.ApiImpl(new hlimpl.ASTNodeImpl(x.ast(), null, apiType, null));
	            api = expander.expandTraitsAndResourceTypes(api);
	        }
	    });
	    console.log("Api parsed " + api.title());
	    return new Opt(api);
	}
	function getErrors(node) {
	    var result = [];
	    node.errors().forEach(function (x) { return result.push({
	        code: x.code,
	        message: x.message,
	        path: x.path,
	        start: x.start,
	        end: x.end,
	        isWarning: x.isWarning
	    }); });
	    return result;
	}
	run();
	//# sourceMappingURL=entryPoint.instrumented.js.map

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = apiCreatorWrapper;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = javaPathResolver;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = this.__extends || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var hl = __webpack_require__(17);
	var core = __webpack_require__(18);
	var BasicNodeImpl = (function (_super) {
	    __extends(BasicNodeImpl, _super);
	    function BasicNodeImpl(node) {
	        _super.call(this, node);
	    }
	    BasicNodeImpl.prototype.wrapperClassName = function () {
	        return 'BasicNodeImpl';
	    };
	    BasicNodeImpl.prototype.parent = function () {
	        return _super.prototype.parent.call(this);
	    };
	    return BasicNodeImpl;
	})(core.BasicSuperNodeImpl);
	exports.BasicNodeImpl = BasicNodeImpl;
	var RAMLLanguageElementImpl = (function (_super) {
	    __extends(RAMLLanguageElementImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function RAMLLanguageElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createRAMLLanguageElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    RAMLLanguageElementImpl.prototype.wrapperClassName = function () {
	        return "RAMLLanguageElementImpl";
	    };
	    /**
	     *
	     **/
	    //displayName
	    RAMLLanguageElementImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     *
	     **/
	    //setDisplayName
	    RAMLLanguageElementImpl.prototype.setDisplayName = function (param) {
	        {
	            this.highLevel().attrOrCreate("displayName").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //description
	    RAMLLanguageElementImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //annotations
	    RAMLLanguageElementImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    return RAMLLanguageElementImpl;
	})(BasicNodeImpl);
	exports.RAMLLanguageElementImpl = RAMLLanguageElementImpl;
	var ValueTypeImpl = (function () {
	    /**
	     *
	     **/
	    //constructor
	    function ValueTypeImpl(attr) {
	        this.attr = attr;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ValueTypeImpl.prototype.wrapperClassName = function () {
	        return "ValueTypeImpl";
	    };
	    /**
	     *
	     **/
	    //value
	    ValueTypeImpl.prototype.value = function () {
	        return this.attr.value();
	    };
	    /**
	     *
	     **/
	    //highLevel
	    ValueTypeImpl.prototype.highLevel = function () {
	        return this.attr;
	    };
	    return ValueTypeImpl;
	})();
	exports.ValueTypeImpl = ValueTypeImpl;
	var NumberTypeImpl = (function (_super) {
	    __extends(NumberTypeImpl, _super);
	    function NumberTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    NumberTypeImpl.prototype.wrapperClassName = function () {
	        return "NumberTypeImpl";
	    };
	    return NumberTypeImpl;
	})(ValueTypeImpl);
	exports.NumberTypeImpl = NumberTypeImpl;
	var BooleanTypeImpl = (function (_super) {
	    __extends(BooleanTypeImpl, _super);
	    function BooleanTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    BooleanTypeImpl.prototype.wrapperClassName = function () {
	        return "BooleanTypeImpl";
	    };
	    return BooleanTypeImpl;
	})(ValueTypeImpl);
	exports.BooleanTypeImpl = BooleanTypeImpl;
	var ReferenceImpl = (function (_super) {
	    __extends(ReferenceImpl, _super);
	    function ReferenceImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ReferenceImpl.prototype.wrapperClassName = function () {
	        return "ReferenceImpl";
	    };
	    /**
	     *
	     **/
	    //value
	    ReferenceImpl.prototype.value = function () {
	        return core.toStructuredValue(this.attr);
	    };
	    return ReferenceImpl;
	})(ValueTypeImpl);
	exports.ReferenceImpl = ReferenceImpl;
	var ResourceTypeRefImpl = (function (_super) {
	    __extends(ResourceTypeRefImpl, _super);
	    function ResourceTypeRefImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ResourceTypeRefImpl.prototype.wrapperClassName = function () {
	        return "ResourceTypeRefImpl";
	    };
	    return ResourceTypeRefImpl;
	})(ReferenceImpl);
	exports.ResourceTypeRefImpl = ResourceTypeRefImpl;
	var TraitRefImpl = (function (_super) {
	    __extends(TraitRefImpl, _super);
	    function TraitRefImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    TraitRefImpl.prototype.wrapperClassName = function () {
	        return "TraitRefImpl";
	    };
	    return TraitRefImpl;
	})(ReferenceImpl);
	exports.TraitRefImpl = TraitRefImpl;
	var SecuritySchemaRefImpl = (function (_super) {
	    __extends(SecuritySchemaRefImpl, _super);
	    function SecuritySchemaRefImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    SecuritySchemaRefImpl.prototype.wrapperClassName = function () {
	        return "SecuritySchemaRefImpl";
	    };
	    return SecuritySchemaRefImpl;
	})(ReferenceImpl);
	exports.SecuritySchemaRefImpl = SecuritySchemaRefImpl;
	var AnnotationRefImpl = (function (_super) {
	    __extends(AnnotationRefImpl, _super);
	    function AnnotationRefImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    AnnotationRefImpl.prototype.wrapperClassName = function () {
	        return "AnnotationRefImpl";
	    };
	    return AnnotationRefImpl;
	})(ReferenceImpl);
	exports.AnnotationRefImpl = AnnotationRefImpl;
	var DataElementRefImpl = (function (_super) {
	    __extends(DataElementRefImpl, _super);
	    function DataElementRefImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    DataElementRefImpl.prototype.wrapperClassName = function () {
	        return "DataElementRefImpl";
	    };
	    return DataElementRefImpl;
	})(ReferenceImpl);
	exports.DataElementRefImpl = DataElementRefImpl;
	var ramlexpressionImpl = (function (_super) {
	    __extends(ramlexpressionImpl, _super);
	    function ramlexpressionImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ramlexpressionImpl.prototype.wrapperClassName = function () {
	        return "ramlexpressionImpl";
	    };
	    return ramlexpressionImpl;
	})(ValueTypeImpl);
	exports.ramlexpressionImpl = ramlexpressionImpl;
	var AnnotationTargetImpl = (function (_super) {
	    __extends(AnnotationTargetImpl, _super);
	    function AnnotationTargetImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    AnnotationTargetImpl.prototype.wrapperClassName = function () {
	        return "AnnotationTargetImpl";
	    };
	    return AnnotationTargetImpl;
	})(ValueTypeImpl);
	exports.AnnotationTargetImpl = AnnotationTargetImpl;
	var pointerImpl = (function (_super) {
	    __extends(pointerImpl, _super);
	    function pointerImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    pointerImpl.prototype.wrapperClassName = function () {
	        return "pointerImpl";
	    };
	    return pointerImpl;
	})(ValueTypeImpl);
	exports.pointerImpl = pointerImpl;
	var StringTypeImpl = (function (_super) {
	    __extends(StringTypeImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function StringTypeImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    StringTypeImpl.prototype.wrapperClassName = function () {
	        return "StringTypeImpl";
	    };
	    return StringTypeImpl;
	})(ValueTypeImpl);
	exports.StringTypeImpl = StringTypeImpl;
	var UriTemplateImpl = (function (_super) {
	    __extends(UriTemplateImpl, _super);
	    function UriTemplateImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    UriTemplateImpl.prototype.wrapperClassName = function () {
	        return "UriTemplateImpl";
	    };
	    return UriTemplateImpl;
	})(StringTypeImpl);
	exports.UriTemplateImpl = UriTemplateImpl;
	var RelativeUriImpl = (function (_super) {
	    __extends(RelativeUriImpl, _super);
	    function RelativeUriImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    RelativeUriImpl.prototype.wrapperClassName = function () {
	        return "RelativeUriImpl";
	    };
	    return RelativeUriImpl;
	})(UriTemplateImpl);
	exports.RelativeUriImpl = RelativeUriImpl;
	var FullUriTemplateImpl = (function (_super) {
	    __extends(FullUriTemplateImpl, _super);
	    function FullUriTemplateImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    FullUriTemplateImpl.prototype.wrapperClassName = function () {
	        return "FullUriTemplateImpl";
	    };
	    return FullUriTemplateImpl;
	})(UriTemplateImpl);
	exports.FullUriTemplateImpl = FullUriTemplateImpl;
	var StatusCodeImpl = (function (_super) {
	    __extends(StatusCodeImpl, _super);
	    function StatusCodeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    StatusCodeImpl.prototype.wrapperClassName = function () {
	        return "StatusCodeImpl";
	    };
	    return StatusCodeImpl;
	})(StringTypeImpl);
	exports.StatusCodeImpl = StatusCodeImpl;
	var FixedUriImpl = (function (_super) {
	    __extends(FixedUriImpl, _super);
	    function FixedUriImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    FixedUriImpl.prototype.wrapperClassName = function () {
	        return "FixedUriImpl";
	    };
	    return FixedUriImpl;
	})(StringTypeImpl);
	exports.FixedUriImpl = FixedUriImpl;
	var ContentTypeImpl = (function (_super) {
	    __extends(ContentTypeImpl, _super);
	    function ContentTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ContentTypeImpl.prototype.wrapperClassName = function () {
	        return "ContentTypeImpl";
	    };
	    return ContentTypeImpl;
	})(StringTypeImpl);
	exports.ContentTypeImpl = ContentTypeImpl;
	var ValidityExpressionImpl = (function (_super) {
	    __extends(ValidityExpressionImpl, _super);
	    function ValidityExpressionImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ValidityExpressionImpl.prototype.wrapperClassName = function () {
	        return "ValidityExpressionImpl";
	    };
	    return ValidityExpressionImpl;
	})(StringTypeImpl);
	exports.ValidityExpressionImpl = ValidityExpressionImpl;
	var DateFormatSpecImpl = (function (_super) {
	    __extends(DateFormatSpecImpl, _super);
	    function DateFormatSpecImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    DateFormatSpecImpl.prototype.wrapperClassName = function () {
	        return "DateFormatSpecImpl";
	    };
	    return DateFormatSpecImpl;
	})(StringTypeImpl);
	exports.DateFormatSpecImpl = DateFormatSpecImpl;
	var FunctionalInterfaceImpl = (function (_super) {
	    __extends(FunctionalInterfaceImpl, _super);
	    function FunctionalInterfaceImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    FunctionalInterfaceImpl.prototype.wrapperClassName = function () {
	        return "FunctionalInterfaceImpl";
	    };
	    return FunctionalInterfaceImpl;
	})(StringTypeImpl);
	exports.FunctionalInterfaceImpl = FunctionalInterfaceImpl;
	var SchemaStringImpl = (function (_super) {
	    __extends(SchemaStringImpl, _super);
	    function SchemaStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    SchemaStringImpl.prototype.wrapperClassName = function () {
	        return "SchemaStringImpl";
	    };
	    return SchemaStringImpl;
	})(StringTypeImpl);
	exports.SchemaStringImpl = SchemaStringImpl;
	var JSonSchemaStringImpl = (function (_super) {
	    __extends(JSonSchemaStringImpl, _super);
	    function JSonSchemaStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    JSonSchemaStringImpl.prototype.wrapperClassName = function () {
	        return "JSonSchemaStringImpl";
	    };
	    return JSonSchemaStringImpl;
	})(SchemaStringImpl);
	exports.JSonSchemaStringImpl = JSonSchemaStringImpl;
	var XMLSchemaStringImpl = (function (_super) {
	    __extends(XMLSchemaStringImpl, _super);
	    function XMLSchemaStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    XMLSchemaStringImpl.prototype.wrapperClassName = function () {
	        return "XMLSchemaStringImpl";
	    };
	    return XMLSchemaStringImpl;
	})(SchemaStringImpl);
	exports.XMLSchemaStringImpl = XMLSchemaStringImpl;
	var ExampleStringImpl = (function (_super) {
	    __extends(ExampleStringImpl, _super);
	    function ExampleStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ExampleStringImpl.prototype.wrapperClassName = function () {
	        return "ExampleStringImpl";
	    };
	    return ExampleStringImpl;
	})(StringTypeImpl);
	exports.ExampleStringImpl = ExampleStringImpl;
	var ScriptingHookImpl = (function (_super) {
	    __extends(ScriptingHookImpl, _super);
	    function ScriptingHookImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ScriptingHookImpl.prototype.wrapperClassName = function () {
	        return "ScriptingHookImpl";
	    };
	    return ScriptingHookImpl;
	})(StringTypeImpl);
	exports.ScriptingHookImpl = ScriptingHookImpl;
	var SecuritySchemaHookScriptImpl = (function (_super) {
	    __extends(SecuritySchemaHookScriptImpl, _super);
	    function SecuritySchemaHookScriptImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    SecuritySchemaHookScriptImpl.prototype.wrapperClassName = function () {
	        return "SecuritySchemaHookScriptImpl";
	    };
	    return SecuritySchemaHookScriptImpl;
	})(ScriptingHookImpl);
	exports.SecuritySchemaHookScriptImpl = SecuritySchemaHookScriptImpl;
	var RAMLPointerImpl = (function (_super) {
	    __extends(RAMLPointerImpl, _super);
	    function RAMLPointerImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    RAMLPointerImpl.prototype.wrapperClassName = function () {
	        return "RAMLPointerImpl";
	    };
	    return RAMLPointerImpl;
	})(StringTypeImpl);
	exports.RAMLPointerImpl = RAMLPointerImpl;
	var RAMLSelectorImpl = (function (_super) {
	    __extends(RAMLSelectorImpl, _super);
	    function RAMLSelectorImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    RAMLSelectorImpl.prototype.wrapperClassName = function () {
	        return "RAMLSelectorImpl";
	    };
	    return RAMLSelectorImpl;
	})(StringTypeImpl);
	exports.RAMLSelectorImpl = RAMLSelectorImpl;
	var MimeTypeImpl = (function (_super) {
	    __extends(MimeTypeImpl, _super);
	    function MimeTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    MimeTypeImpl.prototype.wrapperClassName = function () {
	        return "MimeTypeImpl";
	    };
	    return MimeTypeImpl;
	})(StringTypeImpl);
	exports.MimeTypeImpl = MimeTypeImpl;
	var MarkdownStringImpl = (function (_super) {
	    __extends(MarkdownStringImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function MarkdownStringImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    MarkdownStringImpl.prototype.wrapperClassName = function () {
	        return "MarkdownStringImpl";
	    };
	    return MarkdownStringImpl;
	})(StringTypeImpl);
	exports.MarkdownStringImpl = MarkdownStringImpl;
	var DocumentationItemImpl = (function (_super) {
	    __extends(DocumentationItemImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function DocumentationItemImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createDocumentationItem(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    DocumentationItemImpl.prototype.wrapperClassName = function () {
	        return "DocumentationItemImpl";
	    };
	    /**
	     *
	     **/
	    //title
	    DocumentationItemImpl.prototype.title = function () {
	        return _super.prototype.attribute.call(this, 'title', this.toString);
	    };
	    /**
	     *
	     **/
	    //setTitle
	    DocumentationItemImpl.prototype.setTitle = function (param) {
	        {
	            this.highLevel().attrOrCreate("title").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //content
	    DocumentationItemImpl.prototype.content = function () {
	        return _super.prototype.attribute.call(this, 'content', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    return DocumentationItemImpl;
	})(RAMLLanguageElementImpl);
	exports.DocumentationItemImpl = DocumentationItemImpl;
	var ScriptSpecImpl = (function (_super) {
	    __extends(ScriptSpecImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function ScriptSpecImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createScriptSpec(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ScriptSpecImpl.prototype.wrapperClassName = function () {
	        return "ScriptSpecImpl";
	    };
	    /**
	     *
	     **/
	    //language
	    ScriptSpecImpl.prototype.language = function () {
	        return _super.prototype.attribute.call(this, 'language', this.toString);
	    };
	    /**
	     *
	     **/
	    //setLanguage
	    ScriptSpecImpl.prototype.setLanguage = function (param) {
	        {
	            this.highLevel().attrOrCreate("language").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //content
	    ScriptSpecImpl.prototype.content = function () {
	        return _super.prototype.attribute.call(this, 'content', this.toString);
	    };
	    /**
	     *
	     **/
	    //setContent
	    ScriptSpecImpl.prototype.setContent = function (param) {
	        {
	            this.highLevel().attrOrCreate("content").setValue("" + param);
	            return this;
	        }
	    };
	    return ScriptSpecImpl;
	})(RAMLLanguageElementImpl);
	exports.ScriptSpecImpl = ScriptSpecImpl;
	var ApiDescriptionImpl = (function (_super) {
	    __extends(ApiDescriptionImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function ApiDescriptionImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createApiDescription(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ApiDescriptionImpl.prototype.wrapperClassName = function () {
	        return "ApiDescriptionImpl";
	    };
	    /**
	     *
	     **/
	    //apiFiles
	    ApiDescriptionImpl.prototype.apiFiles = function () {
	        return _super.prototype.elements.call(this, 'apiFiles');
	    };
	    /**
	     *
	     **/
	    //script
	    ApiDescriptionImpl.prototype.script = function () {
	        return _super.prototype.elements.call(this, 'script');
	    };
	    /**
	     *
	     **/
	    //type
	    ApiDescriptionImpl.prototype["type"] = function () {
	        return _super.prototype.attribute.call(this, 'type', this.toString);
	    };
	    /**
	     *
	     **/
	    //setType
	    ApiDescriptionImpl.prototype.setType = function (param) {
	        {
	            this.highLevel().attrOrCreate("type").setValue("" + param);
	            return this;
	        }
	    };
	    return ApiDescriptionImpl;
	})(RAMLLanguageElementImpl);
	exports.ApiDescriptionImpl = ApiDescriptionImpl;
	var CallbackAPIDescriptionImpl = (function (_super) {
	    __extends(CallbackAPIDescriptionImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function CallbackAPIDescriptionImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createCallbackAPIDescription(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    CallbackAPIDescriptionImpl.prototype.wrapperClassName = function () {
	        return "CallbackAPIDescriptionImpl";
	    };
	    /**
	     *
	     **/
	    //callbackFor
	    CallbackAPIDescriptionImpl.prototype.callbackFor = function () {
	        return _super.prototype.element.call(this, 'callbackFor');
	    };
	    return CallbackAPIDescriptionImpl;
	})(ApiDescriptionImpl);
	exports.CallbackAPIDescriptionImpl = CallbackAPIDescriptionImpl;
	var RAMLProjectImpl = (function (_super) {
	    __extends(RAMLProjectImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function RAMLProjectImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createRAMLProject(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    RAMLProjectImpl.prototype.wrapperClassName = function () {
	        return "RAMLProjectImpl";
	    };
	    /**
	     *
	     **/
	    //relatedProjects
	    RAMLProjectImpl.prototype.relatedProjects = function () {
	        return _super.prototype.elements.call(this, 'relatedProjects');
	    };
	    /**
	     *
	     **/
	    //declaredApis
	    RAMLProjectImpl.prototype.declaredApis = function () {
	        return _super.prototype.elements.call(this, 'declaredApis');
	    };
	    /**
	     *
	     **/
	    //license
	    RAMLProjectImpl.prototype.license = function () {
	        return _super.prototype.attribute.call(this, 'license', this.toString);
	    };
	    /**
	     *
	     **/
	    //setLicense
	    RAMLProjectImpl.prototype.setLicense = function (param) {
	        {
	            this.highLevel().attrOrCreate("license").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //overview
	    RAMLProjectImpl.prototype.overview = function () {
	        return _super.prototype.attribute.call(this, 'overview', this.toString);
	    };
	    /**
	     *
	     **/
	    //setOverview
	    RAMLProjectImpl.prototype.setOverview = function (param) {
	        {
	            this.highLevel().attrOrCreate("overview").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //url
	    RAMLProjectImpl.prototype.url = function () {
	        return _super.prototype.attribute.call(this, 'url', this.toString);
	    };
	    /**
	     *
	     **/
	    //setUrl
	    RAMLProjectImpl.prototype.setUrl = function (param) {
	        {
	            this.highLevel().attrOrCreate("url").setValue("" + param);
	            return this;
	        }
	    };
	    return RAMLProjectImpl;
	})(RAMLLanguageElementImpl);
	exports.RAMLProjectImpl = RAMLProjectImpl;
	var SecuritySchemaTypeImpl = (function (_super) {
	    __extends(SecuritySchemaTypeImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function SecuritySchemaTypeImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchemaType(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    SecuritySchemaTypeImpl.prototype.wrapperClassName = function () {
	        return "SecuritySchemaTypeImpl";
	    };
	    /**
	     *
	     **/
	    //requiredSettings
	    SecuritySchemaTypeImpl.prototype.requiredSettings = function () {
	        return _super.prototype.elements.call(this, 'requiredSettings');
	    };
	    /**
	     *
	     **/
	    //describedBy
	    SecuritySchemaTypeImpl.prototype.describedBy = function () {
	        return _super.prototype.element.call(this, 'describedBy');
	    };
	    return SecuritySchemaTypeImpl;
	})(RAMLLanguageElementImpl);
	exports.SecuritySchemaTypeImpl = SecuritySchemaTypeImpl;
	var DataElementImpl = (function (_super) {
	    __extends(DataElementImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function DataElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createDataElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    DataElementImpl.prototype.wrapperClassName = function () {
	        return "DataElementImpl";
	    };
	    /**
	     *
	     **/
	    //name
	    DataElementImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     *
	     **/
	    //setName
	    DataElementImpl.prototype.setName = function (param) {
	        {
	            this.highLevel().attrOrCreate("name").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //xml
	    DataElementImpl.prototype.xml = function () {
	        return _super.prototype.element.call(this, 'xml');
	    };
	    /**
	     *
	     **/
	    //facets
	    DataElementImpl.prototype.facets = function () {
	        return _super.prototype.elements.call(this, 'facets');
	    };
	    /**
	     *
	     **/
	    //schema
	    DataElementImpl.prototype.schema = function () {
	        return _super.prototype.attribute.call(this, 'schema', this.toString);
	    };
	    /**
	     *
	     **/
	    //setSchema
	    DataElementImpl.prototype.setSchema = function (param) {
	        {
	            this.highLevel().attrOrCreate("schema").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //usage
	    DataElementImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /**
	     *
	     **/
	    //setUsage
	    DataElementImpl.prototype.setUsage = function (param) {
	        {
	            this.highLevel().attrOrCreate("usage").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //type
	    DataElementImpl.prototype["type"] = function () {
	        return _super.prototype.attributes.call(this, 'type', this.toString);
	    };
	    /**
	     *
	     **/
	    //setType
	    DataElementImpl.prototype.setType = function (param) {
	        {
	            this.highLevel().attrOrCreate("type").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //location
	    DataElementImpl.prototype.location = function () {
	        return _super.prototype.attribute.call(this, 'location', function (attr) { return new ModelLocationImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //locationKind
	    DataElementImpl.prototype.locationKind = function () {
	        return _super.prototype.attribute.call(this, 'locationKind', function (attr) { return new LocationKindImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //default
	    DataElementImpl.prototype["default"] = function () {
	        return _super.prototype.attribute.call(this, 'default', this.toString);
	    };
	    /**
	     *
	     **/
	    //setDefault
	    DataElementImpl.prototype.setDefault = function (param) {
	        {
	            this.highLevel().attrOrCreate("default").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //example
	    DataElementImpl.prototype.example = function () {
	        return _super.prototype.attribute.call(this, 'example', this.toString);
	    };
	    /**
	     *
	     **/
	    //setExample
	    DataElementImpl.prototype.setExample = function (param) {
	        {
	            this.highLevel().attrOrCreate("example").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //examples
	    DataElementImpl.prototype.examples = function () {
	        return _super.prototype.elements.call(this, 'examples');
	    };
	    /**
	     *
	     **/
	    //repeat
	    DataElementImpl.prototype.repeat = function () {
	        return _super.prototype.attribute.call(this, 'repeat', this.toBoolean);
	    };
	    /**
	     *
	     **/
	    //setRepeat
	    DataElementImpl.prototype.setRepeat = function (param) {
	        {
	            this.highLevel().attrOrCreate("repeat").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //required
	    DataElementImpl.prototype.required = function () {
	        return _super.prototype.attribute.call(this, 'required', this.toBoolean);
	    };
	    /**
	     *
	     **/
	    //setRequired
	    DataElementImpl.prototype.setRequired = function (param) {
	        {
	            this.highLevel().attrOrCreate("required").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //displayName
	    DataElementImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     *
	     **/
	    //setDisplayName
	    DataElementImpl.prototype.setDisplayName = function (param) {
	        {
	            this.highLevel().attrOrCreate("displayName").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //description
	    DataElementImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //annotations
	    DataElementImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    return DataElementImpl;
	})(RAMLLanguageElementImpl);
	exports.DataElementImpl = DataElementImpl;
	var XMLInfoImpl = (function (_super) {
	    __extends(XMLInfoImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function XMLInfoImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createXMLInfo(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    XMLInfoImpl.prototype.wrapperClassName = function () {
	        return "XMLInfoImpl";
	    };
	    /**
	     *
	     **/
	    //name
	    XMLInfoImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     *
	     **/
	    //setName
	    XMLInfoImpl.prototype.setName = function (param) {
	        {
	            this.highLevel().attrOrCreate("name").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //namespace
	    XMLInfoImpl.prototype.namespace = function () {
	        return _super.prototype.attribute.call(this, 'namespace', this.toString);
	    };
	    /**
	     *
	     **/
	    //setNamespace
	    XMLInfoImpl.prototype.setNamespace = function (param) {
	        {
	            this.highLevel().attrOrCreate("namespace").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //prefix
	    XMLInfoImpl.prototype.prefix = function () {
	        return _super.prototype.attribute.call(this, 'prefix', this.toString);
	    };
	    /**
	     *
	     **/
	    //setPrefix
	    XMLInfoImpl.prototype.setPrefix = function (param) {
	        {
	            this.highLevel().attrOrCreate("prefix").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //attribute
	    XMLInfoImpl.prototype.attribute = function () {
	        return _super.prototype.attribute.call(this, 'attribute', this.toBoolean);
	    };
	    /**
	     *
	     **/
	    //setAttribute
	    XMLInfoImpl.prototype.setAttribute = function (param) {
	        {
	            this.highLevel().attrOrCreate("attribute").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //wrapped
	    XMLInfoImpl.prototype.wrapped = function () {
	        return _super.prototype.attribute.call(this, 'wrapped', this.toBoolean);
	    };
	    /**
	     *
	     **/
	    //setWrapped
	    XMLInfoImpl.prototype.setWrapped = function (param) {
	        {
	            this.highLevel().attrOrCreate("wrapped").setValue("" + param);
	            return this;
	        }
	    };
	    return XMLInfoImpl;
	})(BasicNodeImpl);
	exports.XMLInfoImpl = XMLInfoImpl;
	var ModelLocationImpl = (function () {
	    /**
	     *
	     **/
	    //constructor
	    function ModelLocationImpl(attr) {
	        this.attr = attr;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ModelLocationImpl.prototype.wrapperClassName = function () {
	        return "ModelLocationImpl";
	    };
	    return ModelLocationImpl;
	})();
	exports.ModelLocationImpl = ModelLocationImpl;
	var LocationKindImpl = (function () {
	    /**
	     *
	     **/
	    //constructor
	    function LocationKindImpl(attr) {
	        this.attr = attr;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    LocationKindImpl.prototype.wrapperClassName = function () {
	        return "LocationKindImpl";
	    };
	    return LocationKindImpl;
	})();
	exports.LocationKindImpl = LocationKindImpl;
	var ExampleSpecImpl = (function (_super) {
	    __extends(ExampleSpecImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function ExampleSpecImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createExampleSpec(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ExampleSpecImpl.prototype.wrapperClassName = function () {
	        return "ExampleSpecImpl";
	    };
	    /**
	     *
	     **/
	    //content
	    ExampleSpecImpl.prototype.content = function () {
	        return _super.prototype.attribute.call(this, 'content', this.toString);
	    };
	    /**
	     *
	     **/
	    //setContent
	    ExampleSpecImpl.prototype.setContent = function (param) {
	        {
	            this.highLevel().attrOrCreate("content").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //strict
	    ExampleSpecImpl.prototype.strict = function () {
	        return _super.prototype.attribute.call(this, 'strict', this.toBoolean);
	    };
	    /**
	     *
	     **/
	    //setStrict
	    ExampleSpecImpl.prototype.setStrict = function (param) {
	        {
	            this.highLevel().attrOrCreate("strict").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //name
	    ExampleSpecImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     *
	     **/
	    //setName
	    ExampleSpecImpl.prototype.setName = function (param) {
	        {
	            this.highLevel().attrOrCreate("name").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //displayName
	    ExampleSpecImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     *
	     **/
	    //setDisplayName
	    ExampleSpecImpl.prototype.setDisplayName = function (param) {
	        {
	            this.highLevel().attrOrCreate("displayName").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //description
	    ExampleSpecImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //annotations
	    ExampleSpecImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    return ExampleSpecImpl;
	})(RAMLLanguageElementImpl);
	exports.ExampleSpecImpl = ExampleSpecImpl;
	var FileParameterImpl = (function (_super) {
	    __extends(FileParameterImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function FileParameterImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createFileParameter(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    FileParameterImpl.prototype.wrapperClassName = function () {
	        return "FileParameterImpl";
	    };
	    /**
	     *
	     **/
	    //fileTypes
	    FileParameterImpl.prototype.fileTypes = function () {
	        return _super.prototype.attributes.call(this, 'fileTypes', function (attr) { return new ContentTypeImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //minLength
	    FileParameterImpl.prototype.minLength = function () {
	        return _super.prototype.attribute.call(this, 'minLength', this.toNumber);
	    };
	    /**
	     *
	     **/
	    //setMinLength
	    FileParameterImpl.prototype.setMinLength = function (param) {
	        {
	            this.highLevel().attrOrCreate("minLength").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //maxLength
	    FileParameterImpl.prototype.maxLength = function () {
	        return _super.prototype.attribute.call(this, 'maxLength', this.toNumber);
	    };
	    /**
	     *
	     **/
	    //setMaxLength
	    FileParameterImpl.prototype.setMaxLength = function (param) {
	        {
	            this.highLevel().attrOrCreate("maxLength").setValue("" + param);
	            return this;
	        }
	    };
	    return FileParameterImpl;
	})(DataElementImpl);
	exports.FileParameterImpl = FileParameterImpl;
	var ArrayFieldImpl = (function (_super) {
	    __extends(ArrayFieldImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function ArrayFieldImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createArrayField(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ArrayFieldImpl.prototype.wrapperClassName = function () {
	        return "ArrayFieldImpl";
	    };
	    /**
	     *
	     **/
	    //uniqueItems
	    ArrayFieldImpl.prototype.uniqueItems = function () {
	        return _super.prototype.attribute.call(this, 'uniqueItems', this.toBoolean);
	    };
	    /**
	     *
	     **/
	    //setUniqueItems
	    ArrayFieldImpl.prototype.setUniqueItems = function (param) {
	        {
	            this.highLevel().attrOrCreate("uniqueItems").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //items
	    ArrayFieldImpl.prototype.items = function () {
	        return _super.prototype.element.call(this, 'items');
	    };
	    /**
	     *
	     **/
	    //minItems
	    ArrayFieldImpl.prototype.minItems = function () {
	        return _super.prototype.attribute.call(this, 'minItems', this.toNumber);
	    };
	    /**
	     *
	     **/
	    //setMinItems
	    ArrayFieldImpl.prototype.setMinItems = function (param) {
	        {
	            this.highLevel().attrOrCreate("minItems").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //maxItems
	    ArrayFieldImpl.prototype.maxItems = function () {
	        return _super.prototype.attribute.call(this, 'maxItems', this.toNumber);
	    };
	    /**
	     *
	     **/
	    //setMaxItems
	    ArrayFieldImpl.prototype.setMaxItems = function (param) {
	        {
	            this.highLevel().attrOrCreate("maxItems").setValue("" + param);
	            return this;
	        }
	    };
	    return ArrayFieldImpl;
	})(DataElementImpl);
	exports.ArrayFieldImpl = ArrayFieldImpl;
	var UnionFieldImpl = (function (_super) {
	    __extends(UnionFieldImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function UnionFieldImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createUnionField(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    UnionFieldImpl.prototype.wrapperClassName = function () {
	        return "UnionFieldImpl";
	    };
	    /**
	     *
	     **/
	    //discriminator
	    UnionFieldImpl.prototype.discriminator = function () {
	        return _super.prototype.attribute.call(this, 'discriminator', this.toString);
	    };
	    /**
	     *
	     **/
	    //setDiscriminator
	    UnionFieldImpl.prototype.setDiscriminator = function (param) {
	        {
	            this.highLevel().attrOrCreate("discriminator").setValue("" + param);
	            return this;
	        }
	    };
	    return UnionFieldImpl;
	})(DataElementImpl);
	exports.UnionFieldImpl = UnionFieldImpl;
	var ObjectFieldImpl = (function (_super) {
	    __extends(ObjectFieldImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function ObjectFieldImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createObjectField(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ObjectFieldImpl.prototype.wrapperClassName = function () {
	        return "ObjectFieldImpl";
	    };
	    /**
	     *
	     **/
	    //properties
	    ObjectFieldImpl.prototype.properties = function () {
	        return _super.prototype.elements.call(this, 'properties');
	    };
	    /**
	     *
	     **/
	    //minProperties
	    ObjectFieldImpl.prototype.minProperties = function () {
	        return _super.prototype.attribute.call(this, 'minProperties', this.toNumber);
	    };
	    /**
	     *
	     **/
	    //setMinProperties
	    ObjectFieldImpl.prototype.setMinProperties = function (param) {
	        {
	            this.highLevel().attrOrCreate("minProperties").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //maxProperties
	    ObjectFieldImpl.prototype.maxProperties = function () {
	        return _super.prototype.attribute.call(this, 'maxProperties', this.toNumber);
	    };
	    /**
	     *
	     **/
	    //setMaxProperties
	    ObjectFieldImpl.prototype.setMaxProperties = function (param) {
	        {
	            this.highLevel().attrOrCreate("maxProperties").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //additionalProperties
	    ObjectFieldImpl.prototype.additionalProperties = function () {
	        return _super.prototype.element.call(this, 'additionalProperties');
	    };
	    /**
	     *
	     **/
	    //patternProperties
	    ObjectFieldImpl.prototype.patternProperties = function () {
	        return _super.prototype.elements.call(this, 'patternProperties');
	    };
	    /**
	     *
	     **/
	    //discriminator
	    ObjectFieldImpl.prototype.discriminator = function () {
	        return _super.prototype.attribute.call(this, 'discriminator', function (attr) { return new pointerImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //discriminatorValue
	    ObjectFieldImpl.prototype.discriminatorValue = function () {
	        return _super.prototype.attribute.call(this, 'discriminatorValue', this.toString);
	    };
	    /**
	     *
	     **/
	    //setDiscriminatorValue
	    ObjectFieldImpl.prototype.setDiscriminatorValue = function (param) {
	        {
	            this.highLevel().attrOrCreate("discriminatorValue").setValue("" + param);
	            return this;
	        }
	    };
	    return ObjectFieldImpl;
	})(DataElementImpl);
	exports.ObjectFieldImpl = ObjectFieldImpl;
	var StrElementImpl = (function (_super) {
	    __extends(StrElementImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function StrElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createStrElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    StrElementImpl.prototype.wrapperClassName = function () {
	        return "StrElementImpl";
	    };
	    /**
	     *
	     **/
	    //pattern
	    StrElementImpl.prototype.pattern = function () {
	        return _super.prototype.attribute.call(this, 'pattern', this.toString);
	    };
	    /**
	     *
	     **/
	    //setPattern
	    StrElementImpl.prototype.setPattern = function (param) {
	        {
	            this.highLevel().attrOrCreate("pattern").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //minLength
	    StrElementImpl.prototype.minLength = function () {
	        return _super.prototype.attribute.call(this, 'minLength', this.toNumber);
	    };
	    /**
	     *
	     **/
	    //setMinLength
	    StrElementImpl.prototype.setMinLength = function (param) {
	        {
	            this.highLevel().attrOrCreate("minLength").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //maxLength
	    StrElementImpl.prototype.maxLength = function () {
	        return _super.prototype.attribute.call(this, 'maxLength', this.toNumber);
	    };
	    /**
	     *
	     **/
	    //setMaxLength
	    StrElementImpl.prototype.setMaxLength = function (param) {
	        {
	            this.highLevel().attrOrCreate("maxLength").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //enum
	    StrElementImpl.prototype.enum = function () {
	        return _super.prototype.attributes.call(this, 'enum', this.toString);
	    };
	    /**
	     *
	     **/
	    //setEnum
	    StrElementImpl.prototype.setEnum = function (param) {
	        {
	            this.highLevel().attrOrCreate("enum").setValue("" + param);
	            return this;
	        }
	    };
	    return StrElementImpl;
	})(DataElementImpl);
	exports.StrElementImpl = StrElementImpl;
	var BooleanElementImpl = (function (_super) {
	    __extends(BooleanElementImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function BooleanElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createBooleanElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    BooleanElementImpl.prototype.wrapperClassName = function () {
	        return "BooleanElementImpl";
	    };
	    return BooleanElementImpl;
	})(DataElementImpl);
	exports.BooleanElementImpl = BooleanElementImpl;
	var ValueElementImpl = (function (_super) {
	    __extends(ValueElementImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function ValueElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createValueElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ValueElementImpl.prototype.wrapperClassName = function () {
	        return "ValueElementImpl";
	    };
	    return ValueElementImpl;
	})(DataElementImpl);
	exports.ValueElementImpl = ValueElementImpl;
	var NumberElementImpl = (function (_super) {
	    __extends(NumberElementImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function NumberElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createNumberElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    NumberElementImpl.prototype.wrapperClassName = function () {
	        return "NumberElementImpl";
	    };
	    /**
	     *
	     **/
	    //minimum
	    NumberElementImpl.prototype.minimum = function () {
	        return _super.prototype.attribute.call(this, 'minimum', this.toNumber);
	    };
	    /**
	     *
	     **/
	    //setMinimum
	    NumberElementImpl.prototype.setMinimum = function (param) {
	        {
	            this.highLevel().attrOrCreate("minimum").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //maximum
	    NumberElementImpl.prototype.maximum = function () {
	        return _super.prototype.attribute.call(this, 'maximum', this.toNumber);
	    };
	    /**
	     *
	     **/
	    //setMaximum
	    NumberElementImpl.prototype.setMaximum = function (param) {
	        {
	            this.highLevel().attrOrCreate("maximum").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //enum
	    NumberElementImpl.prototype.enum = function () {
	        return _super.prototype.attributes.call(this, 'enum', this.toString);
	    };
	    /**
	     *
	     **/
	    //setEnum
	    NumberElementImpl.prototype.setEnum = function (param) {
	        {
	            this.highLevel().attrOrCreate("enum").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //format
	    NumberElementImpl.prototype.format = function () {
	        return _super.prototype.attribute.call(this, 'format', this.toString);
	    };
	    /**
	     *
	     **/
	    //setFormat
	    NumberElementImpl.prototype.setFormat = function (param) {
	        {
	            this.highLevel().attrOrCreate("format").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //multipleOf
	    NumberElementImpl.prototype.multipleOf = function () {
	        return _super.prototype.attribute.call(this, 'multipleOf', this.toNumber);
	    };
	    /**
	     *
	     **/
	    //setMultipleOf
	    NumberElementImpl.prototype.setMultipleOf = function (param) {
	        {
	            this.highLevel().attrOrCreate("multipleOf").setValue("" + param);
	            return this;
	        }
	    };
	    return NumberElementImpl;
	})(DataElementImpl);
	exports.NumberElementImpl = NumberElementImpl;
	var IntegerElementImpl = (function (_super) {
	    __extends(IntegerElementImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function IntegerElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createIntegerElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    IntegerElementImpl.prototype.wrapperClassName = function () {
	        return "IntegerElementImpl";
	    };
	    /**
	     *
	     **/
	    //format
	    IntegerElementImpl.prototype.format = function () {
	        return _super.prototype.attribute.call(this, 'format', this.toString);
	    };
	    /**
	     *
	     **/
	    //setFormat
	    IntegerElementImpl.prototype.setFormat = function (param) {
	        {
	            this.highLevel().attrOrCreate("format").setValue("" + param);
	            return this;
	        }
	    };
	    return IntegerElementImpl;
	})(NumberElementImpl);
	exports.IntegerElementImpl = IntegerElementImpl;
	var RAMLPointerElementImpl = (function (_super) {
	    __extends(RAMLPointerElementImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function RAMLPointerElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createRAMLPointerElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    RAMLPointerElementImpl.prototype.wrapperClassName = function () {
	        return "RAMLPointerElementImpl";
	    };
	    /**
	     *
	     **/
	    //target
	    RAMLPointerElementImpl.prototype.target = function () {
	        return _super.prototype.attribute.call(this, 'target', function (attr) { return new RAMLSelectorImpl(attr); });
	    };
	    return RAMLPointerElementImpl;
	})(DataElementImpl);
	exports.RAMLPointerElementImpl = RAMLPointerElementImpl;
	var RAMLExpressionImpl = (function (_super) {
	    __extends(RAMLExpressionImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function RAMLExpressionImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createRAMLExpression(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    RAMLExpressionImpl.prototype.wrapperClassName = function () {
	        return "RAMLExpressionImpl";
	    };
	    return RAMLExpressionImpl;
	})(DataElementImpl);
	exports.RAMLExpressionImpl = RAMLExpressionImpl;
	var ScriptHookElementImpl = (function (_super) {
	    __extends(ScriptHookElementImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function ScriptHookElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createScriptHookElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ScriptHookElementImpl.prototype.wrapperClassName = function () {
	        return "ScriptHookElementImpl";
	    };
	    /**
	     *
	     **/
	    //declaredIn
	    ScriptHookElementImpl.prototype.declaredIn = function () {
	        return _super.prototype.attribute.call(this, 'declaredIn', this.toString);
	    };
	    /**
	     *
	     **/
	    //setDeclaredIn
	    ScriptHookElementImpl.prototype.setDeclaredIn = function (param) {
	        {
	            this.highLevel().attrOrCreate("declaredIn").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //interfaceName
	    ScriptHookElementImpl.prototype.interfaceName = function () {
	        return _super.prototype.attribute.call(this, 'interfaceName', this.toString);
	    };
	    /**
	     *
	     **/
	    //setInterfaceName
	    ScriptHookElementImpl.prototype.setInterfaceName = function (param) {
	        {
	            this.highLevel().attrOrCreate("interfaceName").setValue("" + param);
	            return this;
	        }
	    };
	    return ScriptHookElementImpl;
	})(DataElementImpl);
	exports.ScriptHookElementImpl = ScriptHookElementImpl;
	var SchemaElementImpl = (function (_super) {
	    __extends(SchemaElementImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function SchemaElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createSchemaElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    SchemaElementImpl.prototype.wrapperClassName = function () {
	        return "SchemaElementImpl";
	    };
	    return SchemaElementImpl;
	})(DataElementImpl);
	exports.SchemaElementImpl = SchemaElementImpl;
	var DateElementImpl = (function (_super) {
	    __extends(DateElementImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function DateElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createDateElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    DateElementImpl.prototype.wrapperClassName = function () {
	        return "DateElementImpl";
	    };
	    /**
	     *
	     **/
	    //dateFormat
	    DateElementImpl.prototype.dateFormat = function () {
	        return _super.prototype.attribute.call(this, 'dateFormat', function (attr) { return new DateFormatSpecImpl(attr); });
	    };
	    return DateElementImpl;
	})(DataElementImpl);
	exports.DateElementImpl = DateElementImpl;
	var HasNormalParametersImpl = (function (_super) {
	    __extends(HasNormalParametersImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function HasNormalParametersImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createHasNormalParameters(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    HasNormalParametersImpl.prototype.wrapperClassName = function () {
	        return "HasNormalParametersImpl";
	    };
	    /**
	     *
	     **/
	    //queryParameters
	    HasNormalParametersImpl.prototype.queryParameters = function () {
	        return _super.prototype.elements.call(this, 'queryParameters');
	    };
	    /**
	     *
	     **/
	    //headers
	    HasNormalParametersImpl.prototype.headers = function () {
	        return _super.prototype.elements.call(this, 'headers');
	    };
	    /**
	     *
	     **/
	    //queryString
	    HasNormalParametersImpl.prototype.queryString = function () {
	        return _super.prototype.element.call(this, 'queryString');
	    };
	    return HasNormalParametersImpl;
	})(RAMLLanguageElementImpl);
	exports.HasNormalParametersImpl = HasNormalParametersImpl;
	var MethodBaseImpl = (function (_super) {
	    __extends(MethodBaseImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function MethodBaseImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createMethodBase(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    MethodBaseImpl.prototype.wrapperClassName = function () {
	        return "MethodBaseImpl";
	    };
	    /**
	     *
	     **/
	    //responses
	    MethodBaseImpl.prototype.responses = function () {
	        return _super.prototype.elements.call(this, 'responses');
	    };
	    /**
	     *
	     **/
	    //body
	    MethodBaseImpl.prototype.body = function () {
	        return _super.prototype.elements.call(this, 'body');
	    };
	    /**
	     *
	     **/
	    //protocols
	    MethodBaseImpl.prototype.protocols = function () {
	        return _super.prototype.attributes.call(this, 'protocols', this.toString);
	    };
	    /**
	     *
	     **/
	    //setProtocols
	    MethodBaseImpl.prototype.setProtocols = function (param) {
	        {
	            this.highLevel().attrOrCreate("protocols").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //is
	    MethodBaseImpl.prototype.is = function () {
	        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //securedBy
	    MethodBaseImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
	    };
	    return MethodBaseImpl;
	})(HasNormalParametersImpl);
	exports.MethodBaseImpl = MethodBaseImpl;
	var ResponseImpl = (function (_super) {
	    __extends(ResponseImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function ResponseImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createResponse(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ResponseImpl.prototype.wrapperClassName = function () {
	        return "ResponseImpl";
	    };
	    /**
	     *
	     **/
	    //code
	    ResponseImpl.prototype.code = function () {
	        return _super.prototype.attribute.call(this, 'code', function (attr) { return new StatusCodeImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //headers
	    ResponseImpl.prototype.headers = function () {
	        return _super.prototype.elements.call(this, 'headers');
	    };
	    /**
	     *
	     **/
	    //body
	    ResponseImpl.prototype.body = function () {
	        return _super.prototype.elements.call(this, 'body');
	    };
	    /**
	     *
	     **/
	    //displayName
	    ResponseImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     *
	     **/
	    //setDisplayName
	    ResponseImpl.prototype.setDisplayName = function (param) {
	        {
	            this.highLevel().attrOrCreate("displayName").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //description
	    ResponseImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //annotations
	    ResponseImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    return ResponseImpl;
	})(RAMLLanguageElementImpl);
	exports.ResponseImpl = ResponseImpl;
	var TraitImpl = (function (_super) {
	    __extends(TraitImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function TraitImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createTrait(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    TraitImpl.prototype.wrapperClassName = function () {
	        return "TraitImpl";
	    };
	    /**
	     *
	     **/
	    //name
	    TraitImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     *
	     **/
	    //setName
	    TraitImpl.prototype.setName = function (param) {
	        {
	            this.highLevel().attrOrCreate("name").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //usage
	    TraitImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /**
	     *
	     **/
	    //setUsage
	    TraitImpl.prototype.setUsage = function (param) {
	        {
	            this.highLevel().attrOrCreate("usage").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //uses
	    TraitImpl.prototype.uses = function () {
	        return _super.prototype.elements.call(this, 'uses');
	    };
	    return TraitImpl;
	})(MethodBaseImpl);
	exports.TraitImpl = TraitImpl;
	var LibraryImpl = (function (_super) {
	    __extends(LibraryImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function LibraryImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createLibrary(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    LibraryImpl.prototype.wrapperClassName = function () {
	        return "LibraryImpl";
	    };
	    /**
	     *
	     **/
	    //name
	    LibraryImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     *
	     **/
	    //setName
	    LibraryImpl.prototype.setName = function (param) {
	        {
	            this.highLevel().attrOrCreate("name").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //schemas
	    LibraryImpl.prototype.schemas = function () {
	        return _super.prototype.elements.call(this, 'schemas');
	    };
	    /**
	     *
	     **/
	    //usage
	    LibraryImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /**
	     *
	     **/
	    //setUsage
	    LibraryImpl.prototype.setUsage = function (param) {
	        {
	            this.highLevel().attrOrCreate("usage").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //annotations
	    LibraryImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //types
	    LibraryImpl.prototype.types = function () {
	        return _super.prototype.elements.call(this, 'types');
	    };
	    /**
	     *
	     **/
	    //traits
	    LibraryImpl.prototype.traits = function () {
	        return _super.prototype.elements.call(this, 'traits');
	    };
	    /**
	     *
	     **/
	    //resourceTypes
	    LibraryImpl.prototype.resourceTypes = function () {
	        return _super.prototype.elements.call(this, 'resourceTypes');
	    };
	    /**
	     *
	     **/
	    //annotationTypes
	    LibraryImpl.prototype.annotationTypes = function () {
	        return _super.prototype.elements.call(this, 'annotationTypes');
	    };
	    /**
	     *
	     **/
	    //securitySchemaTypes
	    LibraryImpl.prototype.securitySchemaTypes = function () {
	        return _super.prototype.elements.call(this, 'securitySchemaTypes');
	    };
	    /**
	     *
	     **/
	    //securitySchemes
	    LibraryImpl.prototype.securitySchemes = function () {
	        return _super.prototype.elements.call(this, 'securitySchemes');
	    };
	    /**
	     *
	     **/
	    //uses
	    LibraryImpl.prototype.uses = function () {
	        return _super.prototype.elements.call(this, 'uses');
	    };
	    return LibraryImpl;
	})(BasicNodeImpl);
	exports.LibraryImpl = LibraryImpl;
	var RAMLSimpleElementImpl = (function (_super) {
	    __extends(RAMLSimpleElementImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function RAMLSimpleElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createRAMLSimpleElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    RAMLSimpleElementImpl.prototype.wrapperClassName = function () {
	        return "RAMLSimpleElementImpl";
	    };
	    return RAMLSimpleElementImpl;
	})(BasicNodeImpl);
	exports.RAMLSimpleElementImpl = RAMLSimpleElementImpl;
	var ImportDeclarationImpl = (function (_super) {
	    __extends(ImportDeclarationImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function ImportDeclarationImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createImportDeclaration(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ImportDeclarationImpl.prototype.wrapperClassName = function () {
	        return "ImportDeclarationImpl";
	    };
	    /**
	     *
	     **/
	    //key
	    ImportDeclarationImpl.prototype.key = function () {
	        return _super.prototype.attribute.call(this, 'key', this.toString);
	    };
	    /**
	     *
	     **/
	    //setKey
	    ImportDeclarationImpl.prototype.setKey = function (param) {
	        {
	            this.highLevel().attrOrCreate("key").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //value
	    ImportDeclarationImpl.prototype.value = function () {
	        return _super.prototype.element.call(this, 'value');
	    };
	    return ImportDeclarationImpl;
	})(RAMLSimpleElementImpl);
	exports.ImportDeclarationImpl = ImportDeclarationImpl;
	var GlobalSchemaImpl = (function (_super) {
	    __extends(GlobalSchemaImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function GlobalSchemaImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createGlobalSchema(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    GlobalSchemaImpl.prototype.wrapperClassName = function () {
	        return "GlobalSchemaImpl";
	    };
	    /**
	     *
	     **/
	    //key
	    GlobalSchemaImpl.prototype.key = function () {
	        return _super.prototype.attribute.call(this, 'key', this.toString);
	    };
	    /**
	     *
	     **/
	    //setKey
	    GlobalSchemaImpl.prototype.setKey = function (param) {
	        {
	            this.highLevel().attrOrCreate("key").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //value
	    GlobalSchemaImpl.prototype.value = function () {
	        return _super.prototype.attribute.call(this, 'value', function (attr) { return new SchemaStringImpl(attr); });
	    };
	    return GlobalSchemaImpl;
	})(RAMLSimpleElementImpl);
	exports.GlobalSchemaImpl = GlobalSchemaImpl;
	var ResourceBaseImpl = (function (_super) {
	    __extends(ResourceBaseImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function ResourceBaseImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createResourceBase(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ResourceBaseImpl.prototype.wrapperClassName = function () {
	        return "ResourceBaseImpl";
	    };
	    /**
	     *
	     **/
	    //methods
	    ResourceBaseImpl.prototype.methods = function () {
	        return _super.prototype.elements.call(this, 'methods');
	    };
	    /**
	     *
	     **/
	    //is
	    ResourceBaseImpl.prototype.is = function () {
	        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //type
	    ResourceBaseImpl.prototype["type"] = function () {
	        return _super.prototype.attribute.call(this, 'type', function (attr) { return new ResourceTypeRefImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //securedBy
	    ResourceBaseImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //uriParameters
	    ResourceBaseImpl.prototype.uriParameters = function () {
	        return _super.prototype.elements.call(this, 'uriParameters');
	    };
	    return ResourceBaseImpl;
	})(RAMLLanguageElementImpl);
	exports.ResourceBaseImpl = ResourceBaseImpl;
	var MethodImpl = (function (_super) {
	    __extends(MethodImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function MethodImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createMethod(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    MethodImpl.prototype.wrapperClassName = function () {
	        return "MethodImpl";
	    };
	    /**
	     *
	     **/
	    //signature
	    MethodImpl.prototype.signature = function () {
	        return _super.prototype.attribute.call(this, 'signature', function (attr) { return new SchemaStringImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //method
	    MethodImpl.prototype.method = function () {
	        return _super.prototype.attribute.call(this, 'method', this.toString);
	    };
	    /**
	     *
	     **/
	    //setMethod
	    MethodImpl.prototype.setMethod = function (param) {
	        {
	            this.highLevel().attrOrCreate("method").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //displayName
	    MethodImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     *
	     **/
	    //setDisplayName
	    MethodImpl.prototype.setDisplayName = function (param) {
	        {
	            this.highLevel().attrOrCreate("displayName").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //description
	    MethodImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //queryString
	    MethodImpl.prototype.queryString = function () {
	        return _super.prototype.element.call(this, 'queryString');
	    };
	    /**
	     *
	     **/
	    //queryParameters
	    MethodImpl.prototype.queryParameters = function () {
	        return _super.prototype.elements.call(this, 'queryParameters');
	    };
	    /**
	     *
	     **/
	    //headers
	    MethodImpl.prototype.headers = function () {
	        return _super.prototype.elements.call(this, 'headers');
	    };
	    /**
	     *
	     **/
	    //body
	    MethodImpl.prototype.body = function () {
	        return _super.prototype.elements.call(this, 'body');
	    };
	    /**
	     *
	     **/
	    //is
	    MethodImpl.prototype.is = function () {
	        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //annotations
	    MethodImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //securedBy
	    MethodImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
	    };
	    return MethodImpl;
	})(MethodBaseImpl);
	exports.MethodImpl = MethodImpl;
	var ResourceImpl = (function (_super) {
	    __extends(ResourceImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function ResourceImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createResource(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ResourceImpl.prototype.wrapperClassName = function () {
	        return "ResourceImpl";
	    };
	    /**
	     *
	     **/
	    //signature
	    ResourceImpl.prototype.signature = function () {
	        return _super.prototype.attribute.call(this, 'signature', function (attr) { return new SchemaStringImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //relativeUri
	    ResourceImpl.prototype.relativeUri = function () {
	        return _super.prototype.attribute.call(this, 'relativeUri', function (attr) { return new RelativeUriImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //resources
	    ResourceImpl.prototype.resources = function () {
	        return _super.prototype.elements.call(this, 'resources');
	    };
	    /**
	     *
	     **/
	    //displayName
	    ResourceImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     *
	     **/
	    //setDisplayName
	    ResourceImpl.prototype.setDisplayName = function (param) {
	        {
	            this.highLevel().attrOrCreate("displayName").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //description
	    ResourceImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //annotations
	    ResourceImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    return ResourceImpl;
	})(ResourceBaseImpl);
	exports.ResourceImpl = ResourceImpl;
	var ResourceTypeImpl = (function (_super) {
	    __extends(ResourceTypeImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function ResourceTypeImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createResourceType(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ResourceTypeImpl.prototype.wrapperClassName = function () {
	        return "ResourceTypeImpl";
	    };
	    /**
	     *
	     **/
	    //name
	    ResourceTypeImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     *
	     **/
	    //setName
	    ResourceTypeImpl.prototype.setName = function (param) {
	        {
	            this.highLevel().attrOrCreate("name").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //usage
	    ResourceTypeImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /**
	     *
	     **/
	    //setUsage
	    ResourceTypeImpl.prototype.setUsage = function (param) {
	        {
	            this.highLevel().attrOrCreate("usage").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //uses
	    ResourceTypeImpl.prototype.uses = function () {
	        return _super.prototype.elements.call(this, 'uses');
	    };
	    return ResourceTypeImpl;
	})(ResourceBaseImpl);
	exports.ResourceTypeImpl = ResourceTypeImpl;
	var AnnotationTypeImpl = (function (_super) {
	    __extends(AnnotationTypeImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function AnnotationTypeImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createAnnotationType(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    AnnotationTypeImpl.prototype.wrapperClassName = function () {
	        return "AnnotationTypeImpl";
	    };
	    /**
	     *
	     **/
	    //name
	    AnnotationTypeImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     *
	     **/
	    //setName
	    AnnotationTypeImpl.prototype.setName = function (param) {
	        {
	            this.highLevel().attrOrCreate("name").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //usage
	    AnnotationTypeImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /**
	     *
	     **/
	    //setUsage
	    AnnotationTypeImpl.prototype.setUsage = function (param) {
	        {
	            this.highLevel().attrOrCreate("usage").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //properties
	    AnnotationTypeImpl.prototype.properties = function () {
	        return _super.prototype.elements.call(this, 'properties');
	    };
	    /**
	     *
	     **/
	    //allowMultiple
	    AnnotationTypeImpl.prototype.allowMultiple = function () {
	        return _super.prototype.attribute.call(this, 'allowMultiple', this.toBoolean);
	    };
	    /**
	     *
	     **/
	    //setAllowMultiple
	    AnnotationTypeImpl.prototype.setAllowMultiple = function (param) {
	        {
	            this.highLevel().attrOrCreate("allowMultiple").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //allowedTargets
	    AnnotationTypeImpl.prototype.allowedTargets = function () {
	        return _super.prototype.attributes.call(this, 'allowedTargets', function (attr) { return new AnnotationTargetImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //displayName
	    AnnotationTypeImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     *
	     **/
	    //setDisplayName
	    AnnotationTypeImpl.prototype.setDisplayName = function (param) {
	        {
	            this.highLevel().attrOrCreate("displayName").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //description
	    AnnotationTypeImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    return AnnotationTypeImpl;
	})(RAMLLanguageElementImpl);
	exports.AnnotationTypeImpl = AnnotationTypeImpl;
	var SecuritySchemaImpl = (function (_super) {
	    __extends(SecuritySchemaImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function SecuritySchemaImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchema(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    SecuritySchemaImpl.prototype.wrapperClassName = function () {
	        return "SecuritySchemaImpl";
	    };
	    /**
	     *
	     **/
	    //name
	    SecuritySchemaImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     *
	     **/
	    //setName
	    SecuritySchemaImpl.prototype.setName = function (param) {
	        {
	            this.highLevel().attrOrCreate("name").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //type
	    SecuritySchemaImpl.prototype["type"] = function () {
	        return _super.prototype.attribute.call(this, 'type', this.toString);
	    };
	    /**
	     *
	     **/
	    //setType
	    SecuritySchemaImpl.prototype.setType = function (param) {
	        {
	            this.highLevel().attrOrCreate("type").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //description
	    SecuritySchemaImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //describedBy
	    SecuritySchemaImpl.prototype.describedBy = function () {
	        return _super.prototype.element.call(this, 'describedBy');
	    };
	    /**
	     *
	     **/
	    //settings
	    SecuritySchemaImpl.prototype.settings = function () {
	        return _super.prototype.element.call(this, 'settings');
	    };
	    return SecuritySchemaImpl;
	})(RAMLLanguageElementImpl);
	exports.SecuritySchemaImpl = SecuritySchemaImpl;
	var SecuritySchemaSettingsImpl = (function (_super) {
	    __extends(SecuritySchemaSettingsImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function SecuritySchemaSettingsImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchemaSettings(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    SecuritySchemaSettingsImpl.prototype.wrapperClassName = function () {
	        return "SecuritySchemaSettingsImpl";
	    };
	    return SecuritySchemaSettingsImpl;
	})(BasicNodeImpl);
	exports.SecuritySchemaSettingsImpl = SecuritySchemaSettingsImpl;
	var OAuth1SecuritySchemeSettingsImpl = (function (_super) {
	    __extends(OAuth1SecuritySchemeSettingsImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function OAuth1SecuritySchemeSettingsImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth1SecuritySchemeSettings(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    OAuth1SecuritySchemeSettingsImpl.prototype.wrapperClassName = function () {
	        return "OAuth1SecuritySchemeSettingsImpl";
	    };
	    /**
	     *
	     **/
	    //requestTokenUri
	    OAuth1SecuritySchemeSettingsImpl.prototype.requestTokenUri = function () {
	        return _super.prototype.attribute.call(this, 'requestTokenUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //authorizationUri
	    OAuth1SecuritySchemeSettingsImpl.prototype.authorizationUri = function () {
	        return _super.prototype.attribute.call(this, 'authorizationUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //tokenCredentialsUri
	    OAuth1SecuritySchemeSettingsImpl.prototype.tokenCredentialsUri = function () {
	        return _super.prototype.attribute.call(this, 'tokenCredentialsUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //signatures
	    OAuth1SecuritySchemeSettingsImpl.prototype.signatures = function () {
	        return _super.prototype.attributes.call(this, 'signatures', this.toString);
	    };
	    /**
	     *
	     **/
	    //setSignatures
	    OAuth1SecuritySchemeSettingsImpl.prototype.setSignatures = function (param) {
	        {
	            this.highLevel().attrOrCreate("signatures").setValue("" + param);
	            return this;
	        }
	    };
	    return OAuth1SecuritySchemeSettingsImpl;
	})(SecuritySchemaSettingsImpl);
	exports.OAuth1SecuritySchemeSettingsImpl = OAuth1SecuritySchemeSettingsImpl;
	var OAuth2SecuritySchemeSettingsImpl = (function (_super) {
	    __extends(OAuth2SecuritySchemeSettingsImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function OAuth2SecuritySchemeSettingsImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth2SecuritySchemeSettings(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    OAuth2SecuritySchemeSettingsImpl.prototype.wrapperClassName = function () {
	        return "OAuth2SecuritySchemeSettingsImpl";
	    };
	    /**
	     *
	     **/
	    //accessTokenUri
	    OAuth2SecuritySchemeSettingsImpl.prototype.accessTokenUri = function () {
	        return _super.prototype.attribute.call(this, 'accessTokenUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //authorizationUri
	    OAuth2SecuritySchemeSettingsImpl.prototype.authorizationUri = function () {
	        return _super.prototype.attribute.call(this, 'authorizationUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //authorizationGrants
	    OAuth2SecuritySchemeSettingsImpl.prototype.authorizationGrants = function () {
	        return _super.prototype.attributes.call(this, 'authorizationGrants', this.toString);
	    };
	    /**
	     *
	     **/
	    //setAuthorizationGrants
	    OAuth2SecuritySchemeSettingsImpl.prototype.setAuthorizationGrants = function (param) {
	        {
	            this.highLevel().attrOrCreate("authorizationGrants").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //scopes
	    OAuth2SecuritySchemeSettingsImpl.prototype.scopes = function () {
	        return _super.prototype.attributes.call(this, 'scopes', this.toString);
	    };
	    /**
	     *
	     **/
	    //setScopes
	    OAuth2SecuritySchemeSettingsImpl.prototype.setScopes = function (param) {
	        {
	            this.highLevel().attrOrCreate("scopes").setValue("" + param);
	            return this;
	        }
	    };
	    return OAuth2SecuritySchemeSettingsImpl;
	})(SecuritySchemaSettingsImpl);
	exports.OAuth2SecuritySchemeSettingsImpl = OAuth2SecuritySchemeSettingsImpl;
	var PassThroughSettingsImpl = (function (_super) {
	    __extends(PassThroughSettingsImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function PassThroughSettingsImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createPassThroughSettings(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    PassThroughSettingsImpl.prototype.wrapperClassName = function () {
	        return "PassThroughSettingsImpl";
	    };
	    /**
	     *
	     **/
	    //queryParameterName
	    PassThroughSettingsImpl.prototype.queryParameterName = function () {
	        return _super.prototype.attribute.call(this, 'queryParameterName', this.toString);
	    };
	    /**
	     *
	     **/
	    //setQueryParameterName
	    PassThroughSettingsImpl.prototype.setQueryParameterName = function (param) {
	        {
	            this.highLevel().attrOrCreate("queryParameterName").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //headerName
	    PassThroughSettingsImpl.prototype.headerName = function () {
	        return _super.prototype.attribute.call(this, 'headerName', this.toString);
	    };
	    /**
	     *
	     **/
	    //setHeaderName
	    PassThroughSettingsImpl.prototype.setHeaderName = function (param) {
	        {
	            this.highLevel().attrOrCreate("headerName").setValue("" + param);
	            return this;
	        }
	    };
	    return PassThroughSettingsImpl;
	})(SecuritySchemaSettingsImpl);
	exports.PassThroughSettingsImpl = PassThroughSettingsImpl;
	var Oath2Impl = (function (_super) {
	    __extends(Oath2Impl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function Oath2Impl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createOath2(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    Oath2Impl.prototype.wrapperClassName = function () {
	        return "Oath2Impl";
	    };
	    /**
	     *
	     **/
	    //settings
	    Oath2Impl.prototype.settings = function () {
	        return _super.prototype.element.call(this, 'settings');
	    };
	    return Oath2Impl;
	})(SecuritySchemaImpl);
	exports.Oath2Impl = Oath2Impl;
	var Oath1Impl = (function (_super) {
	    __extends(Oath1Impl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function Oath1Impl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createOath1(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    Oath1Impl.prototype.wrapperClassName = function () {
	        return "Oath1Impl";
	    };
	    /**
	     *
	     **/
	    //settings
	    Oath1Impl.prototype.settings = function () {
	        return _super.prototype.element.call(this, 'settings');
	    };
	    return Oath1Impl;
	})(SecuritySchemaImpl);
	exports.Oath1Impl = Oath1Impl;
	var PassThroughImpl = (function (_super) {
	    __extends(PassThroughImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function PassThroughImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createPassThrough(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    PassThroughImpl.prototype.wrapperClassName = function () {
	        return "PassThroughImpl";
	    };
	    /**
	     *
	     **/
	    //settings
	    PassThroughImpl.prototype.settings = function () {
	        return _super.prototype.element.call(this, 'settings');
	    };
	    return PassThroughImpl;
	})(SecuritySchemaImpl);
	exports.PassThroughImpl = PassThroughImpl;
	var BasicImpl = (function (_super) {
	    __extends(BasicImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function BasicImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createBasic(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    BasicImpl.prototype.wrapperClassName = function () {
	        return "BasicImpl";
	    };
	    return BasicImpl;
	})(SecuritySchemaImpl);
	exports.BasicImpl = BasicImpl;
	var DigestImpl = (function (_super) {
	    __extends(DigestImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function DigestImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createDigest(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    DigestImpl.prototype.wrapperClassName = function () {
	        return "DigestImpl";
	    };
	    return DigestImpl;
	})(SecuritySchemaImpl);
	exports.DigestImpl = DigestImpl;
	var CustomImpl = (function (_super) {
	    __extends(CustomImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function CustomImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createCustom(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    CustomImpl.prototype.wrapperClassName = function () {
	        return "CustomImpl";
	    };
	    return CustomImpl;
	})(SecuritySchemaImpl);
	exports.CustomImpl = CustomImpl;
	var SecuritySchemaPartImpl = (function (_super) {
	    __extends(SecuritySchemaPartImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function SecuritySchemaPartImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchemaPart(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    SecuritySchemaPartImpl.prototype.wrapperClassName = function () {
	        return "SecuritySchemaPartImpl";
	    };
	    /**
	     *
	     **/
	    //headers
	    SecuritySchemaPartImpl.prototype.headers = function () {
	        return _super.prototype.elements.call(this, 'headers');
	    };
	    /**
	     *
	     **/
	    //queryParameters
	    SecuritySchemaPartImpl.prototype.queryParameters = function () {
	        return _super.prototype.elements.call(this, 'queryParameters');
	    };
	    /**
	     *
	     **/
	    //queryString
	    SecuritySchemaPartImpl.prototype.queryString = function () {
	        return _super.prototype.element.call(this, 'queryString');
	    };
	    /**
	     *
	     **/
	    //responses
	    SecuritySchemaPartImpl.prototype.responses = function () {
	        return _super.prototype.elements.call(this, 'responses');
	    };
	    /**
	     *
	     **/
	    //is
	    SecuritySchemaPartImpl.prototype.is = function () {
	        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //securedBy
	    SecuritySchemaPartImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //displayName
	    SecuritySchemaPartImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     *
	     **/
	    //setDisplayName
	    SecuritySchemaPartImpl.prototype.setDisplayName = function (param) {
	        {
	            this.highLevel().attrOrCreate("displayName").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //description
	    SecuritySchemaPartImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //annotations
	    SecuritySchemaPartImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    return SecuritySchemaPartImpl;
	})(MethodBaseImpl);
	exports.SecuritySchemaPartImpl = SecuritySchemaPartImpl;
	var OLibraryImpl = (function (_super) {
	    __extends(OLibraryImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function OLibraryImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createOLibrary(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    OLibraryImpl.prototype.wrapperClassName = function () {
	        return "OLibraryImpl";
	    };
	    /**
	     *
	     **/
	    //name
	    OLibraryImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     *
	     **/
	    //setName
	    OLibraryImpl.prototype.setName = function (param) {
	        {
	            this.highLevel().attrOrCreate("name").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //schemas
	    OLibraryImpl.prototype.schemas = function () {
	        return _super.prototype.elements.call(this, 'schemas');
	    };
	    /**
	     *
	     **/
	    //types
	    OLibraryImpl.prototype.types = function () {
	        return _super.prototype.elements.call(this, 'types');
	    };
	    /**
	     *
	     **/
	    //traits
	    OLibraryImpl.prototype.traits = function () {
	        return _super.prototype.elements.call(this, 'traits');
	    };
	    /**
	     *
	     **/
	    //resourceTypes
	    OLibraryImpl.prototype.resourceTypes = function () {
	        return _super.prototype.elements.call(this, 'resourceTypes');
	    };
	    /**
	     *
	     **/
	    //annotationTypes
	    OLibraryImpl.prototype.annotationTypes = function () {
	        return _super.prototype.elements.call(this, 'annotationTypes');
	    };
	    /**
	     *
	     **/
	    //securitySchemaTypes
	    OLibraryImpl.prototype.securitySchemaTypes = function () {
	        return _super.prototype.elements.call(this, 'securitySchemaTypes');
	    };
	    /**
	     *
	     **/
	    //securitySchemes
	    OLibraryImpl.prototype.securitySchemes = function () {
	        return _super.prototype.elements.call(this, 'securitySchemes');
	    };
	    /**
	     *
	     **/
	    //uses
	    OLibraryImpl.prototype.uses = function () {
	        return _super.prototype.elements.call(this, 'uses');
	    };
	    return OLibraryImpl;
	})(RAMLLanguageElementImpl);
	exports.OLibraryImpl = OLibraryImpl;
	var ApiImpl = (function (_super) {
	    __extends(ApiImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function ApiImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createApi(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ApiImpl.prototype.wrapperClassName = function () {
	        return "ApiImpl";
	    };
	    /**
	     *
	     **/
	    //title
	    ApiImpl.prototype.title = function () {
	        return _super.prototype.attribute.call(this, 'title', this.toString);
	    };
	    /**
	     *
	     **/
	    //setTitle
	    ApiImpl.prototype.setTitle = function (param) {
	        {
	            this.highLevel().attrOrCreate("title").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //version
	    ApiImpl.prototype.version = function () {
	        return _super.prototype.attribute.call(this, 'version', this.toString);
	    };
	    /**
	     *
	     **/
	    //setVersion
	    ApiImpl.prototype.setVersion = function (param) {
	        {
	            this.highLevel().attrOrCreate("version").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //baseUri
	    ApiImpl.prototype.baseUri = function () {
	        return _super.prototype.attribute.call(this, 'baseUri', function (attr) { return new FullUriTemplateImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //baseUriParameters
	    ApiImpl.prototype.baseUriParameters = function () {
	        return _super.prototype.elements.call(this, 'baseUriParameters');
	    };
	    /**
	     *
	     **/
	    //protocols
	    ApiImpl.prototype.protocols = function () {
	        return _super.prototype.attributes.call(this, 'protocols', this.toString);
	    };
	    /**
	     *
	     **/
	    //setProtocols
	    ApiImpl.prototype.setProtocols = function (param) {
	        {
	            this.highLevel().attrOrCreate("protocols").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //mediaType
	    ApiImpl.prototype.mediaType = function () {
	        return _super.prototype.attribute.call(this, 'mediaType', function (attr) { return new MimeTypeImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //securedBy
	    ApiImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //resources
	    ApiImpl.prototype.resources = function () {
	        return _super.prototype.elements.call(this, 'resources');
	    };
	    /**
	     *
	     **/
	    //documentation
	    ApiImpl.prototype.documentation = function () {
	        return _super.prototype.elements.call(this, 'documentation');
	    };
	    /**
	     *
	     **/
	    //displayName
	    ApiImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     *
	     **/
	    //setDisplayName
	    ApiImpl.prototype.setDisplayName = function (param) {
	        {
	            this.highLevel().attrOrCreate("displayName").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //name
	    ApiImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     *
	     **/
	    //setName
	    ApiImpl.prototype.setName = function (param) {
	        {
	            this.highLevel().attrOrCreate("name").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //description
	    ApiImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //annotations
	    ApiImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //securitySchemaTypes
	    ApiImpl.prototype.securitySchemaTypes = function () {
	        return _super.prototype.elements.call(this, 'securitySchemaTypes');
	    };
	    return ApiImpl;
	})(OLibraryImpl);
	exports.ApiImpl = ApiImpl;
	var OverlayImpl = (function (_super) {
	    __extends(OverlayImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function OverlayImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createOverlay(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    OverlayImpl.prototype.wrapperClassName = function () {
	        return "OverlayImpl";
	    };
	    /**
	     *
	     **/
	    //usage
	    OverlayImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /**
	     *
	     **/
	    //setUsage
	    OverlayImpl.prototype.setUsage = function (param) {
	        {
	            this.highLevel().attrOrCreate("usage").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //masterRef
	    OverlayImpl.prototype.masterRef = function () {
	        return _super.prototype.attribute.call(this, 'masterRef', this.toString);
	    };
	    /**
	     *
	     **/
	    //setMasterRef
	    OverlayImpl.prototype.setMasterRef = function (param) {
	        {
	            this.highLevel().attrOrCreate("masterRef").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //title
	    OverlayImpl.prototype.title = function () {
	        return _super.prototype.attribute.call(this, 'title', this.toString);
	    };
	    /**
	     *
	     **/
	    //setTitle
	    OverlayImpl.prototype.setTitle = function (param) {
	        {
	            this.highLevel().attrOrCreate("title").setValue("" + param);
	            return this;
	        }
	    };
	    return OverlayImpl;
	})(ApiImpl);
	exports.OverlayImpl = OverlayImpl;
	var ExtensionImpl = (function (_super) {
	    __extends(ExtensionImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function ExtensionImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createExtension(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ExtensionImpl.prototype.wrapperClassName = function () {
	        return "ExtensionImpl";
	    };
	    /**
	     *
	     **/
	    //usage
	    ExtensionImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /**
	     *
	     **/
	    //setUsage
	    ExtensionImpl.prototype.setUsage = function (param) {
	        {
	            this.highLevel().attrOrCreate("usage").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //masterRef
	    ExtensionImpl.prototype.masterRef = function () {
	        return _super.prototype.attribute.call(this, 'masterRef', this.toString);
	    };
	    /**
	     *
	     **/
	    //setMasterRef
	    ExtensionImpl.prototype.setMasterRef = function (param) {
	        {
	            this.highLevel().attrOrCreate("masterRef").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //title
	    ExtensionImpl.prototype.title = function () {
	        return _super.prototype.attribute.call(this, 'title', this.toString);
	    };
	    /**
	     *
	     **/
	    //setTitle
	    ExtensionImpl.prototype.setTitle = function (param) {
	        {
	            this.highLevel().attrOrCreate("title").setValue("" + param);
	            return this;
	        }
	    };
	    return ExtensionImpl;
	})(ApiImpl);
	exports.ExtensionImpl = ExtensionImpl;
	function createApi(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Api");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createOLibrary(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("OLibrary");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createRAMLLanguageElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("RAMLLanguageElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createDocumentationItem(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("DocumentationItem");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createScriptSpec(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("ScriptSpec");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createApiDescription(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("ApiDescription");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createCallbackAPIDescription(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("CallbackAPIDescription");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createRAMLProject(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("RAMLProject");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createSecuritySchemaType(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("SecuritySchemaType");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createDataElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("DataElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createXMLInfo(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("XMLInfo");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createExampleSpec(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("ExampleSpec");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createFileParameter(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("FileParameter");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createArrayField(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("ArrayField");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createUnionField(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("UnionField");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createObjectField(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("ObjectField");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createStrElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("StrElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createBooleanElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("BooleanElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createValueElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("ValueElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createNumberElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("NumberElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createIntegerElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("IntegerElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createRAMLPointerElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("RAMLPointerElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createRAMLExpression(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("RAMLExpression");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createScriptHookElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("ScriptHookElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createSchemaElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("SchemaElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createDateElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("DateElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createSecuritySchemaPart(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("SecuritySchemaPart");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createMethodBase(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("MethodBase");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createHasNormalParameters(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("HasNormalParameters");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createResponse(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Response");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createTrait(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Trait");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createLibrary(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Library");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createGlobalSchema(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("GlobalSchema");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createRAMLSimpleElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("RAMLSimpleElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createImportDeclaration(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("ImportDeclaration");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createResourceType(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("ResourceType");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createResourceBase(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("ResourceBase");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createMethod(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Method");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createResource(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Resource");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createAnnotationType(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("AnnotationType");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createSecuritySchema(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("SecuritySchema");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createSecuritySchemaSettings(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("SecuritySchemaSettings");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createOAuth1SecuritySchemeSettings(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("OAuth1SecuritySchemeSettings");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createOAuth2SecuritySchemeSettings(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("OAuth2SecuritySchemeSettings");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createPassThroughSettings(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("PassThroughSettings");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createOath2(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Oath2");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createOath1(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Oath1");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createPassThrough(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("PassThrough");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createBasic(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Basic");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createDigest(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Digest");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createCustom(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Custom");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createOverlay(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Overlay");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createExtension(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Extension");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	//# sourceMappingURL=raml003parser.js.map

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var hlimpl = __webpack_require__(7);
	var proxy = __webpack_require__(13);
	var RamlWrapper = __webpack_require__(3);
	var RamlWrapper08 = __webpack_require__(14);
	var wrapperHelper = __webpack_require__(15);
	var pluralize = __webpack_require__(45);
	var sig = __webpack_require__(16);
	var universeProvider = __webpack_require__(10);
	function expandTraitsAndResourceTypes(api) {
	    if (!(api instanceof RamlWrapper.ApiImpl || api instanceof RamlWrapper08.ApiImpl)) {
	        return null;
	    }
	    return new TraitsAndResourceTypesExpander().expandTraitsAndResourceTypes(api);
	}
	exports.expandTraitsAndResourceTypes = expandTraitsAndResourceTypes;
	var TraitsAndResourceTypesExpander = (function () {
	    function TraitsAndResourceTypesExpander() {
	    }
	    TraitsAndResourceTypesExpander.prototype.expandTraitsAndResourceTypes = function (_api) {
	        var _this = this;
	        var isRAML1 = _api instanceof RamlWrapper.ApiImpl;
	        var api = _api;
	        var traits = wrapperHelper.allTraits(api);
	        var resourceTypes = wrapperHelper.allResourceTypes(api);
	        //if ((!traits || traits.length == 0) && (!resourceTypes || resourceTypes.length == 0)) {
	        //    return api;
	        //}
	        var llNode = api.highLevel().lowLevel();
	        this.ramlVersion = _api.highLevel().definition().universe().version();
	        var topComposite = new proxy.LowLevelCompositeNode(llNode, null, null);
	        var apiType = isRAML1 ? universeProvider('RAML10').type('Api') : universeProvider('RAML08').type('Api');
	        var hlNode = new hlimpl.ASTNodeImpl(topComposite, null, apiType, null);
	        var result = isRAML1 ? new RamlWrapper.ApiImpl(hlNode) : new RamlWrapper08.ApiImpl(hlNode);
	        this.traitMap = {};
	        this.resourceTypeMap = {};
	        if (traits) {
	            traits.forEach(function (x) { return _this.traitMap[wrapperHelper.qName(x)] = x; });
	        }
	        if (resourceTypes) {
	            resourceTypes.forEach(function (x) { return _this.resourceTypeMap[wrapperHelper.qName(x)] = x; });
	        }
	        var resources = result.resources();
	        resources.forEach(function (x) { return _this.processResource(x); });
	        return result;
	    };
	    TraitsAndResourceTypesExpander.prototype.processResource = function (resource) {
	        var _this = this;
	        var resourceData = this.collectResourceData(resource);
	        if (resource instanceof RamlWrapper.ResourceImpl) {
	            var mb = resource;
	            var signature = mb.signature();
	            if (signature) {
	                var trait = sig.convertToTrait(sig.parse(mb.highLevel().attr("signature")));
	                var cm = trait.highLevel().lowLevel();
	                var vl = resource.relativeUri().value();
	                var indExof = vl.lastIndexOf(".");
	                if (indExof != -1) {
	                    var composite = new proxy.LowLevelCompositeNode(cm, null, null);
	                    trait.highLevel()._node = composite;
	                    resource.highLevel().lowLevel().setKeyOverride(vl.substr(0, indExof));
	                    var me = new RamlWrapper.MethodImpl(vl.substr(indExof + 1));
	                    var rt = new RamlWrapper.ResourceTypeImpl("$$$signature");
	                    rt.add(me);
	                    trait.highLevel().elements().forEach(function (x) { return me.highLevel().add(x); });
	                    var composite = new proxy.LowLevelCompositeNode(rt.highLevel().lowLevel(), null, null);
	                    rt.highLevel()._node = composite;
	                    var val = {
	                        name: "$$$signature",
	                        node: rt,
	                        transformer: null
	                    };
	                    resourceData = [{
	                        resourceType: val,
	                        traits: [],
	                        methodTraits: {}
	                    }].concat(resourceData);
	                }
	            }
	        }
	        resourceData.filter(function (x) { return x.resourceType != null; }).forEach(function (x) { return resource.highLevel().lowLevel().adopt(x.resourceType.node.highLevel().lowLevel(), x.resourceType.transformer); });
	        var methods = resource.methods();
	        methods.forEach(function (m) {
	            var name = m.method();
	            var map = {};
	            resourceData.forEach(function (x) {
	                var methodTraits = x.methodTraits[name];
	                if (methodTraits) {
	                    methodTraits.forEach(function (x) { return m.highLevel().lowLevel().adopt(x.node.highLevel().lowLevel(), x.transformer); }, true);
	                }
	                var resourceTraits = x.traits;
	                if (resourceTraits) {
	                    resourceTraits.forEach(function (x) { return m.highLevel().lowLevel().adopt(x.node.highLevel().lowLevel(), x.transformer); }, true);
	                }
	            });
	        });
	        var resources = resource.resources();
	        resources.forEach(function (x) { return _this.processResource(x); });
	    };
	    TraitsAndResourceTypesExpander.prototype.collectResourceData = function (obj, arr, transformer) {
	        var _this = this;
	        if (arr === void 0) { arr = []; }
	        var ownTraits = this.extractTraits(obj);
	        var methodTraitsMap = {};
	        var methods = obj.methods();
	        methods.forEach(function (x) {
	            var methodTraits = _this.extractTraits(x);
	            if (methodTraits && methodTraits.length > 0) {
	                methodTraitsMap[x.method()] = methodTraits;
	            }
	        });
	        var rtData;
	        var rt = obj.type();
	        if (rt) {
	            rtData = this.readGenerictData(rt, this.resourceTypeMap, 'resource type', transformer);
	        }
	        arr.push({
	            resourceType: rtData,
	            traits: ownTraits,
	            methodTraits: methodTraitsMap
	        });
	        if (rtData) {
	            this.collectResourceData(rtData.node, arr, rtData.transformer);
	        }
	        return arr;
	    };
	    TraitsAndResourceTypesExpander.prototype.extractTraits = function (obj, _transformer, map) {
	        var _this = this;
	        if (map === void 0) { map = {}; }
	        var arr = [];
	        for (var i = -1; i < arr.length; i++) {
	            var gd = i < 0 ? null : arr[i];
	            var _obj = gd ? gd.node : obj;
	            var transformer = gd ? gd.transformer : _transformer;
	            _obj.is().forEach(function (x) {
	                var traitData = _this.readGenerictData(x, _this.traitMap, 'trait', transformer);
	                if (traitData) {
	                    var name = traitData.name;
	                    if (!map[name]) {
	                        map[name] = true;
	                        arr.push(traitData);
	                    }
	                }
	            });
	        }
	        if (obj instanceof RamlWrapper.MethodImpl) {
	            var mb = obj;
	            var signature = mb.signature();
	            if (signature) {
	                var trait = sig.convertToTrait(sig.parse(mb.highLevel().attr("signature")));
	                var cm = trait.highLevel().lowLevel();
	                var composite = new proxy.LowLevelCompositeNode(cm, null, null);
	                trait.highLevel()._node = composite;
	                var val = {
	                    name: "$$$signature",
	                    node: trait,
	                    transformer: null
	                };
	                map["$$$signature"] = true;
	                arr = [val].concat(arr);
	            }
	        }
	        return arr;
	    };
	    TraitsAndResourceTypesExpander.prototype.readGenerictData = function (obj, globalMap, template, transformer) {
	        var value = obj.value();
	        if (typeof (value) == 'string') {
	            if (transformer) {
	                value = transformer.transform(value);
	            }
	            var node = globalMap[value];
	            if (node) {
	                return {
	                    name: value,
	                    transformer: null,
	                    node: node
	                };
	            }
	        }
	        else if (value instanceof hlimpl.StructuredValue) {
	            var sv = value;
	            var name = sv.valueName();
	            var params = {};
	            var node = globalMap[name];
	            //var t = hlimpl.typeFromNode(node.highLevel());
	            if (node) {
	                if (this.ramlVersion == 'RAML08' && transformer) {
	                    sv.children().forEach(function (x) { return params[x.valueName()] = transformer.transform(x.lowLevel().value()); });
	                }
	                else {
	                    sv.children().forEach(function (x) { return params[x.valueName()] = x.lowLevel().value(); });
	                }
	                return {
	                    name: name,
	                    transformer: new ValueTransformer(params, template),
	                    node: node
	                };
	            }
	        }
	        return null;
	    };
	    return TraitsAndResourceTypesExpander;
	})();
	var ValueTransformer = (function () {
	    function ValueTransformer(params, template) {
	        this.params = params;
	        this.template = template;
	    }
	    ValueTransformer.prototype.error = function () {
	        return this.err;
	    };
	    ValueTransformer.prototype.transform = function (obj) {
	        var undefParams = {};
	        if (typeof (obj) === 'string') {
	            var str = obj;
	            var str1 = '';
	            var prev = 0;
	            for (var i = str.indexOf('<<'); i >= 0; i = str.indexOf('<<', prev)) {
	                str1 += str.substring(prev, i);
	                var i0 = i;
	                i += '<<'.length;
	                prev = str.indexOf('>>', i);
	                var paramOccurence = str.substring(i, prev);
	                prev += '>>'.length;
	                var originalString = str.substring(i0, prev);
	                var val;
	                var paramName;
	                if (paramOccurence.match(/\|\s*!\s*singularize\s*$/)) {
	                    var ind = paramOccurence.lastIndexOf('|');
	                    paramName = paramOccurence.substring(0, ind).trim();
	                    val = this.params[paramName];
	                    if (val) {
	                        val = pluralize.singular(val);
	                    }
	                }
	                else if (paramOccurence.match(/\|\s*!\s*pluralize\s*$/)) {
	                    var ind = paramOccurence.lastIndexOf('|');
	                    paramName = paramOccurence.substring(0, ind).trim();
	                    val = this.params[paramName];
	                    if (val) {
	                        val = pluralize.plural(val);
	                    }
	                }
	                else {
	                    paramName = paramOccurence.trim();
	                    val = this.params[paramName];
	                }
	                if (!val) {
	                    undefParams[paramName] = true;
	                    val = originalString;
	                }
	                str1 += val;
	            }
	            var upArr = Object.keys(undefParams);
	            if (upArr.length > 0) {
	                var errStr = upArr.join(', ').trim();
	                this.err = "Undefined " + this.template + " parameter" + (upArr.length > 1 ? 's' : '') + ": " + errStr;
	            }
	            else {
	                this.err = null;
	            }
	            str1 += str.substring(prev, str.length);
	            return str1;
	        }
	        else {
	            return obj;
	        }
	    };
	    return ValueTransformer;
	})();
	//# sourceMappingURL=expander.js.map

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../typings/tsd.d.ts" />
	var invariant = __webpack_require__(46);
	var exists = function (v) { return (v != null); };
	var globalEmptyOpt;
	var Opt = (function () {
	    function Opt(_value) {
	        var _this = this;
	        this._value = _value;
	        this._isDefined = false;
	        this._isEmpty = true;
	        this._arr = undefined;
	        this.getOrThrow = function () {
	            invariant(_this._isDefined, 'Opt is empty. Use `Opt#getOrElse` or check `Opt#isDefined`.');
	            return _this._value;
	        };
	        this.value = function () { return _this._value; };
	        this.isDefined = function () { return _this._isDefined; };
	        this.isEmpty = function () { return _this._isEmpty; };
	        this.toArray = function () { return _this._arr || (_this._arr = _this._isDefined ? [_this._value] : []); };
	        this.getOrElse = function (v) { return _this._isDefined ? _this._value : v; };
	        this.getOrElseF = function (v) { return _this._isDefined ? _this._value : v(); };
	        this.map = function (f) { return _this._isEmpty ? Opt.empty() : new Opt(f(_this._value)); };
	        this.flatMap = function (f) { return _this.map(f).getOrElse(Opt.empty()); };
	        this.equals = function (other) {
	            invariant(other instanceof Opt, 'Expected other to be an `Opt`, but got `%s`', typeof other);
	            return (_this._isDefined === other.isDefined()) && (_this._value === other.value());
	        };
	        if (exists(this._value)) {
	            this._isDefined = true;
	            this._isEmpty = false;
	        }
	    }
	    Opt.prototype.forEach = function (fn) {
	        if (this.isDefined()) {
	            fn(this._value);
	        }
	    };
	    /**
	     * You can always create an empty option by hand just by calling new Opt<T>()
	     * but calling this method will return a global instance instead of allocating a new one each time
	     */
	    Opt.empty = function () { return (globalEmptyOpt || (globalEmptyOpt = new Opt())); };
	    return Opt;
	})();
	module.exports = Opt;
	//# sourceMappingURL=Opt.js.map

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/tsd.d.ts" />
	var yaml = __webpack_require__(19);
	var lowlevel = __webpack_require__(25);
	var path = __webpack_require__(11);
	var fs = __webpack_require__(12);
	var parser = __webpack_require__(26);
	var dumper = __webpack_require__(27);
	var Error = __webpack_require__(28);
	var textutil = __webpack_require__(29);
	var rr = __webpack_require__(30);
	var MarkupIndentingBuffer = (function () {
	    function MarkupIndentingBuffer(indent) {
	        this.text = '';
	        this.indent = indent;
	    }
	    MarkupIndentingBuffer.prototype.isLastNL = function () {
	        return this.text.length > 0 && this.text[this.text.length - 1] == '\n';
	    };
	    MarkupIndentingBuffer.prototype.addWithIndent = function (lev, s) {
	        if (this.isLastNL()) {
	            this.text += textutil.indent(lev);
	            this.text += this.indent;
	        }
	        this.text += s;
	    };
	    MarkupIndentingBuffer.prototype.addChar = function (ch) {
	        if (this.isLastNL()) {
	            this.text += this.indent;
	        }
	        this.text += ch;
	    };
	    MarkupIndentingBuffer.prototype.append = function (s) {
	        for (var i = 0; i < s.length; i++) {
	            this.addChar(s[i]);
	        }
	    };
	    return MarkupIndentingBuffer;
	})();
	exports.MarkupIndentingBuffer = MarkupIndentingBuffer;
	var CompilationUnit = (function () {
	    function CompilationUnit(_path, _content, _tl, _project, _apath) {
	        this._path = _path;
	        this._content = _content;
	        this._tl = _tl;
	        this._project = _project;
	        this._apath = _apath;
	    }
	    CompilationUnit.prototype.isStubUnit = function () {
	        return this.stu;
	    };
	    CompilationUnit.prototype.cloneToProject = function (p) {
	        var newUnit = new CompilationUnit(this._path, this._content, this._tl, p, this._apath);
	        return newUnit;
	    };
	    CompilationUnit.prototype.clone = function () {
	        var newUnit = new CompilationUnit(this._path, this._content, this._tl, this.project(), this._apath);
	        return newUnit;
	    };
	    CompilationUnit.prototype.stub = function () {
	        var newUnit = new CompilationUnit(this._path, this._content, this._tl, this.project(), this._apath);
	        newUnit.stu = true;
	        return newUnit;
	    };
	    CompilationUnit.prototype.isDirty = function () {
	        return false;
	    };
	    CompilationUnit.prototype.absolutePath = function () {
	        return this._apath;
	    };
	    CompilationUnit.prototype.isRAMLUnit = function () {
	        var en = path.extname(this._path);
	        return en == '.raml' || en == '.yaml';
	    };
	    CompilationUnit.prototype.contents = function () {
	        return this._content;
	    };
	    CompilationUnit.prototype.resolve = function (p) {
	        var unit = this._project.resolve(this._path, p);
	        return unit;
	    };
	    CompilationUnit.prototype.path = function () {
	        return this._path;
	    };
	    CompilationUnit.prototype.lexerErrors = function () {
	        if (this.errors == null) {
	            this.ast();
	        }
	        return this.errors;
	    };
	    CompilationUnit.prototype.ast = function () {
	        var _this = this;
	        if (this._node) {
	            return this._node;
	        }
	        try {
	            var result = parser.load(this._content, {});
	            this.errors = result.errors;
	            this.errors.forEach(function (x) {
	                if (x.mark) {
	                    x.mark.filePath = _this.absolutePath();
	                }
	            });
	            this._node = new ASTNode(result, this, null, null, null);
	            this._node._errors = this.errors;
	            return this._node;
	        }
	        catch (e) {
	            this.errors = [];
	            this.errors.push(new Error(e.message));
	            //console.log(this._content)
	            //console.log(e)
	            this._node = null;
	            return this._node;
	        }
	    };
	    CompilationUnit.prototype.isTopLevel = function () {
	        return this._tl;
	    };
	    CompilationUnit.prototype.updateContent = function (n) {
	        this._content = n;
	        this.errors = null;
	        this._node = null; //todo incremental update
	    };
	    CompilationUnit.prototype.updateContentSafe = function (n) {
	        this._content = n;
	    };
	    CompilationUnit.prototype.project = function () {
	        return this._project;
	    };
	    return CompilationUnit;
	})();
	exports.CompilationUnit = CompilationUnit;
	var FSResolver = (function () {
	    function FSResolver() {
	    }
	    FSResolver.prototype.content = function (path) {
	        if (!fs.existsSync(path)) {
	            return null;
	        }
	        try {
	            return fs.readFileSync(path).toString();
	        }
	        catch (e) {
	            return null;
	        }
	    };
	    FSResolver.prototype.list = function (path) {
	        return fs.readdirSync(path);
	    };
	    return FSResolver;
	})();
	exports.FSResolver = FSResolver;
	function copyNode(n) {
	    if (n == null) {
	        return null;
	    }
	    switch (n.kind) {
	        case 0 /* SCALAR */:
	            return {
	                errors: [],
	                startPosition: n.startPosition,
	                endPosition: n.endPosition,
	                value: n.value,
	                kind: 0 /* SCALAR */,
	                parent: n.parent
	            };
	        case 1 /* MAPPING */:
	            var map = n;
	            return {
	                errors: [],
	                key: copyNode(map.key),
	                value: copyNode(map.value),
	                startPosition: map.startPosition,
	                endPosition: map.endPosition,
	                kind: 1 /* MAPPING */,
	                parent: map.parent
	            };
	        case 2 /* MAP */:
	            var ymap = n;
	            return {
	                errors: [],
	                startPosition: n.startPosition,
	                endPosition: n.endPosition,
	                mappings: ymap.mappings.map(function (x) { return copyNode(x); }),
	                kind: 2 /* MAP */,
	                parent: ymap.parent
	            };
	    }
	    return n;
	}
	var innerShift = function (offset, yaNode, shift) {
	    if (!yaNode)
	        return;
	    if (yaNode.startPosition >= offset) {
	        yaNode.startPosition += shift;
	    }
	    if (yaNode.endPosition > offset) {
	        yaNode.endPosition += shift;
	    }
	    //this kind is a separate case
	    if (yaNode.kind == 1 /* MAPPING */) {
	        var m = yaNode;
	        innerShift(offset, m.key, shift);
	        innerShift(offset, m.value, shift);
	    }
	};
	function splitOnLines(text) {
	    var lines = text.match(/^.*((\r\n|\n|\r)|$)/gm);
	    return lines;
	}
	//TODO IMPROVE INDENTS
	function stripIndent(text, indent) {
	    var lines = splitOnLines(text);
	    var rs = [];
	    for (var i = 0; i < lines.length; i++) {
	        if (i == 0) {
	            rs.push(lines[0]);
	        }
	        else {
	            rs.push(lines[i].substring(indent.length));
	        }
	    }
	    return rs.join("");
	}
	var leadingIndent = function (node, text) {
	    var leading = "";
	    var pos = node.start() - 1;
	    while (pos > 0) {
	        var ch = text[pos];
	        //if (ch == '\r' || ch == '\n' || ch != ' ') break;
	        //console.log('char: [' + ch + ']');
	        if (ch != ' ' && ch != '-')
	            break;
	        leading = ' ' + leading;
	        pos--;
	    }
	    return leading;
	};
	function indent(line) {
	    var rs = "";
	    for (var i = 0; i < line.length; i++) {
	        var c = line[i];
	        if (c == '\r' || c == '\n') {
	            continue;
	        }
	        if (c == ' ' || c == '\t') {
	            rs += c;
	            continue;
	        }
	        break;
	    }
	    return rs;
	}
	function indentLines(s, indent) {
	    return s.split("\n").map(function (x) {
	        if (x.trim().length == 0) {
	            return x;
	        }
	        return indent + x;
	    }).join("\n");
	}
	function extraIndent(text, indent) {
	    var lines = splitOnLines(text);
	    var rs = [];
	    for (var i = 0; i < lines.length; i++) {
	        if (i == 0) {
	            rs.push(lines[0]);
	        }
	        else {
	            if (lines[i].trim().length > 0) {
	                rs.push(indent + lines[i]);
	            }
	            else {
	                rs.push("");
	            }
	        }
	    }
	    return rs.join("");
	}
	var Project = (function () {
	    /**
	     *
	     * @param rootPath - path to folder where your root api is located
	     * @param resolver
	     * @param _httpResolver
	     */
	    function Project(rootPath, resolver, _httpResolver) {
	        if (resolver === void 0) { resolver = new FSResolver(); }
	        if (_httpResolver === void 0) { _httpResolver = null; }
	        this.rootPath = rootPath;
	        this.resolver = resolver;
	        this._httpResolver = _httpResolver;
	        this.listeners = [];
	        this.tlisteners = [];
	        this.pathToUnit = {};
	    }
	    Project.prototype.cloneWithResolver = function (newResolver, httpResolver) {
	        if (httpResolver === void 0) { httpResolver = null; }
	        var newProject = new Project(this.rootPath, newResolver, httpResolver ? httpResolver : this._httpResolver);
	        for (var unitPath in this.pathToUnit) {
	            newProject.pathToUnit[unitPath] = this.pathToUnit[unitPath].cloneToProject(newProject);
	        }
	        return newProject;
	    };
	    Project.prototype.setCachedUnitContent = function (pth, cnt, tl) {
	        if (tl === void 0) { tl = true; }
	        var relPath = pth;
	        var apath = path.resolve(this.rootPath, pth);
	        var unit = new CompilationUnit(relPath, cnt, tl, this, apath);
	        this.pathToUnit[apath] = unit;
	        return unit;
	    };
	    Project.prototype.resolve = function (unitPath, pathInUnit) {
	        if (!pathInUnit)
	            return null;
	        if (pathInUnit.charAt(0) == '/') {
	            return this.unit(pathInUnit);
	        }
	        if (pathInUnit.indexOf("http://") == 0 || pathInUnit.indexOf("https://") == 0) {
	            return this.unit(pathInUnit, true);
	        }
	        if (unitPath.charAt(0) == '/') {
	            var absPath = path.resolve(path.dirname(unitPath), pathInUnit);
	            return this.unit(absPath, true);
	        }
	        var absPath = path.resolve(path.dirname(path.resolve(this.rootPath, unitPath)), pathInUnit);
	        return this.unit(absPath, true);
	    };
	    Project.prototype.units = function () {
	        var _this = this;
	        var names = this.resolver.list(this.rootPath).filter(function (x) { return path.extname(x) == '.raml'; });
	        return names.map(function (x) { return _this.unit(x); }).filter(function (y) { return y.isTopLevel(); });
	    };
	    Project.prototype.lexerErrors = function () {
	        var results = [];
	        this.units().forEach(function (x) {
	            results = results.concat(x.lexerErrors());
	        });
	        return results;
	    };
	    Project.prototype.deleteUnit = function (p, absolute) {
	        if (absolute === void 0) { absolute = false; }
	        var apath = null;
	        if (p.indexOf("http://") == 0 || p.indexOf("https://") == 0) {
	            apath = p;
	        }
	        else {
	            apath = absolute ? p : path.resolve(this.rootPath, p);
	        }
	        delete this.pathToUnit[apath];
	    };
	    Project.prototype.unit = function (p, absolute) {
	        if (absolute === void 0) { absolute = false; }
	        var cnt = null;
	        var apath = p;
	        if (p.indexOf("http://") == 0 || p.indexOf("https://") == 0) {
	            if (this.pathToUnit[apath]) {
	                return this.pathToUnit[apath];
	            }
	            if (this._httpResolver) {
	                cnt = this._httpResolver.getResource(p);
	            }
	            else {
	                cnt = rr.readFromCacheOrGet(p);
	            }
	        }
	        else {
	            if (p.charAt(0) == '/' && !absolute) {
	                p = p.substr(1); //TODO REVIEW IT
	            }
	            var apath = absolute ? p : path.resolve(this.rootPath, p);
	            if (this.pathToUnit[apath]) {
	                return this.pathToUnit[apath];
	            }
	            cnt = this.resolver.content(apath);
	        }
	        if (cnt == null) {
	            return null;
	        }
	        var tl = (cnt.indexOf("#%RAML") == 0);
	        var relPath = path.relative(this.rootPath, apath);
	        var unit = new CompilationUnit(relPath, cnt, tl, this, apath);
	        this.pathToUnit[apath] = unit;
	        return unit;
	    };
	    Project.prototype.visualizeNewlines = function (s) {
	        var res = '';
	        for (var i = 0; i < s.length; i++) {
	            var ch = s[i];
	            if (ch == '\r')
	                ch = '\\r';
	            if (ch == '\n')
	                ch = '\\n';
	            res += ch;
	        }
	        return res;
	    };
	    Project.prototype.indent = function (node) {
	        //node.show('NODE');
	        var text = node.unit().contents();
	        //console.log('node text: ' + textutil.replaceNewlines(text.substring(node.start(), node.end())));
	        //console.log('node parent: ' + node.parent());
	        //console.log('node unit: ' + node.unit());
	        if (node == node.root()) {
	            //console.log('node is root');
	            return '';
	        }
	        var leading = leadingIndent(node, text);
	        //console.log('leading: [' + leading + '] ' + leading.length);
	        var dmp = splitOnLines(node.dump());
	        if (dmp.length > 1) {
	            if (dmp[1].trim().length > 0) {
	                //console.log('DMP0: [' + dmp[0] + ']');
	                //console.log('DMP1: [' + dmp[1] + ']');
	                var extra = indent(dmp[1]);
	                return leading + extra;
	            }
	        }
	        //console.log('LEADING: [' + this.visualizeNewlines(leading) + '] ');
	        return leading + '  ';
	    };
	    Project.prototype.startIndent = function (node) {
	        var text = node.unit().contents();
	        //console.log('Node text:\n' + this.visualizeNewlines(text.substring(node.start(), node.end())));
	        if (node == node.root())
	            return '';
	        var dmp = splitOnLines(node.dump());
	        if (dmp.length > 0) {
	            console.log('FIRST: ' + dmp[0]);
	            var extra = indent(dmp[0]);
	            return extra + '  ';
	        }
	        //console.log('LEADING: [' + this.visualizeNewlines(leading) + '] ');
	        return '';
	    };
	    Project.prototype.canWriteInOneLine = function (node) {
	        return false;
	    };
	    Project.prototype.isOneLine = function (node) {
	        return node.text().indexOf('\n') < 0;
	    };
	    Project.prototype.recalcPositionsUp = function (target) {
	        var np = target;
	        while (np) {
	            np.recalcEndPositionFromChilds();
	            np = np.parent();
	        }
	    };
	    Project.prototype.add2 = function (target, node, toSeq, ipoint, json) {
	        if (json === void 0) { json = false; }
	        var unit = target.unit();
	        var api = target.root();
	        //console.log('api: ' + api);
	        var point = null;
	        if (ipoint) {
	            if (ipoint instanceof ASTNode) {
	                //console.log('insertion: ast node');
	                point = ipoint;
	            }
	            if (ipoint instanceof InsertionPoint) {
	                //console.log('insertion: ip');
	                point = ipoint.point;
	            }
	        }
	        //console.log('target: ' + target.kindName() + '/' + target.valueKindName() + ' node: ' + node.kindName());
	        //if(point) point.show('POINT:');
	        if (target.isValueInclude()) {
	            //console.log('insert to include ref');
	            var childs = target.children();
	            if (childs.length == 0) {
	                throw "not implemented: insert into empty include ref";
	            }
	            var parent = childs[0].parent();
	            //console.log('parent: ' + parent);
	            //parent.show('INCLUDE PARENT:');
	            this.add2(parent, node, toSeq, point, json);
	            return;
	        }
	        var range = new textutil.TextRange(unit.contents(), node.start(), node.end());
	        var targetRange = new textutil.TextRange(unit.contents(), target.start(), target.end());
	        var unitText = target.unit().contents();
	        if (target.valueKind() == 3 /* SEQ */) {
	            target = createSeq(target.valueAsSeq(), target, target.unit());
	        }
	        var json = this.isJson(target);
	        //console.log('target: ' + target.start() + '..' + target.end());
	        var originalIndent = json ? '' : this.indent(target.isSeq() ? target.parent() : target);
	        //console.log('indent: [' + originalIndent + '] ' + originalIndent.length + '; toseq: ' + toSeq + '; json: ' + json);
	        var xindent = originalIndent;
	        var indentLength = originalIndent.length;
	        var isTargetSeq = target.isSeq() || target.isMapping() && (target.isValueSeq() || target.isValueScalar() || !target.asMapping().value); //target.valueKind() == yaml.Kind.SEQ || target.isSeq();
	        //toSeq = false;
	        //console.log('target: ' + target.kindName() + '/' + yaml.Kind[target.valueKind()] + '; toseq: ' + toSeq);
	        //target.root().show("API:");
	        //target.show("TARGET:");
	        //console.log('oindent: ' + originalIndent.length);
	        toSeq = toSeq; // || isTargetSeq;
	        if (toSeq) {
	            if (json) {
	            }
	            else {
	                if (isTargetSeq) {
	                    xindent += "  ";
	                    indentLength += 2;
	                }
	            }
	        }
	        //console.log('xindent: ' + xindent.length);
	        var buf = new MarkupIndentingBuffer(xindent);
	        //target.show('TARGET:');
	        //node.show('NODE1');
	        node.markupNode(buf, node._actualNode(), 0, json);
	        var text = buf.text;
	        //node.show('NODE2', 0, text);
	        //console.log('TEXT TO ADD0: ' + textutil.replaceNewlines(text));
	        if (toSeq) {
	            //if(target.valueKind() == yaml.Kind.SEQ) {
	            var trimText = textutil.trimEnd(text);
	            var trimLen = text.length - trimText.length;
	            if (trimLen > 0) {
	                //console.log('trim len: ' + trimLen);
	                var textlen = text.length;
	                text = text.substring(0, textlen - trimLen);
	                node.shiftNodes(textlen - trimLen, -trimLen);
	            }
	        }
	        //target.show('TARGET2');
	        //node.show('NODE2', 0, text);
	        //console.log('TEXT TO ADD1: ' + textutil.replaceNewlines(text));
	        //console.log('TEXT TO ADD:\n' + this.visualizeNewlines(text));
	        //console.log('toseq: ' + toSeq);
	        if (toSeq && !json) {
	            if (node.highLevelNode()) {
	            }
	            //console.log('target: ' + target.kindName());
	            if (target.isMapping()) {
	            }
	            if (target.isSeq() || target.isMapping() && (target.isValueSeq() || target.isValueScalar() || !target.asMapping().value)) {
	                //console.log('--- make it seq');
	                text = originalIndent + '- ' + text;
	            }
	            else {
	                //console.log('--- keep it map');
	                text = originalIndent + text;
	            }
	        }
	        else {
	            text = originalIndent + text;
	        }
	        //console.log('TEXT TO ADD2: ' + textutil.replaceNewlines(text));
	        //target.show('TARGET3');
	        var pos = target.end();
	        //console.log('insert to target end: ' + pos+ ' ; point: ' + point);
	        if (point) {
	            //point.show("POINT");
	            if (point != target) {
	                pos = point.end();
	            }
	            else {
	                if (json && toSeq) {
	                }
	                else {
	                    pos = target.keyEnd() + 1;
	                    pos = new textutil.TextRange(unitText, pos, pos).extendAnyUntilNewLines().endpos();
	                }
	            }
	        }
	        else {
	            if (json && toSeq) {
	                var seq = target.asSeq();
	                if (seq) {
	                    if (seq.items.length > 0) {
	                        pos = seq.items[seq.items.length - 1].endPosition;
	                    }
	                    else {
	                        pos = seq.endPosition - 1;
	                    }
	                }
	            }
	            else {
	                if (ipoint && (ipoint instanceof InsertionPoint)) {
	                    //ipoint.show('insertion point provided');
	                    var ip = ipoint;
	                    if (ip.type == 1 /* START */) {
	                        pos = target.keyEnd() + 1;
	                        pos = new textutil.TextRange(unitText, pos, pos).extendAnyUntilNewLines().endpos();
	                    }
	                }
	            }
	        }
	        //console.log('insert poition: ' + pos);
	        var insertionRange = new textutil.TextRange(unitText, 0, pos);
	        pos = insertionRange.extendToNewlines().reduceSpaces().endpos();
	        if (json && target.isSeq()) {
	            var seq = target.asSeq();
	            if (seq.items.length > 0) {
	                text = ', ' + text;
	                indentLength += 2;
	            }
	        }
	        else if (pos > 0 && unitText[pos - 1] != '\n') {
	            text = "\n" + text;
	            indentLength++;
	        }
	        var suffixLen = 0;
	        if (toSeq && !json) {
	            text += '\n';
	            suffixLen++;
	        }
	        //console.log('FINAL TEXT TO ADD: [' + textutil.replaceNewlines(text) + '] at position ' + pos);
	        var newtext = unitText.substring(0, pos) + text + unitText.substring(pos, unitText.length);
	        var cu = unit;
	        cu.updateContentSafe(newtext);
	        this.executeReplace(new textutil.TextRange(unitText, pos, pos), text, cu);
	        //console.log('shift root from position: ' + pos);
	        target.root().shiftNodes(pos, indentLength + (node.end() - node.start()) + suffixLen);
	        //console.log('node len: ' + (node.end()-node.start()));
	        //console.log('text len: ' + text.length);
	        //(<ASTNode>target.root()).shiftNodes(pos, text.length+indentLength);
	        //target.show('TARGET2:');
	        //node.show('NODE TO ADD:');
	        if (point) {
	            var childs = target.children();
	            var index = -1;
	            for (var i = 0; i < childs.length; i++) {
	                var x = childs[i];
	                if (x.start() == point.start() && x.end() == point.end()) {
	                    index = i;
	                    break;
	                }
	            }
	            //console.log('index: ' + index);
	            if (index >= 0) {
	                target.addChild(node, index + 1);
	            }
	            else {
	                target.addChild(node);
	            }
	        }
	        else {
	            target.addChild(node);
	        }
	        node.shiftNodes(0, pos + indentLength);
	        //target.show('TARGET UPDATED:');
	        this.recalcPositionsUp(target);
	        //target.show('TARGET UPDATED POSITIONS:');
	        //api.show('ROOT UPDATED POSITIONS:');
	        node.setUnit(target.unit());
	        node.visit(function (n) {
	            var node = n;
	            node.setUnit(target.unit());
	            return true;
	        });
	    };
	    Project.prototype.isJsonMap = function (node) {
	        if (!node.isMap())
	            return false;
	        var text = node.text().trim();
	        return text.length >= 2 && text[0] == '{' && text[text.length - 1] == '}';
	    };
	    Project.prototype.isJsonSeq = function (node) {
	        if (!node.isSeq())
	            return false;
	        var text = node.text().trim();
	        return text.length >= 2 && text[0] == '[' && text[text.length - 1] == ']';
	    };
	    Project.prototype.isJson = function (node) {
	        return this.isJsonMap(node) || this.isJsonSeq(node);
	    };
	    Project.prototype.remove = function (unit, target, node) {
	        var parent = node.parent();
	        node._oldText = node.dump();
	        //node.showParents('PARENTS:');
	        //console.log('REMOVE NODE: ' + node.kindName() + ' from ' + target.kindName());
	        //console.log('INITIAL SELECTION: [' + textutil.replaceNewlines(range.text()) + ']');
	        //console.log('  text: \n' + unitText.substring(startpos,endpos));
	        if (this.isOneLine(node) && node.isMapping() && node.parent().isMap()) {
	            var mapnode = node.parent();
	            if (mapnode.asMap().mappings.length == 1 && mapnode.parent() != null) {
	                //console.log('REMOVE MAP INSTEAD!');
	                this.remove(unit, mapnode.parent(), mapnode);
	                return;
	            }
	        }
	        if (this.isOneLine(node) && node.isScalar() && node.parent().isSeq()) {
	            var seqnode = node.parent();
	            var seqn = seqnode.asSeq();
	            //console.log('SEQ: ' + seqn.items.length);
	            if (seqn.items.length == 1) {
	                //console.log('REMOVE SEQ INSTEAD!');
	                this.remove(unit, seqnode.parent(), seqnode);
	                return;
	            }
	        }
	        if (target.isMapping() && node.isSeq()) {
	            //console.log('remove seq from mapping');
	            var map = target.parent();
	            //console.log('REMOVE MAPPING INSTEAD!');
	            this.remove(unit, map, target);
	            return;
	        }
	        //target.show('TARGET:');
	        //node.show('NODE:');
	        var range = new textutil.TextRange(unit.contents(), node.start(), node.end());
	        var targetRange = new textutil.TextRange(unit.contents(), target.start(), target.end());
	        var parentRange = new textutil.TextRange(unit.contents(), parent.start(), parent.end());
	        var originalStartPos = range.startpos();
	        //console.log('REMOVE TEXT: ' +  this.visualizeNewlines(range.text()));
	        if (target.isSeq()) {
	            // extend range to start of line
	            //console.log('RANGE SEQ 0: ' + textutil.replaceNewlines(range.text()));
	            var seq = (node.isSeq() ? node : node.parentOfKind(3 /* SEQ */));
	            //console.log('seq: ' + seq.text() + ' json: ' + this.isJson(seq));
	            if (seq && this.isJson(seq)) {
	                range = range.extendSpaces().extendCharIfAny(',').extendSpaces();
	            }
	            else {
	                range = range.extendToStartOfLine().extendAnyUntilNewLines().extendToNewlines(); //
	            }
	        }
	        if (target.isMap()) {
	            // extend range to end of line
	            //console.log('RANGE MAP 0: [' +  this.visualizeNewlines(range.text()) + ']');
	            range = range.trimEnd().extendAnyUntilNewLines().extendToNewlines();
	            //console.log('RANGE MAP 1: [' +  this.visualizeNewlines(range.text()) + ']');
	            range = range.extendToStartOfLine().extendUntilNewlinesBack();
	        }
	        if (target.kind() == 1 /* MAPPING */) {
	            //console.log('RANGE MAPPING 0: ' +  this.visualizeNewlines(range.text()));
	            //console.log('NODE TEXT: ' + node.text());
	            if (this.isJson(node) && this.isOneLine(node)) {
	            }
	            else {
	                // extend range to end of line
	                //console.log('RANGE MAP 0: ' +  this.visualizeNewlines(range.text()));
	                range = range.extendSpacesUntilNewLines();
	                range = range.extendToNewlines();
	                //console.log('RANGE MAP 2: ' +  this.visualizeNewlines(range.text()));
	                range = range.extendToStartOfLine().extendUntilNewlinesBack();
	            }
	        }
	        if (node.isSeq()) {
	            //console.log('cleanup seq');
	            range = range.reduceSpaces();
	        }
	        //console.log('NODE:\n-----------\n' + range.unitText() + '\n-------------');
	        //console.log('TARGET: ' + target.kindName());
	        //target.show('TARGET');
	        //console.log('FINAL REMOVE TEXT: [' +  this.visualizeNewlines(range.text()) + ']');
	        //console.log('NEW TEXT:\n-----------\n' + range.remove() + '\n-------------');
	        var cu = unit;
	        cu.updateContentSafe(range.remove());
	        this.executeReplace(range, "", cu);
	        //node.parent().show('Before remove');
	        node.parent().removeChild(node);
	        var shift = -range.len();
	        //console.log('shift: ' + shift);
	        target.root().shiftNodes(originalStartPos, shift);
	        this.recalcPositionsUp(target);
	        //this.executeTextChange(new lowlevel.TextChangeCommand(range.startpos(), range.len(), "", unit))
	        //target.show('TARGET AFTER REMOVE:');
	        //target.root().show('API AFTER REMOVE:');
	    };
	    Project.prototype.changeKey = function (unit, attr, newval) {
	        //console.log('set key: ' + newval);
	        var range = new textutil.TextRange(attr.unit().contents(), attr.keyStart(), attr.keyEnd());
	        if (attr.kind() == 1 /* MAPPING */) {
	            var sc = attr._actualNode().key;
	            sc.value = newval;
	            sc.endPosition = sc.startPosition + newval.length;
	        }
	        var cu = unit;
	        this.executeReplace(range, newval, cu);
	        //console.log('new text: ' + this.visualizeNewlines(newtext));
	        var shift = newval.length - range.len();
	        //console.log('shift: ' + shift);
	        attr.root().shiftNodes(range.startpos(), shift, attr);
	        this.recalcPositionsUp(attr);
	    };
	    Project.prototype.executeReplace = function (r, txt, unit) {
	        var command = new lowlevel.TextChangeCommand(r.startpos(), r.endpos() - r.startpos(), txt, unit);
	        unit.project();
	        try {
	            this.tlisteners.forEach(function (x) { return x(command); });
	        }
	        catch (e) {
	            return false;
	        }
	        var newtext = r.replace(txt);
	        unit.updateContentSafe(newtext);
	        return true;
	    };
	    Project.prototype.changeValue = function (unit, attr, newval) {
	        //console.log('set value: ' + newval);mark
	        //console.log('ATTR ' + yaml.Kind[attr.kind()] + '; VALUE: ' + val + ' => ' + newval);
	        //attr.root().show('NODE:');
	        //console.log('TEXT:\n' + attr.unit().contents());
	        var range = new textutil.TextRange(attr.unit().contents(), attr.start(), attr.end());
	        //console.log('Range0: ' + range.startpos() + '..' + range.endpos() + ': [' + this.visualizeNewlines(range.text()) + ']');
	        //console.log('ATTR: ' + attr.kindName());
	        //attr.root().show('BEFORE');
	        var newNodeText;
	        var prefix = 0;
	        var delta = 0;
	        var replacer = null;
	        var mapping = null;
	        //console.log('attr: ' + attr.kindName());
	        if (attr.kind() == 0 /* SCALAR */) {
	            if (typeof newval == 'string') {
	                attr.asScalar().value = newval;
	                //range = range.withStart(attr.valueStart()).withEnd(attr.valueEnd());
	                //console.log('Range1: ' + this.visualizeNewlines(range.text()));
	                //console.log('Range0: ' + range.startpos() + '..' + range.endpos());
	                newNodeText = newval;
	            }
	            else {
	                throw "not implemented";
	            }
	        }
	        else if (attr.kind() == 1 /* MAPPING */) {
	            //attr.show('ATTR:');
	            mapping = attr.asMapping();
	            //console.log('mapping val: ' + attr.valueKindName());
	            if (attr.isValueInclude()) {
	                var inc = attr.valueAsInclude();
	                var includePath = inc.value;
	                //console.log("attr.setValue: path: " + includePath);
	                var resolved = attr.unit().resolve(includePath);
	                if (resolved == null) {
	                    console.log("attr.setValue: couldn't resolve: " + includePath);
	                    return; // "can not resolve "+includePath
	                }
	                //console.log("attr.setValue: resolved: " + includePath);
	                if (resolved.isRAMLUnit()) {
	                    //TODO DIFFERENT DATA TYPES, inner references
	                    return;
	                }
	                resolved.updateContent(newval);
	                return;
	            }
	            //console.log('Range0: ' + range.startpos() + '..' + range.endpos() + ': [' + this.visualizeNewlines(range.text()) + ']');
	            if (mapping.value)
	                range = range.withStart(attr.valueStart()).withEnd(attr.valueEnd());
	            else
	                range = range.withStart(attr.keyEnd() + 1).withEnd(attr.keyEnd() + 1);
	            //console.log('Range1: ' + range.startpos() + '..' + range.endpos());
	            range = range.reduceNewlinesEnd();
	            //console.log('Range2: ' + range.startpos() + '..' + range.endpos() + ': [' + this.visualizeNewlines(range.text()) + ']');
	            if (newval == null) {
	                newNodeText = '';
	                mapping.value = null;
	            }
	            else if (typeof newval == 'string' || newval == null) {
	                var newstr = newval;
	                var ind = this.indent(attr);
	                //console.log('indent: ' + ind.length);
	                if (newstr && textutil.isMultiLine(newstr)) {
	                    newstr = '' + textutil.makeMutiLine(newstr, ind.length / 2);
	                }
	                newNodeText = newstr;
	                //var valueNode = null;
	                if (!mapping.value) {
	                    console.log('no value');
	                    mapping.value = yaml.newScalar(newstr);
	                    mapping.value.startPosition = attr.keyEnd() + 1;
	                    mapping.value.endPosition = mapping.value.startPosition + newstr.length;
	                    mapping.endPosition = mapping.value.endPosition;
	                    if (unit.contents().length > attr.keyEnd() + 1) {
	                        var vlPos = attr.keyEnd() + 1;
	                        if (unit.contents()[vlPos - 1] == ':') {
	                            newNodeText = " " + newNodeText;
	                            mapping.value.startPosition++;
	                            mapping.value.endPosition++;
	                            mapping.endPosition++;
	                            delta++;
	                        }
	                    }
	                }
	                else if (mapping.value.kind == 3 /* SEQ */) {
	                    console.log('seq value');
	                    var v = mapping.value.items[0];
	                    throw "assign value!!!";
	                }
	                else if (mapping.value.kind == 0 /* SCALAR */) {
	                    //console.log('scalar value');
	                    var sc = mapping.value;
	                    var oldtext = sc.value;
	                    //console.log('oldval: ' + sc.value);
	                    //console.log('newstr: ' + newstr + ' ' + newstr.length);
	                    sc.value = newstr;
	                    //console.log('value1: ' + mapping.value.startPosition + '..' + mapping.value.endPosition);
	                    mapping.value.endPosition = mapping.value.startPosition + newstr.length;
	                    //console.log('value2: ' + mapping.value.startPosition + '..' + mapping.value.endPosition);
	                    mapping.endPosition = mapping.value.endPosition;
	                    //console.log('mvalue: ' + mapping.startPosition + '..' + mapping.endPosition);
	                    //console.log('newval: ' + sc.value);
	                    delta += newstr.length - oldtext.length;
	                }
	            }
	            else {
	                var n = newval;
	                if (n.isMapping()) {
	                    newval = createMap([n.asMapping()]);
	                    n = newval;
	                }
	                else if (n.isMap()) {
	                }
	                else {
	                    throw "only MAP/MAPPING nodes allowed as values";
	                }
	                //n.show('NODE1');
	                var buf = new MarkupIndentingBuffer('');
	                n.markupNode(buf, n._actualNode(), 0, true);
	                //n.show('NODE2');
	                newNodeText = '' + buf.text + '';
	                //indent++;
	                //n.shiftNodes(0, 1);
	                //console.log('node text: [[[' + newNodeText + ']]]');
	                //n.show("NN1:", 0, newNodeText);
	                //range = mapping.value? range.withStart(attr.valueStart()).withEnd(attr.valueEnd()) : range.withStart(attr.keyEnd()+1).withEnd(attr.keyEnd()+1 + newNodeText);
	                n.shiftNodes(0, range.startpos() + delta);
	                //n.show("NN2:");
	                replacer = n;
	            }
	        }
	        else {
	            console.log('Unsupported change value case: ' + attr.kindName());
	        }
	        //console.log('RangeX: ' + range.startpos() + '..' + range.endpos() + ': [' + this.visualizeNewlines(range.text()) + ']');
	        //console.log('new node text: ' + newNodeText);
	        var cu = unit;
	        //console.log('Range1: ' + range.startpos() + '..' + range.endpos());
	        //console.log('replace: ' + range.len());
	        //console.log('Range: ' + range.startpos() + '..' + range.endpos());
	        //console.log('OldText: ' + this.visualizeNewlines(cu.contents()));
	        this.executeReplace(range, newNodeText, cu);
	        //var newtext = range.replace(newNodeText);
	        //console.log('NewText: ' + this.visualizeNewlines(newtext));
	        //cu.updateContentSafe(newtext);
	        var shift = newNodeText.length - range.len();
	        //var shift = delta;
	        //attr.root().show('BEFORE SHIFT');
	        //console.log('shift: ' + shift + '; from: ' + (range.endpos() + prefix) + '; delta: ' + delta + '; prefix: ' + prefix);
	        attr.root().shiftNodes(range.endpos() + prefix, shift, attr);
	        //(<ASTNode>attr.root()).shiftNodes(range.endpos()+indent, shift);
	        //attr.show('ATTR2:');
	        if (replacer) {
	            mapping.value = replacer._actualNode();
	        }
	        this.recalcPositionsUp(attr);
	    };
	    Project.prototype.initWithRoot = function (root, newroot) {
	        var shift = root.end();
	        newroot.markup(false);
	        newroot._actualNode().startPosition = shift;
	        newroot._actualNode().endPosition = shift;
	        newroot.setUnit(root.unit());
	    };
	    Project.prototype.execute = function (cmd) {
	        var _this = this;
	        //console.log('Commands: ' + cmd.commands.length);
	        cmd.commands.forEach(function (x) {
	            switch (x.kind) {
	                case 4 /* CHANGE_VALUE */:
	                    var attr = x.target;
	                    var curval = attr.value();
	                    if (!curval) {
	                        curval = "";
	                    }
	                    var newval = x.value;
	                    //console.log('set value: ' + (typeof curval) + ' ==> ' + (typeof newval));
	                    if (typeof curval == 'string' && typeof newval == 'string') {
	                        //console.log('set value: str => str');
	                        if (curval != newval) {
	                            _this.changeValue(attr.unit(), attr, newval);
	                        }
	                    }
	                    else if (typeof curval == 'string' && typeof newval != 'string') {
	                        //console.log('set value: str => obj');
	                        // change structure
	                        //this.changeValue(attr.unit(), attr, null);
	                        _this.changeValue(attr.unit(), attr, newval);
	                    }
	                    else if (typeof curval != 'string' && typeof newval == 'string') {
	                        var newstr = x.value;
	                        if (curval.kind() == 1 /* MAPPING */) {
	                            if (textutil.isMultiLine(newstr)) {
	                                //console.log('multiline');
	                                attr.children().forEach(function (n) {
	                                    _this.remove(attr.unit(), attr, n);
	                                });
	                                _this.changeValue(attr.unit(), attr, newstr);
	                            }
	                            else {
	                                //console.log('singleline');
	                                _this.changeKey(attr.unit(), curval, newstr);
	                            }
	                        }
	                        else {
	                            throw 'unsupported case: attribute value conversion: ' + (typeof curval) + ' ==> ' + (typeof newval) + ' not supported';
	                        }
	                    }
	                    else if (typeof curval != 'string' && typeof newval != 'string') {
	                        var newvalnode = newval;
	                        //(<ASTNode>curval).show("OLD:");
	                        //newvalnode.show("NEW:");
	                        if (newvalnode.isMapping()) {
	                            newval = createMap([newvalnode.asMapping()]);
	                        }
	                        //console.log('obj obj: ' + (curval == newval));
	                        if (curval == newval)
	                            break;
	                        // change structure
	                        //console.log('set value: obj => obj');
	                        var node = newval;
	                        var map = node.asMap();
	                        //console.log('attr: ' + attr.kindName() + " " + attr.dump());
	                        attr.children().forEach(function (n) {
	                            _this.remove(attr.unit(), attr, n);
	                        });
	                        node.children().forEach(function (m) {
	                            //this.add2(attr, <ASTNode>m, false, null, true);
	                        });
	                        _this.changeValue(attr.unit(), attr, newval);
	                    }
	                    else {
	                        throw "shouldn't be this case: attribute value conversion " + (typeof curval) + ' ==> ' + (typeof newval) + ' not supported';
	                    }
	                    return;
	                case 3 /* CHANGE_KEY */:
	                    var attr = x.target;
	                    _this.changeKey(attr.unit(), attr, x.value);
	                    return;
	                case 0 /* ADD_CHILD */:
	                    var attr = x.target;
	                    var newValueNode = x.value;
	                    _this.add2(attr, newValueNode, x.toSeq, x.insertionPoint);
	                    return;
	                case 1 /* REMOVE_CHILD */:
	                    var target = x.target;
	                    var node = x.value;
	                    _this.remove(target.unit(), target, node);
	                    return;
	                case 5 /* INIT_RAML_FILE */:
	                    var root = x.target;
	                    var newroot = x.value;
	                    _this.initWithRoot(root, newroot);
	                    return;
	                default:
	                    console.log('UNSUPPORTED COMMAND: ' + lowlevel.CommandKind[x.kind]);
	                    return;
	            }
	        });
	    };
	    Project.prototype.replaceYamlNode = function (target, newNodeContent, offset, shift, unit) {
	        //console.log('New content:\n' + newNodeContent);
	        //target.show('OLD TARGET');
	        var newYamlNode = parser.load(newNodeContent, {});
	        //console.log('new yaml: ' + yaml.Kind[newYamlNode.kind]);
	        this.updatePositions(target.start(), newYamlNode);
	        //console.log('Shift: ' + shift);
	        //(<ASTNode>unit.ast()).shiftNodes(offset, shift);
	        target.root().shiftNodes(offset, shift);
	        var targetParent = target.parent();
	        var targetYamlNode = target._actualNode();
	        var parent = targetYamlNode.parent;
	        newYamlNode.parent = parent;
	        if (targetParent && targetParent.kind() == 2 /* MAP */) {
	            //console.log('MAP!!!');
	            var targetParentMapNode = targetParent._actualNode();
	            targetParentMapNode.mappings = targetParentMapNode.mappings.map(function (x) {
	                if (x != targetYamlNode) {
	                    return x;
	                }
	                return newYamlNode;
	            });
	        }
	        target.updateFrom(newYamlNode);
	        //target.show('MEW TARGET');
	        this.recalcPositionsUp(target);
	    };
	    Project.prototype.executeTextChange2 = function (textCommand) {
	        var cu = textCommand.unit;
	        var unitText = cu.contents();
	        var target = textCommand.target;
	        if (target) {
	            var cnt = unitText.substring(target.start(), target.end());
	            var original = unitText;
	            unitText = unitText.substr(0, textCommand.offset) + textCommand.text + unitText.substr(textCommand.offset + textCommand.replacementLength);
	            var newNodeContent = cnt.substr(0, textCommand.offset - target.start()) + textCommand.text + cnt.substr(textCommand.offset - target.start() + textCommand.replacementLength);
	            cu.updateContentSafe(unitText);
	            if (textCommand.offset > target.start()) {
	                try {
	                    var shift = textCommand.text.length - textCommand.replacementLength;
	                    var offset = textCommand.offset;
	                    target.unit().project().replaceYamlNode(target, newNodeContent, offset, shift, textCommand.unit);
	                }
	                catch (e) {
	                    console.log('New node contents (causes error below): \n' + newNodeContent);
	                    console.log('Reparse error: ' + e.stack);
	                }
	            }
	        }
	        else {
	            unitText = unitText.substr(0, textCommand.offset) + textCommand.text + unitText.substr(textCommand.offset + textCommand.replacementLength);
	        }
	        cu.updateContent(unitText);
	        this.listeners.forEach(function (x) {
	            x(null);
	        });
	        this.tlisteners.forEach(function (x) {
	            x(textCommand);
	        });
	    };
	    Project.prototype.executeTextChange = function (textCommand) {
	        var l0 = new Date().getTime();
	        try {
	            var oc = textCommand.unit.contents();
	            //console.log('Offset: ' + textCommand.offset + '; end: ' + (textCommand.offset + textCommand.replacementLength) + '; len: ' + textCommand.replacementLength);
	            var target = textCommand.target;
	            if (target == null) {
	                target = this.findNode(textCommand.unit.ast(), textCommand.offset, textCommand.offset + textCommand.replacementLength);
	            }
	            var cu = textCommand.unit;
	            if (target) {
	                var cnt = oc.substring(target.start(), target.end());
	                //console.log('Content: ' + cnt);
	                var original = oc;
	                oc = oc.substr(0, textCommand.offset) + textCommand.text + oc.substr(textCommand.offset + textCommand.replacementLength);
	                var newNodeContent = cnt.substr(0, textCommand.offset - target.start()) + textCommand.text + cnt.substr(textCommand.offset - target.start() + textCommand.replacementLength);
	                cu.updateContentSafe(oc);
	                //console.log('UPDATED TEXT: ' + oc);
	                var hasNewLines = breaksTheLine(original, textCommand);
	                if (textCommand.offset > target.start()) {
	                    try {
	                        var newYamlNode = parser.load(newNodeContent, {});
	                        this.updatePositions(target.start(), newYamlNode);
	                        //console.log("Positions updated")
	                        //lets shift all after it
	                        var shift = textCommand.text.length - textCommand.replacementLength;
	                        //console.log('shift: ' + shift);
	                        //console.log('offset: ' + textCommand.offset);
	                        textCommand.unit.ast().shiftNodes(textCommand.offset, shift);
	                        //console.log('Unit AST: ' + textCommand.unit.ast())
	                        if (newYamlNode != null && newYamlNode.kind == 2 /* MAP */) {
	                            var actualResult = newYamlNode.mappings[0];
	                            var targetYamlNode = target._actualNode();
	                            var parent = targetYamlNode.parent;
	                            var cmd = new lowlevel.ASTDelta();
	                            var unit = textCommand.unit;
	                            cmd.commands = [
	                                new lowlevel.ASTChangeCommand(4 /* CHANGE_VALUE */, new ASTNode(copyNode(targetYamlNode), unit, null, null, null), new ASTNode(actualResult, unit, null, null, null), 0)
	                            ];
	                            if (parent && parent.kind == 2 /* MAP */) {
	                                var map = parent;
	                                map.mappings = map.mappings.map(function (x) {
	                                    if (x != targetYamlNode) {
	                                        return x;
	                                    }
	                                    return actualResult;
	                                });
	                            }
	                            actualResult.parent = parent;
	                            //updating low level ast from yaml
	                            this.recalcPositionsUp(target);
	                            target.updateFrom(actualResult);
	                            //console.log("Incremental without listeners: "+(new Date().getTime()-l0));
	                            //console.log("Notify listeners1: " + this.listeners.length + ":" + this.tlisteners.length);
	                            this.listeners.forEach(function (x) {
	                                x(cmd);
	                            });
	                            this.tlisteners.forEach(function (x) {
	                                x(textCommand);
	                            });
	                            //console.log("Incremental update processed");
	                            return;
	                        }
	                    }
	                    catch (e) {
	                        console.log('New node contents (causes error below): \n' + newNodeContent);
	                        console.log('Reparse error: ' + e.stack);
	                    }
	                }
	            }
	            else {
	                oc = oc.substr(0, textCommand.offset) + textCommand.text + oc.substr(textCommand.offset + textCommand.replacementLength);
	            }
	            var t2 = new Date().getTime();
	            //console.log("Full without listeners:"+(t2-l0));
	            //!find node in scope
	            cu.updateContent(oc);
	            //console.log("Notify listeners2: " + this.listeners.length + ":" + this.tlisteners.length);
	            this.listeners.forEach(function (x) {
	                x(null);
	            });
	            this.tlisteners.forEach(function (x) {
	                x(textCommand);
	            });
	        }
	        finally {
	            var t2 = new Date().getTime();
	        }
	    };
	    Project.prototype.updatePositions = function (offset, n) {
	        var _this = this;
	        if (n == null) {
	            return;
	        }
	        if (n.startPosition == -1) {
	            n.startPosition = offset;
	        }
	        else {
	            n.startPosition = offset + n.startPosition;
	        }
	        n.endPosition = offset + n.endPosition;
	        switch (n.kind) {
	            case 2 /* MAP */:
	                var m = n;
	                m.mappings.forEach(function (x) { return _this.updatePositions(offset, x); });
	                break;
	            case 1 /* MAPPING */:
	                var ma = n;
	                this.updatePositions(offset, ma.key);
	                this.updatePositions(offset, ma.value);
	                break;
	            case 0 /* SCALAR */:
	                break;
	            case 3 /* SEQ */:
	                var s = n;
	                s.items.forEach(function (x) { return _this.updatePositions(offset, x); });
	                break;
	        }
	    };
	    Project.prototype.findNode = function (n, offset, end) {
	        var _this = this;
	        if (n == null) {
	            return null;
	        }
	        var node = n;
	        if (n.start() <= offset && n.end() >= end) {
	            var res = n;
	            node.directChildren().forEach(function (x) {
	                var m = _this.findNode(x, offset, end);
	                if (m) {
	                    res = m;
	                }
	            });
	            return res;
	        }
	        return null;
	    };
	    //shiftNodes(n:lowlevel.ILowLevelASTNode, offset:number, shift:number):lowlevel.ILowLevelASTNode{
	    //    var node:ASTNode=<ASTNode>n;
	    //    if (node==null){
	    //        return null;
	    //    }
	    //    node.directChildren().forEach(x=> {
	    //        var m = this.shiftNodes(x, offset, shift);
	    //    })
	    //    var yaNode=(<ASTNode>n)._actualNode();
	    //    if(yaNode) innerShift(offset, yaNode, shift);
	    //    return null;
	    //}
	    Project.prototype.addTextChangeListener = function (listener) {
	        this.tlisteners.push(listener);
	    };
	    Project.prototype.removeTextChangeListener = function (listener) {
	        this.tlisteners = this.tlisteners.filter(function (x) { return x != listener; });
	    };
	    Project.prototype.addListener = function (listener) {
	        this.listeners.push(listener);
	    };
	    Project.prototype.removeListener = function (listener) {
	        this.listeners = this.listeners.filter(function (x) { return x != listener; });
	    };
	    return Project;
	})();
	exports.Project = Project;
	function breaksTheLine(oc, textCommand) {
	    var oldText = oc.substr(textCommand.offset, textCommand.replacementLength);
	    if (oldText.indexOf('\n') != -1) {
	        return true;
	    }
	    if (textCommand.text.indexOf('\n') != -1) {
	        return true;
	    }
	}
	var ASTNode = (function () {
	    function ASTNode(_node, _unit, _parent, _anchor, _include, cacheChildren) {
	        if (cacheChildren === void 0) { cacheChildren = false; }
	        this._node = _node;
	        this._unit = _unit;
	        this._parent = _parent;
	        this._anchor = _anchor;
	        this._include = _include;
	        this.cacheChildren = cacheChildren;
	        this._errors = [];
	        if (_node == null) {
	            console.log("null");
	        }
	    }
	    ASTNode.prototype.yamlNode = function () {
	        return this._node;
	    };
	    ASTNode.prototype.setHighLevelParseResult = function (highLevelParseResult) {
	        this._highLevelParseResult = highLevelParseResult;
	    };
	    ASTNode.prototype.highLevelParseResult = function () {
	        return this._highLevelParseResult;
	    };
	    ASTNode.prototype.setHighLevelNode = function (highLevel) {
	        this._highLevelNode = highLevel;
	    };
	    ASTNode.prototype.highLevelNode = function () {
	        return this._highLevelNode;
	    };
	    ASTNode.prototype.start = function () {
	        return this._node.startPosition;
	    };
	    ASTNode.prototype.errors = function () {
	        return this._errors;
	    };
	    ASTNode.prototype.parent = function () {
	        return this._parent;
	    };
	    ASTNode.prototype.recalcEndPositionFromChilds = function () {
	        var childs = this.children();
	        //if(this.children().length == 0) return;
	        var max = 0;
	        var first = this.children()[0];
	        var last = this.children()[this.children().length - 1];
	        //this.children().forEach(n=> {
	        //    var node: ASTNode = <ASTNode>n;
	        //    if(node._node.endPosition > max) max = node._node.endPosition;
	        //});
	        if (this.isMapping()) {
	            var mapping = this.asMapping();
	            //console.log('reposition: mapping');
	            if (mapping.value) {
	                if (mapping.value.kind == 2 /* MAP */) {
	                    var map = mapping.value;
	                    if (map.startPosition < 0 && first) {
	                        map.startPosition = first.start();
	                    }
	                    if (last)
	                        this._node.endPosition = last._node.endPosition;
	                    //console.log('embedded map: ' + map.startPosition + ".." + map.endPosition);
	                    this._node.endPosition = Math.max(this._node.endPosition, mapping.value.endPosition);
	                }
	                else if (mapping.value.kind == 3 /* SEQ */) {
	                    var seq = mapping.value;
	                    if (seq.startPosition < 0) {
	                        //console.log('*** missed start position');
	                        if (seq.items.length > 0) {
	                            var pos = seq.items[0].startPosition;
	                            var range = new textutil.TextRange(this.unit().contents(), pos, pos);
	                            range = range.extendSpacesBack().extendCharIfAnyBack('-');
	                            seq.startPosition = range.startpos();
	                        }
	                        else {
	                        }
	                    }
	                    //console.log('mapping1     : ' + mapping.startPosition + ".." + mapping.endPosition);
	                    //console.log('embedded seq1: ' + seq.startPosition + ".." + seq.endPosition);
	                    if (seq.items.length > 0) {
	                        var ilast = seq.items[seq.items.length - 1];
	                        this._node.endPosition = Math.max(this._node.endPosition, seq.endPosition, ilast.endPosition);
	                        seq.endPosition = Math.max(this._node.endPosition, seq.endPosition, ilast.endPosition);
	                    }
	                }
	                else if (mapping.value.kind == 0 /* SCALAR */) {
	                }
	                else {
	                    if (last)
	                        this._node.endPosition = last._node.endPosition;
	                }
	            }
	        }
	        else {
	            if (last)
	                this._node.endPosition = last._node.endPosition;
	        }
	        //this._node.endPosition = max;;
	    };
	    ASTNode.prototype.isValueLocal = function () {
	        if (this._node.kind == 1 /* MAPPING */) {
	            var knd = this._node.value.kind;
	            return knd != 5 /* INCLUDE_REF */ && knd != 4 /* ANCHOR_REF */;
	        }
	        return true;
	    };
	    ASTNode.prototype.keyStart = function () {
	        if (this._node.kind == 1 /* MAPPING */) {
	            return this._node.key.startPosition;
	        }
	        return -1;
	    };
	    ASTNode.prototype.keyEnd = function () {
	        if (this._node.kind == 1 /* MAPPING */) {
	            return this._node.key.endPosition;
	        }
	        return -1;
	    };
	    ASTNode.prototype.valueStart = function () {
	        if (this._node.kind == 1 /* MAPPING */) {
	            var mapping = this.asMapping();
	            if (mapping.value)
	                return mapping.value.startPosition;
	            else
	                return mapping.endPosition;
	        }
	        return -1;
	    };
	    ASTNode.prototype.valueEnd = function () {
	        if (this._node.kind == 1 /* MAPPING */) {
	            var mn = this.asMapping();
	            return mn.value.endPosition;
	        }
	        return -1;
	    };
	    ASTNode.prototype.end = function () {
	        return this._node.endPosition;
	    };
	    ASTNode.prototype.dump = function () {
	        if (this._oldText) {
	            return this._oldText;
	        }
	        if (this._unit && this._node.startPosition > 0 && this._node.endPosition > 0) {
	            var originalText = this._unit.contents().substring(this._node.startPosition, this._node.endPosition);
	            originalText = stripIndent(originalText, leadingIndent(this, this._unit.contents()));
	            //console.log("L:");
	            //console.log(originalText);
	            return originalText;
	        }
	        return dumper.dump(this.dumpToObject(), {});
	    };
	    ASTNode.prototype.dumpToObject = function (full) {
	        if (full === void 0) { full = false; }
	        return this.dumpNode(this._node, full);
	    };
	    ASTNode.prototype.dumpNode = function (n, full) {
	        var _this = this;
	        if (full === void 0) { full = false; }
	        if (!n) {
	            return null;
	        }
	        if (n.kind == 3 /* SEQ */) {
	            var seq = n;
	            var arr = [];
	            seq.items.forEach(function (x) { return arr.push(_this.dumpNode(x)); });
	            return arr;
	        }
	        if (n.kind == 1 /* MAPPING */) {
	            var c = n;
	            var v = {};
	            var val = c.value;
	            var mm = this.dumpNode(val, full);
	            v["" + this.dumpNode(c.key, full)] = mm;
	            return v;
	        }
	        if (n.kind == 0 /* SCALAR */) {
	            var s = n;
	            return s.value;
	        }
	        if (n.kind == 2 /* MAP */) {
	            var map = n;
	            var res = {};
	            if (map.mappings.length == 1) {
	                if (map.mappings[0].key.value == 'value') {
	                    return this.dumpNode(map.mappings[0].value, full);
	                }
	            }
	            if (map.mappings) {
	                map.mappings.forEach(function (x) {
	                    var ms = _this.dumpNode(x.value, full);
	                    if (ms == null) {
	                        ms = "!$$$novalue";
	                    }
	                    if ((ms + "").length > 0 || full) {
	                        res[_this.dumpNode(x.key, full) + ""] = ms;
	                    }
	                });
	            }
	            return res;
	        }
	    };
	    ASTNode.prototype._actualNode = function () {
	        return this._node;
	    };
	    ASTNode.prototype.execute = function (cmd) {
	        if (this.unit()) {
	            this.unit().project().execute(cmd);
	        }
	        else {
	            cmd.commands.forEach(function (x) {
	                switch (x.kind) {
	                    case 4 /* CHANGE_VALUE */:
	                        var attr = x.target;
	                        var newValue = x.value;
	                        var va = attr._actualNode();
	                        var as = attr.start();
	                        if (va.kind == 1 /* MAPPING */) {
	                            va.value = yaml.newScalar("" + newValue);
	                        }
	                        //this.executeTextChange(new lowlevel.TextChangeCommand(as,attr.value().length,<string>newValue,attr.unit()))
	                        return;
	                    case 3 /* CHANGE_KEY */:
	                        var attr = x.target;
	                        var newValue = x.value;
	                        var va = attr._actualNode();
	                        if (va.kind == 1 /* MAPPING */) {
	                            var sc = va.key;
	                            sc.value = newValue;
	                        }
	                        return;
	                }
	            });
	        }
	    };
	    ASTNode.prototype.updateFrom = function (n) {
	        this._node = n;
	    };
	    ASTNode.prototype.value = function () {
	        if (!this._node) {
	            return "";
	        }
	        if (this._node.kind == 0 /* SCALAR */) {
	            //TODO WHAT IS IT IS INCLUDE ACTUALLY
	            return this._node['value'];
	        }
	        if (this._node.kind == 4 /* ANCHOR_REF */) {
	            var ref = this._node;
	            return new ASTNode(ref.value, this._unit, this, null, null).value();
	        }
	        if (this._node.kind == 1 /* MAPPING */) {
	            var map = this._node;
	            if (map.value == null) {
	                return null;
	            }
	            return new ASTNode(map.value, this._unit, this, null, null).value();
	        }
	        if (this._node.kind == 5 /* INCLUDE_REF */) {
	            //here we should resolve include
	            var includePath = this._node['value'];
	            var resolved = this._unit.resolve(includePath);
	            if (resolved == null) {
	                return "can not resolve " + includePath;
	            }
	            if (resolved.isRAMLUnit()) {
	                //TODO DIFFERENT DATA TYPES, inner references
	                return null;
	            }
	            var text = resolved.contents();
	            if (textutil.isMultiLineValue(text)) {
	                text = textutil.fromMutiLine(text);
	            }
	            return text;
	        }
	        if (this._node.kind == 2 /* MAP */) {
	            var amap = this._node;
	            if (amap.mappings.length == 1) {
	                //handle map with one member case differently
	                return new ASTNode(amap.mappings[0], this._unit, this, null, null);
	            }
	        }
	        if (this._node.kind == 3 /* SEQ */) {
	            var aseq = this._node;
	            if (aseq.items.length == 1 && true) {
	                //handle seq with one member case differently
	                return new ASTNode(aseq.items[0], this._unit, this, null, null).value();
	            }
	        }
	        //this are only kinds which has values
	        return null;
	    };
	    ASTNode.prototype.printDetails = function (indent) {
	        var result = "";
	        if (!indent)
	            indent = "";
	        var typeName = this.kindName();
	        if (this.kind() == 0 /* SCALAR */) {
	            result += indent + "[" + typeName + "]" + " " + this.value() + "\n";
	        }
	        else if (this.kind() == 1 /* MAPPING */ && this._node.value && this._node.value.kind == 0 /* SCALAR */) {
	            result += indent + "[" + typeName + "]" + " " + this.key() + " = " + this.value() + "\n";
	        }
	        else if (this.kind() == 1 /* MAPPING */) {
	            result += indent + "[" + typeName + "]" + " " + this.key() + " = :\n";
	            this.children().forEach(function (child) {
	                result += child.printDetails(indent + "\t");
	            });
	        }
	        else {
	            result += indent + "[" + typeName + "]" + " :\n";
	            this.children().forEach(function (child) {
	                result += child.printDetails(indent + "\t");
	            });
	        }
	        return result;
	    };
	    ASTNode.prototype.visit = function (v) {
	        this.children().forEach(function (x) {
	            if (v(x)) {
	                x.visit(v);
	            }
	        });
	    };
	    ASTNode.prototype.key = function () {
	        if (!this._node) {
	            return "";
	        }
	        if (this._node.kind == 1 /* MAPPING */) {
	            var map = this._node;
	            if (map.key.kind == 3 /* SEQ */) {
	                var items = map.key;
	                var mn = "[";
	                items.items.forEach(function (x) { return mn += x.value; });
	                return mn + "]";
	            }
	            return map.key.value;
	        }
	        //other kinds do not have keys
	        return null;
	    };
	    ASTNode.prototype.addChild = function (n, pos) {
	        if (pos === void 0) { pos = -1; }
	        //this.show('ADD TARGET:');
	        var node = n;
	        //console.log('add-child: ' + this.kindName() + ' .add ' + node.kindName());
	        node._parent = this;
	        this._oldText = null;
	        if (this.isMap()) {
	            //console.log('pos: ' + pos);
	            var map = this.asMap();
	            if (map.mappings == null || map.mappings == undefined) {
	                map.mappings = [];
	            }
	            if (pos >= 0) {
	                map.mappings.splice(pos, 0, node.asMapping());
	            }
	            else {
	                map.mappings.push(node.asMapping());
	            }
	        }
	        else if (this.isMapping()) {
	            var mapping = this.asMapping();
	            var val = mapping.value;
	            //console.log('mapping value: ' + val);
	            if (!mapping.value && node.isMap()) {
	                mapping.value = node._actualNode();
	                return;
	            }
	            if (mapping.value && mapping.value.kind == 0 /* SCALAR */) {
	                // cleanup old value
	                mapping.value = null;
	                val = null;
	            }
	            if (!val) {
	                if (node.isScalar() || node.highLevelNode() && node.highLevelNode().property().isEmbedMap()) {
	                    val = yaml.newSeq();
	                }
	                else {
	                    val = yaml.newMap();
	                }
	                mapping.value = val;
	            }
	            if (val.kind == 2 /* MAP */) {
	                var map = val;
	                if (map.mappings == null || map.mappings == undefined) {
	                    map.mappings = [];
	                }
	                if (node.isScalar()) {
	                }
	                if (pos >= 0) {
	                    map.mappings.splice(pos, 0, node.asMapping());
	                }
	                else {
	                    map.mappings.push(node.asMapping());
	                }
	            }
	            else if (val.kind == 3 /* SEQ */) {
	                var seq = val;
	                if (pos >= 0) {
	                    seq.items.splice(pos, 0, node._actualNode());
	                }
	                else {
	                    seq.items.push(node._actualNode());
	                }
	            }
	            else {
	                throw "Insert into mapping with " + yaml.Kind[mapping.value.kind] + " value not supported";
	            }
	        }
	        else if (this.isSeq()) {
	            var seq = this.asSeq();
	            if (pos >= 0) {
	                seq.items.splice(pos, 0, node._actualNode());
	            }
	            else {
	                seq.items.push(node._actualNode());
	            }
	        }
	        else {
	            throw "Insert into " + this.kindName() + " not supported";
	        }
	    };
	    ASTNode.prototype.removeChild = function (n) {
	        this._oldText = null;
	        var node = n;
	        var ynode;
	        var index;
	        //console.log('*** REMOVE FROM: ' + this.kindName());
	        if (this.kind() == 3 /* SEQ */) {
	            //console.log('remove from seq');
	            var seq = this.asSeq();
	            //val = <yaml.YamlMap>((<yaml.YAMLMapping>this._node).value);
	            ynode = node._node;
	            index = seq.items.indexOf(ynode);
	            if (index > -1)
	                seq.items.splice(index, 1);
	        }
	        else if (this.kind() == 2 /* MAP */) {
	            //val = <yaml.YamlMap>((<yaml.YAMLMapping>this._node).value);
	            var map = this.asMap();
	            //console.log('remove from map: ' + map.mappings.length);
	            ynode = node.asMapping();
	            index = map.mappings.indexOf(ynode);
	            //console.log('  index: ' + index);
	            if (index > -1)
	                map.mappings.splice(index, 1);
	        }
	        else if (this.kind() == 1 /* MAPPING */) {
	            //console.log('*** REMOVE FROM MAPPING');
	            //val = <yaml.YamlMap>((<yaml.YAMLMapping>this._node).value);
	            //console.log('remove from mapping with map as value');
	            var mapping = this.asMapping();
	            //this.show("REMOVE TARGET: ***");
	            //node.show("REMOVE NODE: ***");
	            if (node._actualNode() == mapping.value) {
	                // remove right from mapping
	                //console.log('*** remove map from mapping!');
	                mapping.value = null;
	            }
	            else {
	                var map = (mapping.value);
	                ynode = node.asMapping();
	                if (map && map.mappings) {
	                    index = map.mappings.indexOf(ynode);
	                    if (index > -1)
	                        map.mappings.splice(index, 1);
	                }
	            }
	        }
	        else {
	            throw "Delete from " + yaml.Kind[this.kind()] + " unsupported";
	        }
	    };
	    ASTNode.prototype.includeErrors = function () {
	        if (this._node.kind == 1 /* MAPPING */) {
	            var mapping = this._node;
	            if (mapping.value == null) {
	                return [];
	            }
	            return new ASTNode(mapping.value, this._unit, this, this._anchor, this._include).includeErrors();
	        }
	        var rs = [];
	        if (this._node.kind == 5 /* INCLUDE_REF */) {
	            var mapping = this._node;
	            if (mapping.value == null) {
	                return [];
	            }
	            var includePath = this.includePath();
	            var resolved = this._unit.resolve(includePath);
	            if (resolved == null) {
	                rs.push("Can not resolve " + includePath);
	                return rs;
	            }
	            if (resolved.isRAMLUnit()) {
	                var ast = resolved.ast();
	                if (ast) {
	                    return [];
	                }
	                else {
	                    rs.push("" + includePath + " can not be parsed");
	                }
	            }
	        }
	        return rs;
	    };
	    ASTNode.prototype.children = function (inc, anc, inOneMemberMap) {
	        var _this = this;
	        if (inc === void 0) { inc = null; }
	        if (anc === void 0) { anc = null; }
	        if (inOneMemberMap === void 0) { inOneMemberMap = true; }
	        if (this._node == null) {
	            return []; //TODO FIXME
	        }
	        if (this.cacheChildren && this._children) {
	            return this._children;
	        }
	        var result;
	        var kind = this._node.kind;
	        if (kind == 0 /* SCALAR */) {
	            result = [];
	        }
	        else if (kind == 2 /* MAP */) {
	            var map = this._node;
	            if (map.mappings.length == 1 && !inOneMemberMap) {
	                //handle map with one member case differently
	                // q:
	                //  []
	                //   - a
	                //   - b
	                // ->
	                // q:
	                //  a
	                //  b
	                result = new ASTNode(map.mappings[0].value, this._unit, this, inc, anc, this.cacheChildren).children(null, null, true);
	            }
	            else {
	                result = map.mappings.map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include, _this.cacheChildren); });
	            }
	        }
	        else if (kind == 1 /* MAPPING */) {
	            var mapping = this._node;
	            if (mapping.value == null) {
	                result = [];
	            }
	            else {
	                result = new ASTNode(mapping.value, this._unit, this, anc ? anc : this._anchor, inc ? inc : this._include, this.cacheChildren).children();
	            }
	        }
	        else if (kind == 3 /* SEQ */) {
	            var seq = this._node;
	            result = seq.items.filter(function (x) { return x != null; }).map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include, _this.cacheChildren); });
	        }
	        else if (kind == 5 /* INCLUDE_REF */) {
	            if (this._unit) {
	                var includePath = this.includePath();
	                var resolved = this._unit.resolve(includePath);
	                if (resolved == null) {
	                    result = [];
	                }
	                else if (resolved.isRAMLUnit()) {
	                    var ast = resolved.ast();
	                    if (ast) {
	                        if (this.cacheChildren) {
	                            ast = toChildCahcingNode(ast);
	                        }
	                        result = resolved.ast().children(this, null);
	                    }
	                }
	            }
	            if (!result) {
	                result = [];
	            }
	        }
	        else if (kind == 4 /* ANCHOR_REF */) {
	            var ref = this._node;
	            result = new ASTNode(ref.value, this._unit, this, null, null, this.cacheChildren).children();
	        }
	        else {
	            throw new Error("Should never happen; kind : " + yaml.Kind[this._node.kind]);
	        }
	        if (this.cacheChildren) {
	            this._children = result;
	        }
	        return result;
	    };
	    ASTNode.prototype.directChildren = function (inc, anc, inOneMemberMap) {
	        var _this = this;
	        if (inc === void 0) { inc = null; }
	        if (anc === void 0) { anc = null; }
	        if (inOneMemberMap === void 0) { inOneMemberMap = true; }
	        if (this._node) {
	            switch (this._node.kind) {
	                case 0 /* SCALAR */:
	                    return [];
	                case 2 /* MAP */:
	                    {
	                        var map = this._node;
	                        if (map.mappings.length == 1 && !inOneMemberMap) {
	                            //handle map with one member case differently
	                            return new ASTNode(map.mappings[0].value, this._unit, this, inc, anc).directChildren(null, null, true);
	                        }
	                        return map.mappings.map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include); });
	                    }
	                case 1 /* MAPPING */:
	                    {
	                        var mapping = this._node;
	                        if (mapping.value == null) {
	                            return [];
	                        }
	                        return new ASTNode(mapping.value, this._unit, this, anc ? anc : this._anchor, inc ? inc : this._include).directChildren();
	                    }
	                case 3 /* SEQ */:
	                    {
	                        var seq = this._node;
	                        return seq.items.filter(function (x) { return x != null; }).map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include); });
	                    }
	                case 5 /* INCLUDE_REF */:
	                    {
	                        return [];
	                    }
	                case 4 /* ANCHOR_REF */:
	                    {
	                        return [];
	                    }
	            }
	            throw new Error("Should never happen; kind : " + yaml.Kind[this._node.kind]);
	        }
	        return [];
	    };
	    ASTNode.prototype.anchorId = function () {
	        return this._node.anchorId;
	    };
	    ASTNode.prototype.unit = function () {
	        return this._unit;
	        //if(this._unit) return this._unit;
	        //if(!this.parent()) return null;
	        //return this.parent().unit();
	    };
	    ASTNode.prototype.setUnit = function (unit) {
	        this._unit = unit;
	    };
	    ASTNode.prototype.includePath = function () {
	        if (this._node.kind == 5 /* INCLUDE_REF */) {
	            var includePath = this._node['value'];
	            return includePath;
	        }
	        else if (this._node.kind == 1 /* MAPPING */) {
	            var mapping = this._node;
	            if (mapping.value == null)
	                return null;
	            return new ASTNode(mapping.value, this._unit, this, null, null).includePath();
	        }
	        return null;
	    };
	    ASTNode.prototype.anchoredFrom = function () {
	        return this._anchor;
	    };
	    ASTNode.prototype.includedFrom = function () {
	        return this._include;
	    };
	    ASTNode.prototype.kind = function () {
	        return this._actualNode().kind;
	    };
	    ASTNode.prototype.valueKind = function () {
	        if (this._node.kind != 1 /* MAPPING */) {
	            return null;
	        }
	        var map = this._node;
	        if (!map.value) {
	            return null;
	        }
	        return map.value.kind;
	    };
	    ASTNode.prototype.valueKindName = function () {
	        var kind = this.valueKind();
	        return kind != undefined ? yaml.Kind[kind] : null;
	    };
	    ASTNode.prototype.kindName = function () {
	        return yaml.Kind[this.kind()];
	    };
	    ASTNode.prototype.indent = function (lev, str) {
	        if (str === void 0) { str = ''; }
	        var leading = '';
	        for (var i = 0; i < lev; i++)
	            leading += '  ';
	        return leading + str;
	    };
	    ASTNode.prototype.replaceNewlines = function (s, rep) {
	        if (rep === void 0) { rep = null; }
	        var res = '';
	        for (var i = 0; i < s.length; i++) {
	            var ch = s[i];
	            if (ch == '\r')
	                ch = rep == null ? '\\r' : rep;
	            if (ch == '\n')
	                ch = rep == null ? '\\n' : rep;
	            res += ch;
	        }
	        return res;
	    };
	    ASTNode.prototype.shortText = function (unittext, maxlen) {
	        if (maxlen === void 0) { maxlen = 50; }
	        var elen = this.end() - this.start();
	        var len = elen;
	        //var len = Math.min(elen,50);
	        var unit = this.unit();
	        if (!unittext && unit) {
	            unittext = unit.contents();
	        }
	        var text;
	        if (!unittext) {
	            text = '[no-unit]';
	        }
	        else {
	            var s = unittext;
	            text = s ? s.substring(this.start(), this.end()) : '[no-text]';
	        }
	        text = "[" + this.start() + ".." + this.end() + "] " + elen + " // " + text + ' //';
	        if (len < elen)
	            text += '...';
	        text = this.replaceNewlines(text);
	        return text;
	    };
	    ASTNode.prototype.nodeShortText = function (node, unittext, maxlen) {
	        if (maxlen === void 0) { maxlen = 50; }
	        var elen = node.endPosition - node.startPosition;
	        var len = elen;
	        //var len = Math.min(elen,50);
	        var unit = this.unit();
	        if (!unittext && unit) {
	            unittext = unit.contents();
	        }
	        var text;
	        if (!unittext) {
	            text = '[no-unit]';
	        }
	        else {
	            var s = unittext;
	            text = s ? s.substring(node.startPosition, node.endPosition) : '[no-text]';
	        }
	        text = "[" + node.startPosition + ".." + node.endPosition + "] " + elen + " // " + text + ' //';
	        if (len < elen)
	            text += '...';
	        text = this.replaceNewlines(text);
	        return text;
	    };
	    ASTNode.prototype.show = function (message, lev, text) {
	        if (message === void 0) { message = null; }
	        if (lev === void 0) { lev = 0; }
	        if (text === void 0) { text = null; }
	        if (message && lev == 0) {
	            console.log(message);
	        }
	        var children = this.children();
	        var desc = this.kindName();
	        var val = this._actualNode().value;
	        if (this.kind() == 1 /* MAPPING */) {
	            desc += '[' + this._actualNode().key.value + ']';
	        }
	        if (val) {
	            desc += "/" + yaml.Kind[val.kind];
	        }
	        else
	            desc += "";
	        if (children.length == 0) {
	            //desc += "/" + this.value();
	            console.log(this.indent(lev) + desc + " // " + this.shortText(text));
	            if (this.isMapping() && this.asMapping().value) {
	                console.log(this.indent(lev + 1) + '// ' + this.valueKindName() + ': ' + this.nodeShortText(this.asMapping().value, text));
	            }
	        }
	        else {
	            console.log(this.indent(lev) + desc + " { // " + this.shortText(text));
	            if (this.isMapping() && this.asMapping().value) {
	                console.log(this.indent(lev + 1) + '// ' + this.valueKindName() + ': ' + this.nodeShortText(this.asMapping().value, text));
	            }
	            children.forEach(function (node) {
	                var n = node;
	                n.show(null, lev + 1, text);
	            });
	            console.log(this.indent(lev) + '}');
	        }
	    };
	    ASTNode.prototype.showParents = function (message, lev) {
	        if (lev === void 0) { lev = 0; }
	        if (message && lev == 0) {
	            console.log(message);
	        }
	        var depth = 0;
	        if (this.parent()) {
	            var n = this.parent();
	            depth = n.showParents(null, lev + 1);
	        }
	        var desc = this.kindName();
	        var val = this._actualNode().value;
	        if (val)
	            desc += "/" + yaml.Kind[val.kind];
	        else
	            desc += "/null";
	        console.log(this.indent(depth) + desc + " // " + this.shortText(null));
	        return depth + 1;
	    };
	    ASTNode.prototype.inlined = function (kind) {
	        return kind == 0 /* SCALAR */ || kind == 5 /* INCLUDE_REF */;
	    };
	    ASTNode.prototype.markupNode = function (xbuf, node, lev, json) {
	        if (json === void 0) { json = false; }
	        var start = xbuf.text.length;
	        switch (node.kind) {
	            case 2 /* MAP */:
	                if (json)
	                    xbuf.append('{');
	                var mappings = node.mappings;
	                for (var i = 0; i < mappings.length; i++) {
	                    if (json && i > 0)
	                        xbuf.append(', ');
	                    this.markupNode(xbuf, mappings[i], lev, json);
	                }
	                if (json)
	                    xbuf.append('}');
	                break;
	            case 3 /* SEQ */:
	                var items = node.items;
	                for (var i = 0; i < items.length; i++) {
	                    xbuf.append(this.indent(lev, '- '));
	                    //this.markupNode(xindent, pos+xbuf.text.length-(lev+1)*2, items[i], lev+1, xbuf);
	                    this.markupNode(xbuf, items[i], lev + 1, json);
	                }
	                break;
	            case 1 /* MAPPING */:
	                var mapping = node;
	                var val = mapping.value;
	                //console.log('mapping: ' + mapping.key.value + ' ' + val.kind);
	                if (json) {
	                    xbuf.append(mapping.key.value);
	                    xbuf.append(': ');
	                    if (val.kind == 0 /* SCALAR */) {
	                        var sc = val;
	                        xbuf.append(sc.value);
	                    }
	                    else if (val.kind == 2 /* MAP */) {
	                        //var mp = <yaml.YamlMap>val;
	                        this.markupNode(xbuf, mapping.value, lev + 1, json);
	                    }
	                    else {
	                        throw "markup not implemented: " + yaml.Kind[val.kind];
	                    }
	                    break;
	                }
	                xbuf.addWithIndent(lev, mapping.key.value + ':');
	                if (!val) {
	                    xbuf.append('\n');
	                    break;
	                }
	                if (val.kind == 0 /* SCALAR */) {
	                    var sc = val;
	                }
	                //xbuf.append(this.indent(lev, mapping.key.value + ':'));
	                if (mapping.value) {
	                    xbuf.append(this.inlined(mapping.value.kind) ? ' ' : '\n');
	                    this.markupNode(xbuf, mapping.value, lev + 1, json);
	                }
	                else {
	                    xbuf.append('\n');
	                }
	                break;
	            case 0 /* SCALAR */:
	                var sc = node;
	                if (textutil.isMultiLine(sc.value)) {
	                    xbuf.append('|\n');
	                    var lines = splitOnLines(sc.value);
	                    for (var i = 0; i < lines.length; i++) {
	                        xbuf.append(this.indent(lev, lines[i]));
	                    }
	                    xbuf.append('\n');
	                }
	                else {
	                    xbuf.append(sc.value + '\n');
	                }
	                break;
	            case 5 /* INCLUDE_REF */:
	                var ref = node;
	                xbuf.append('!include ' + ref.value + '\n');
	                break;
	            default:
	                throw 'Unknown node kind: ' + yaml.Kind[node.kind];
	                break;
	        }
	        while (start < xbuf.text.length && xbuf.text[start] == ' ')
	            start++;
	        node.startPosition = start;
	        node.endPosition = xbuf.text.length;
	    };
	    ASTNode.prototype.markup = function (json) {
	        if (json === void 0) { json = false; }
	        var buf = new MarkupIndentingBuffer('');
	        this.markupNode(buf, this._actualNode(), 0, json);
	        return buf.text;
	    };
	    ASTNode.prototype.root = function () {
	        var node = this;
	        while (node.parent()) {
	            var p = node.parent();
	            //if(p.isValueInclude()) break; // stop on include
	            node = p;
	        }
	        return node;
	    };
	    ASTNode.prototype.parentOfKind = function (kind) {
	        var p = this.parent();
	        while (p) {
	            if (p.kind() == kind)
	                return p;
	            p = p.parent();
	        }
	        return null;
	    };
	    ASTNode.prototype.find = function (name) {
	        var found = null;
	        //console.log('Looking for: ' + name);
	        this.directChildren().forEach(function (y) {
	            if (y.key() && y.key() == name) {
	                if (!found)
	                    found = y;
	            }
	        });
	        return found;
	    };
	    ASTNode.prototype.shiftNodes = function (offset, shift, exclude) {
	        this.directChildren().forEach(function (x) {
	            if (exclude && exclude.start() == x.start() && exclude.end() == x.end()) {
	            }
	            else {
	                var m = x.shiftNodes(offset, shift, exclude);
	            }
	        });
	        if (exclude && exclude.start() == this.start() && exclude.end() == this.end()) {
	        }
	        else {
	            var yaNode = this._actualNode();
	            if (yaNode)
	                innerShift(offset, yaNode, shift);
	        }
	        return null;
	    };
	    ASTNode.prototype.isMap = function () {
	        return this.kind() == 2 /* MAP */;
	    };
	    ASTNode.prototype.isMapping = function () {
	        return this.kind() == 1 /* MAPPING */;
	    };
	    ASTNode.prototype.isSeq = function () {
	        return this.kind() == 3 /* SEQ */;
	    };
	    ASTNode.prototype.isScalar = function () {
	        return this.kind() == 0 /* SCALAR */;
	    };
	    ASTNode.prototype.asMap = function () {
	        if (!this.isMap())
	            throw "map expected instead of " + this.kindName();
	        return (this._actualNode());
	    };
	    ASTNode.prototype.asMapping = function () {
	        if (!this.isMapping())
	            throw "maping expected instead of " + this.kindName();
	        return (this._actualNode());
	    };
	    ASTNode.prototype.asSeq = function () {
	        if (!this.isSeq())
	            throw "seq expected instead of " + this.kindName();
	        return (this._actualNode());
	    };
	    ASTNode.prototype.asScalar = function () {
	        if (!this.isScalar())
	            throw "scalar expected instead of " + this.kindName();
	        return (this._actualNode());
	    };
	    ASTNode.prototype.isValueSeq = function () {
	        return this.valueKind() == 3 /* SEQ */;
	    };
	    ASTNode.prototype.isValueMap = function () {
	        return this.valueKind() == 2 /* MAP */;
	    };
	    ASTNode.prototype.isValueInclude = function () {
	        return this.valueKind() == 5 /* INCLUDE_REF */;
	    };
	    ASTNode.prototype.isValueScalar = function () {
	        return this.valueKind() == 0 /* SCALAR */;
	    };
	    ASTNode.prototype.valueAsSeq = function () {
	        if (!this.isMapping())
	            throw "mapping expected instead of " + this.kindName();
	        if (this.valueKind() != 3 /* SEQ */)
	            throw "mappng/seq expected instead of mapping/" + this.kindName();
	        return (this.asMapping().value);
	    };
	    ASTNode.prototype.valueAsMap = function () {
	        if (!this.isMapping())
	            throw "mapping expected instead of " + this.kindName();
	        if (this.valueKind() != 2 /* MAP */)
	            throw "mappng/map expected instead of mapping/" + this.kindName();
	        return (this.asMapping().value);
	    };
	    ASTNode.prototype.valueAsScalar = function () {
	        if (!this.isMapping())
	            throw "mapping expected instead of " + this.kindName();
	        if (this.valueKind() != 0 /* SCALAR */)
	            throw "mappng/scalar expected instead of mapping/" + this.kindName();
	        return (this.asMapping().value);
	    };
	    ASTNode.prototype.valueAsInclude = function () {
	        if (!this.isMapping())
	            throw "mapping expected instead of " + this.kindName();
	        if (this.valueKind() != 5 /* INCLUDE_REF */)
	            throw "mappng/include expected instead of mapping/" + this.kindName();
	        return (this.asMapping().value);
	    };
	    ASTNode.prototype.text = function (unitText) {
	        if (unitText === void 0) { unitText = null; }
	        if (!unitText) {
	            if (!this.unit())
	                return '[no-text]';
	            unitText = this.unit().contents();
	        }
	        return unitText.substring(this.start(), this.end());
	    };
	    ASTNode.prototype.copy = function () {
	        var yn = copyNode(this._actualNode());
	        return new ASTNode(yn, this._unit, this._parent, this._anchor, this._include);
	    };
	    ASTNode.prototype.nodeDefinition = function () {
	        return getDefinitionForLowLevelNode(this);
	    };
	    return ASTNode;
	})();
	exports.ASTNode = ASTNode;
	(function (InsertionPointType) {
	    InsertionPointType[InsertionPointType["NONE"] = 0] = "NONE";
	    InsertionPointType[InsertionPointType["START"] = 1] = "START";
	    InsertionPointType[InsertionPointType["END"] = 2] = "END";
	    InsertionPointType[InsertionPointType["POINT"] = 3] = "POINT";
	})(exports.InsertionPointType || (exports.InsertionPointType = {}));
	var InsertionPointType = exports.InsertionPointType;
	var InsertionPoint = (function () {
	    function InsertionPoint(type, point) {
	        if (point === void 0) { point = null; }
	        this.type = type;
	        this.point = point;
	    }
	    InsertionPoint.after = function (point) {
	        return new InsertionPoint(3 /* POINT */, point);
	    };
	    InsertionPoint.atStart = function () {
	        return new InsertionPoint(1 /* START */);
	    };
	    InsertionPoint.atEnd = function () {
	        return new InsertionPoint(2 /* END */);
	    };
	    InsertionPoint.node = function () {
	        return new InsertionPoint(0 /* NONE */);
	    };
	    InsertionPoint.prototype.show = function (msg) {
	        if (msg) {
	            console.log(msg);
	            console.log('  insertion point type: ' + InsertionPointType[this.type]);
	        }
	        else {
	            console.log('insertion point type: ' + InsertionPointType[this.type]);
	        }
	        if (this.type == 3 /* POINT */ && this.point) {
	            this.point.show();
	        }
	    };
	    return InsertionPoint;
	})();
	exports.InsertionPoint = InsertionPoint;
	function createNode(key) {
	    //console.log('create node: ' + key);
	    var node = yaml.newMapping(yaml.newScalar(key), yaml.newMap());
	    return new ASTNode(node, null, null, null, null);
	}
	exports.createNode = createNode;
	function createMap(mappings) {
	    //console.log('create node: ' + key);
	    var node = yaml.newMap(mappings);
	    return new ASTNode(node, null, null, null, null);
	}
	exports.createMap = createMap;
	function createScalar(value) {
	    var node = yaml.newScalar(value);
	    return new ASTNode(node, null, null, null, null);
	}
	exports.createScalar = createScalar;
	function createSeq(sn, parent, unit) {
	    return new ASTNode(sn, unit, parent, null, null);
	}
	exports.createSeq = createSeq;
	/*
	export function createMappingWithMap(key:string, map: yaml.YAMLNode){
	    //console.log('create node: ' + key);
	    var node:yaml.YAMLNode=yaml.newMapping(yaml.newScalar(key),map);
	    return new ASTNode(node,null,null,null,null);
	}

	export function createMap(){
	    //console.log('create node: ' + key);
	    var node:yaml.YAMLNode=yaml.newMap();
	    return new ASTNode(node,null,null,null,null);
	}
	*/
	function createSeqNode(key) {
	    var node = yaml.newMapping(yaml.newScalar(key), yaml.newItems());
	    return new ASTNode(node, null, null, null, null);
	}
	exports.createSeqNode = createSeqNode;
	function createMapNode(key) {
	    var node = yaml.newMapping(yaml.newScalar(key), yaml.newMap());
	    return new ASTNode(node, null, null, null, null);
	}
	exports.createMapNode = createMapNode;
	function createMapping(key, v) {
	    //console.log('create mapping: ' + key);
	    var node = yaml.newMapping(yaml.newScalar(key), yaml.newScalar(v));
	    return new ASTNode(node, null, null, null, null);
	}
	exports.createMapping = createMapping;
	function toChildCahcingNode(node) {
	    if (!(node instanceof ASTNode)) {
	        return null;
	    }
	    var astNode = node;
	    var result = new ASTNode(astNode.yamlNode(), astNode.unit(), null, null, null, true);
	    result._errors = astNode._errors;
	    return result;
	}
	exports.toChildCahcingNode = toChildCahcingNode;
	function getDefinitionForLowLevelNode(node) {
	    var hl = node.highLevelNode();
	    if (hl) {
	        return hl.definition();
	    }
	    var parent = node.parent();
	    if (!parent) {
	        return null;
	    }
	    var key = node.key();
	    if (!key) {
	        return null;
	    }
	    var parentDef = parent.nodeDefinition();
	    if (!parentDef) {
	        return null;
	    }
	    if (!parentDef.property) {
	        return null;
	    }
	    var prop = parentDef.property(key);
	    if (!prop) {
	        return null;
	    }
	    return prop.range();
	}
	exports.getDefinitionForLowLevelNode = getDefinitionForLowLevelNode;
	//# sourceMappingURL=jsyaml2lowLevel.js.map

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	var __extends = this.__extends || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var jsyaml = __webpack_require__(6);
	var defs = __webpack_require__(21);
	var hl = __webpack_require__(17);
	var ll = __webpack_require__(25);
	var _ = __webpack_require__(47);
	var yaml = __webpack_require__(19);
	var proxy = __webpack_require__(13);
	var typeExpression = __webpack_require__(31);
	var def = __webpack_require__(21);
	var builder = __webpack_require__(32);
	var linter = __webpack_require__(33);
	var typeBuilder = __webpack_require__(34);
	var search = __webpack_require__(35);
	var textutil = __webpack_require__(29);
	var ModelFactory = __webpack_require__(36);
	var ovlval = __webpack_require__(37);
	function qName(x, context) {
	    var dr = search.declRoot(context);
	    var nm = x.name();
	    var o = nm;
	    var ind = nm.indexOf("<"); //TODO SCOPE IT
	    if (ind != -1) {
	        nm = nm.substring(0, ind);
	    }
	    while (true) {
	        var np = x.parent();
	        if (!np || np == dr) {
	            break;
	        }
	        else {
	            if (np.definition().name() == "Library" && np.parent()) {
	                nm = np.name() + "." + nm;
	            }
	            x = np;
	        }
	    }
	    return nm;
	}
	exports.qName = qName;
	function insideResourceTypeOrTrait(h) {
	    var declRoot = h;
	    while (true) {
	        if (declRoot.definition().isInlinedTemplates()) {
	            return true;
	        }
	        var np = declRoot.parent();
	        if (!np) {
	            break;
	        }
	        else {
	            declRoot = np;
	        }
	    }
	    return false;
	}
	var loophole = __webpack_require__(48);
	function evalInSandbox(code, thisArg, args) {
	    return new loophole.Function(code).call(thisArg, args);
	}
	exports.evalInSandbox = evalInSandbox;
	var BasicASTNode = (function () {
	    function BasicASTNode(_node, _parent) {
	        this._node = _node;
	        this._parent = _parent;
	        this._implicit = false;
	        this.values = {};
	        if (_node) {
	            _node.setHighLevelParseResult(this);
	        }
	    }
	    BasicASTNode.prototype.getKind = function () {
	        return 0 /* BASIC */;
	    };
	    BasicASTNode.prototype.hashkey = function () {
	        if (!this._hashkey)
	            this._hashkey = this.parent() ? this.parent().hashkey() + "/" + this.name() : this.name();
	        return this._hashkey;
	    };
	    BasicASTNode.prototype.root = function () {
	        if (this.parent()) {
	            return this.parent().root();
	        }
	        return this;
	    };
	    BasicASTNode.prototype.checkContextValue = function (name, value, thisObj) {
	        var vl = this.computedValue(name);
	        if (vl && vl.indexOf(value) != -1) {
	            return true; //FIXME
	        }
	        if (!vl) {
	            try {
	                var res = evalInSandbox("return " + name, thisObj, []);
	                if (res != undefined) {
	                    return "" + res == value;
	                }
	            }
	            catch (e) {
	            }
	        }
	        return value == vl || value == 'false';
	    };
	    BasicASTNode.prototype.printDetails = function (indent) {
	        return (indent ? indent : "") + "Unkown\n";
	    };
	    BasicASTNode.prototype.errors = function () {
	        var errors = [];
	        var q = {
	            accept: function (c) {
	                errors.push(c);
	            },
	            begin: function () {
	            },
	            end: function () {
	            }
	        };
	        this.validate(q);
	        return errors;
	    };
	    BasicASTNode.prototype.toRuntimeModel = function () {
	        var _this = this;
	        var thisObj = {};
	        //FIXME it should be be done in much cooler way
	        //Spec for runtime is also needed
	        this.children().forEach(function (x) {
	            if (x instanceof ASTPropImpl) {
	                var pr = x;
	                var val = pr.value();
	                if (val) {
	                    var type = pr.property().range();
	                    val = _this.fillValue(type, val);
	                    thisObj[x.name()] = val;
	                }
	            }
	        });
	        return thisObj;
	    };
	    BasicASTNode.prototype.fillValue = function (type, val) {
	        type.methods().forEach(function (m) {
	            if (typeof val == 'string') {
	                var newVal = {};
	                newVal['value'] = new loophole.Function("return this._value");
	                newVal._value = val;
	                val = newVal;
	            }
	            var nm = m.name;
	            var body = m.text;
	            var actualText = body.substring(body.indexOf('{') + 1, body.lastIndexOf('}'));
	            var func = new loophole.Function(actualText);
	            val[nm] = func;
	        });
	        val['$$'] = this;
	        return val;
	    };
	    BasicASTNode.prototype.markCh = function () {
	        var n = this.lowLevel();
	        n = n._node ? n._node : n;
	        if (n['markCh']) {
	            return true;
	        }
	        n['markCh'] = 1;
	    };
	    BasicASTNode.prototype.unmarkCh = function () {
	        var n = this.lowLevel();
	        n = n._node ? n._node : n;
	        delete n['markCh'];
	    };
	    BasicASTNode.prototype.validate = function (v) {
	        var _this = this;
	        if (this.lowLevel() && this._parent == null) {
	            this.lowLevel().errors().forEach(function (x) {
	                var em = {
	                    code: 1 /* YAML_ERROR */,
	                    message: x.message,
	                    node: null,
	                    start: x.mark.position,
	                    end: x.mark.position + 1,
	                    isWarning: false,
	                    path: _this.lowLevel().unit() == _this.root().lowLevel().unit() ? null : _this.lowLevel().unit().path(),
	                    unit: _this.lowLevel().unit()
	                };
	                v.accept(em);
	            });
	        }
	        this.validateIncludes(v);
	        if (this.isUnknown()) {
	            if (this.needSequence) {
	                v.accept(createIssue(2 /* UNKNOWN_NODE */, "node: " + this.name() + " should be wrapped in sequence", this));
	            }
	            if (this.unresolvedRef) {
	                v.accept(createIssue(2 /* UNKNOWN_NODE */, "reference : " + this.lowLevel().value() + " can not be resolved", this));
	            }
	            if (this.knownProperty && this.lowLevel().value()) {
	                v.accept(createIssue(2 /* UNKNOWN_NODE */, "property " + this.name() + " can not have scalar value", this));
	            }
	            else {
	                v.accept(createIssue(2 /* UNKNOWN_NODE */, "Unknown node:" + this.name(), this));
	            }
	        }
	        if (this.markCh() && !this.allowRecursive()) {
	            v.accept(createIssue(2 /* UNKNOWN_NODE */, "Recursive definition:" + this.name(), this));
	            return;
	        }
	        try {
	            this.directChildren().forEach(function (x) { return x.validate(v); });
	        }
	        finally {
	            this.unmarkCh();
	        }
	    };
	    BasicASTNode.prototype.allowRecursive = function () {
	        return false;
	    };
	    BasicASTNode.prototype.validateIncludes = function (v) {
	        var _this = this;
	        if (this.lowLevel()) {
	            this.lowLevel().includeErrors().forEach(function (x) {
	                var em = createIssue(6 /* UNABLE_TO_RESOLVE_INCLUDE_FILE */, x, _this);
	                v.accept(em);
	            });
	        }
	    };
	    BasicASTNode.prototype.setComputed = function (name, v) {
	        this.values[name] = v;
	    };
	    BasicASTNode.prototype.computedValue = function (name) {
	        var vl = this.values[name];
	        if (!vl && this.parent()) {
	            return this.parent().computedValue(name);
	        }
	        return vl;
	    };
	    BasicASTNode.prototype.lowLevel = function () {
	        return this._node;
	    };
	    BasicASTNode.prototype.expansionSpec = function () {
	        return null;
	    };
	    BasicASTNode.prototype.name = function () {
	        var c = this.lowLevel().key();
	        if (!c) {
	            return "";
	        }
	        return c;
	    };
	    BasicASTNode.prototype.parent = function () {
	        return this._parent;
	    };
	    BasicASTNode.prototype.setParent = function (parent) {
	        this._parent = parent;
	    };
	    BasicASTNode.prototype.isElement = function () {
	        return false;
	    };
	    BasicASTNode.prototype.directChildren = function () {
	        return this.children();
	    };
	    BasicASTNode.prototype.children = function () {
	        return [];
	    };
	    BasicASTNode.prototype.isAttached = function () {
	        return this.parent() != null;
	    };
	    BasicASTNode.prototype.isImplicit = function () {
	        return this._implicit;
	    };
	    BasicASTNode.prototype.isAttr = function () {
	        return false;
	    };
	    BasicASTNode.prototype.isUnknown = function () {
	        return true;
	    };
	    BasicASTNode.prototype.id = function () {
	        var _this = this;
	        if (this._parent) {
	            var parentId = this.parent().id();
	            parentId += "." + this.name();
	            var sameName = this.parent().directChildren().filter(function (x) { return x.name() == _this.name(); });
	            if (sameName.length > 1) {
	                var ind = sameName.indexOf(this);
	                parentId += "[" + ind + "]";
	            }
	            return parentId;
	        }
	        return "";
	    };
	    BasicASTNode.prototype.localId = function () {
	        return this.name();
	    };
	    BasicASTNode.prototype.property = function () {
	        return null;
	    };
	    return BasicASTNode;
	})();
	exports.BasicASTNode = BasicASTNode;
	function createIssue(c, message, node, w) {
	    if (w === void 0) { w = false; }
	    return linter.createIssue(c, message, node, w);
	}
	exports.createIssue = createIssue;
	var StructuredValue = (function () {
	    function StructuredValue(node, _parent, _pr, kv) {
	        if (kv === void 0) { kv = null; }
	        this.node = node;
	        this._parent = _parent;
	        this.kv = kv;
	        this._pr = _pr;
	    }
	    StructuredValue.prototype.valueName = function () {
	        var res = null;
	        if (this.kv) {
	            res = this.kv;
	        }
	        res = this.node.key();
	        if (this._pr && this._pr.isAnnotation()) {
	            if (res && res.charAt(0) == '(') {
	                res = res.substring(1, res.length - 1);
	            }
	        }
	        return res;
	    };
	    StructuredValue.prototype.children = function () {
	        return this.node.children().map(function (x) { return new StructuredValue(x, null, null); });
	    };
	    StructuredValue.prototype.lowLevel = function () {
	        return this.node;
	    };
	    StructuredValue.prototype.toHighlevel = function (parent) {
	        if (!parent && this._parent)
	            parent = this._parent;
	        var vn = this.valueName();
	        var cands = this._pr.referenceTargets(parent).filter(function (x) { return qName(x, parent) == vn; });
	        if (cands && cands[0]) {
	            var tp = typeBuilder.typeFromNode(cands[0]);
	            var node = new ASTNodeImpl(this.node, parent, tp, this._pr);
	            if (this._pr) {
	                this._pr.childRestrictions().forEach(function (y) {
	                    node.setComputed(y.name, y.value);
	                });
	            }
	            return node;
	        }
	        return null;
	    };
	    return StructuredValue;
	})();
	exports.StructuredValue = StructuredValue;
	function genStructuredValue(type, name, mappings, parent) {
	    var map = yaml.newMap(mappings.map(function (mapping) { return yaml.newMapping(yaml.newScalar(mapping.key), yaml.newScalar(mapping.value)); }));
	    var node = new jsyaml.ASTNode(map, (parent ? parent.lowLevel().unit() : null), parent ? parent.lowLevel() : null, null, null);
	    return new StructuredValue(node, parent, parent ? parent.definition().property(type) : null, name);
	}
	exports.genStructuredValue = genStructuredValue;
	function checkPropertyQuard(n, v) {
	    var pr = n.property();
	    if (pr) {
	        pr.getContextRequirements().forEach(function (x) {
	            if (!n.checkContextValue(x.name, x.value, n.parent().toRuntimeModel())) {
	                v.accept(createIssue(8 /* MISSED_CONTEXT_REQUIREMENT */, x.name + " should be " + x.value + " to use property " + pr.name(), n));
	            }
	        });
	    }
	    return pr;
	}
	;
	var ASTPropImpl = (function (_super) {
	    __extends(ASTPropImpl, _super);
	    function ASTPropImpl(node, parent, _def, _prop, fromKey) {
	        if (fromKey === void 0) { fromKey = false; }
	        _super.call(this, node, parent);
	        this._def = _def;
	        this._prop = _prop;
	        this.fromKey = fromKey;
	    }
	    ASTPropImpl.prototype.definition = function () {
	        return this._def;
	    };
	    ASTPropImpl.prototype.getKind = function () {
	        return 2 /* ATTRIBUTE */;
	    };
	    ASTPropImpl.prototype.owningWrapper = function () {
	        return {
	            node: this.parent().wrapperNode(),
	            property: this.name()
	        };
	    };
	    ASTPropImpl.prototype.patchType = function (t) {
	        this._def = t;
	    };
	    ASTPropImpl.prototype.findReferenceDeclaration = function () {
	        var _this = this;
	        var targets = this.property().referenceTargets(this.parent());
	        var vl = this.value();
	        if (vl instanceof StructuredValue) {
	            var st = vl;
	            var nm = st.valueName();
	        }
	        else {
	            var nm = "" + vl;
	        }
	        var t = _.find(targets, function (x) { return qName(x, _this.parent()) == nm; });
	        return t;
	    };
	    ASTPropImpl.prototype.findReferencedValue = function () {
	        var c = this.findReferenceDeclaration();
	        if (c) {
	            var vl = c.attr("value");
	            if (c.definition().name() == "GlobalSchema") {
	                if (vl) {
	                    var actualValue = vl.value();
	                    if (actualValue) {
	                        var rf = this._def.isValid(this.parent(), actualValue, vl.property());
	                        return rf;
	                    }
	                }
	                return null;
	            }
	        }
	        return c;
	    };
	    /**
	     * TODO Split this method into the cases depending from property kind
	     * @param v
	     */
	    ASTPropImpl.prototype.validate = function (v) {
	        var pr = checkPropertyQuard(this, v);
	        var vl = this.value();
	        if (!this.property().range().hasStructure()) {
	            if (vl instanceof StructuredValue && !this.property().isSelfNode()) {
	                //TODO THIS SHOULD BE MOVED TO TYPESYSTEM FOR STS AT SOME MOMENT
	                if (this.property().name() == "schema" || this.property().name() == 'type') {
	                    if (this.property().domain().name() == "BodyLike") {
	                        var structValue = vl;
	                        var node = new ASTNodeImpl(this.lowLevel(), this.parent(), this.parent().definition().universe().getType("ObjectField"), this.property());
	                        node.validate(v);
	                        return;
	                    }
	                }
	                v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Scalar is expected here", this));
	            }
	        }
	        if (this.parent().allowsQuestion() && this.property().isKey()) {
	            if (vl != null && vl.length > 0 && vl.charAt(vl.length - 1) == '?') {
	                vl = vl.substr(0, vl.length - 1);
	            }
	        }
	        if (typeof vl == 'string' && vl.indexOf("<<") != -1) {
	            if (vl.indexOf(">>") > vl.indexOf("<<")) {
	                if (insideResourceTypeOrTrait(this.parent())) {
	                    return;
	                }
	            }
	        }
	        this.validateIncludes(v);
	        if (this.property().range().name() == "MimeType" || (this.property().name() == "name" && this.parent().property().name() == "body")) {
	            new linter.MediaTypeValidator().validate(this, v);
	            return;
	        }
	        if (this.property().isKey()) {
	            if (vl.indexOf(" ") != -1) {
	                v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Keys should not have spaces '" + this.value() + "'", this));
	            }
	        }
	        if (this.name() == "signature" && (this.property().domain().name() == "Resource" || this.property().domain().name() == "Method" || this.property().domain().name() == "MethodBase")) {
	            if (this.property().domain() instanceof defs.NodeClass) {
	                new linter.SignatureValidator().validate(this, v);
	                return;
	            }
	        }
	        //TODO TEMP ADDITION
	        if (this.property().name() == "example" || this.property().name() == "content") {
	            var pn = this.parent().definition().name();
	            new linter.ExampleValidator().validate(this, v);
	        }
	        if (this.property().name() == "name") {
	            //TODO MOVE TO DEF SYSTEM
	            if (this.parent().property() && this.parent().property().name() == 'uriParameters') {
	                new linter.UrlParameterNameValidator().validate(this, v);
	                return;
	            }
	            if (this.parent().property() && this.parent().property().name() == 'baseUriParameters') {
	                new linter.UrlParameterNameValidator().validate(this, v);
	                return;
	            }
	        }
	        if (this.property().range().name() == "RelativeUri") {
	            new linter.UriValidator().validate(this, v);
	            return;
	        }
	        if (this.property().range().name() == "FullUriTemplate") {
	            new linter.UriValidator().validate(this, v);
	            return;
	        }
	        if ("pattern" == this.name() && "StringType" == this.definition().name() && this.parent().definition().isAssignableFrom("StrElement")) {
	            try {
	                new RegExp(this.value());
	            }
	            catch (Error) {
	                v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Illegal pattern " + this.value(), this));
	            }
	        }
	        if ("name" == this.name() && "StringType" == this.definition().name() && (typeof this.value() == "string") && this.value().indexOf("[") == 0 && this.value().lastIndexOf("]") == this.value().length - 1) {
	            if (this.parent() instanceof ASTNodeImpl && "properties" == this.parent().property().name()) {
	                if (this.parent().parent() instanceof ASTNodeImpl && "ObjectField" == this.parent().parent().definition().name()) {
	                    try {
	                        var cleanedValue = this.value().substr(1, this.value().length - 2);
	                        new RegExp(cleanedValue);
	                    }
	                    catch (Error) {
	                        v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Illegal pattern " + cleanedValue, this));
	                    }
	                }
	            }
	        }
	        if (this.property().range().name() == "SchemaString" && this.property().range() instanceof def.ValueType && this.property().range().universe().version() == "RAML10") {
	            var pn = this.parent().definition().name();
	            new linter.SchemaOrTypeValidator().validate(this, v);
	            return;
	        }
	        if (this.property() instanceof def.Property) {
	            if (pr.isTypeExpr()) {
	                new linter.SchemaOrTypeValidator().validate(this, v);
	                return;
	            }
	        }
	        if (pr.isReference() || pr.isDescriminator()) {
	            new linter.DescriminatorOrReferenceValidator().validate(this, v);
	        }
	        else {
	            new linter.NormalValidator().validate(this, v);
	        }
	    };
	    ASTPropImpl.prototype.toRuntime = function () {
	        var vl = this.value();
	        var valueObj = this.fillValue(this.property().range(), vl);
	        if (valueObj['parse']) {
	            try {
	                return valueObj.parse();
	            }
	            catch (e) {
	                return e;
	            }
	        }
	        return valueObj;
	    };
	    ASTPropImpl.prototype.isElement = function () {
	        return false;
	    };
	    ASTPropImpl.prototype.property = function () {
	        return this._prop;
	    };
	    ASTPropImpl.prototype.convertMultivalueToString = function (value) {
	        //|\n  xxx\n  yyy\n  zzz
	        var gap = 0;
	        var pos = 2;
	        while (value[pos] == ' ') {
	            gap++;
	            pos++;
	        }
	        //console.log('gap: ' + gap);
	        var lines = textutil.splitOnLines(value);
	        lines = lines.map(function (line) {
	            //console.log('line: ' + line);
	            return line.substring(gap, line.length);
	        });
	        return lines.join('');
	    };
	    ASTPropImpl.prototype.value = function () {
	        if (this._computed) {
	            return this.computedValue(this.property().name());
	        }
	        if (this.fromKey) {
	            return this._node.key();
	        }
	        if (this.property().isAnnotation() && this._node.key() && this._node.key() != 'annotations') {
	            return new StructuredValue(this._node, this.parent(), this._prop);
	        }
	        var actualValue = this._node.value(); //TODO FIXME
	        if (this.property().isSelfNode()) {
	            if (!actualValue || actualValue instanceof jsyaml.ASTNode) {
	                actualValue = this._node;
	                if (actualValue.children().length == 0) {
	                    actualValue = null;
	                }
	            }
	        }
	        if (actualValue instanceof jsyaml.ASTNode || actualValue instanceof proxy.LowLevelProxyNode) {
	            return new StructuredValue(actualValue, this.parent(), this._prop);
	        }
	        if (textutil.isMultiLineValue(actualValue)) {
	            var res = this.convertMultivalueToString(actualValue);
	            //console.log('converted: [' + textutil.replaceNewlines(res) + ']');
	            return res;
	        }
	        return actualValue;
	    };
	    ASTPropImpl.prototype.name = function () {
	        return this._prop.name();
	    };
	    ASTPropImpl.prototype.printDetails = function (indent) {
	        var className = this.definition().name();
	        var definitionClassName = this.property().range().name();
	        return (indent ? indent : "") + (this.name() + " : " + className + "[" + definitionClassName + "]" + "  =  " + this.value()) + "\n";
	    };
	    ASTPropImpl.prototype.isAttr = function () {
	        return true;
	    };
	    ASTPropImpl.prototype.isUnknown = function () {
	        return false;
	    };
	    ASTPropImpl.prototype.setValue = function (value) {
	        if (value == this.value())
	            return;
	        var c = new ll.CompositeCommand();
	        if (typeof value === 'string') {
	            var val = value;
	            //FIXME actually isFromParentKey should be enough in future does not changing it now for safety reasons
	            if (this._prop.isFromParentKey() || this._prop.isAnnotation()) {
	                if (this._prop.isAnnotation()) {
	                    val = '(' + val + ')';
	                }
	                c.commands.push(ll.setKey(this._node, val));
	            }
	            else {
	                if ((!val || val.length == 0) && !this.isEmbedded()) {
	                    c.commands.push(ll.removeNode(this._node.parent(), this._node));
	                    this.parent().clearChildrenCache();
	                }
	                else {
	                    if (!val)
	                        val = '';
	                    c.commands.push(ll.setAttr(this._node, val));
	                }
	            }
	        }
	        else {
	            if (this._prop.isFromParentKey()) {
	                throw "couldn't set structured value to a key: " + this._prop.name();
	            }
	            var sval = value;
	            c.commands.push(ll.setAttrStructured(this._node, sval));
	        }
	        this._node.execute(c);
	    };
	    ASTPropImpl.prototype.setKey = function (value) {
	        if (value == this.name())
	            return;
	        var c = new ll.CompositeCommand();
	        c.commands.push(ll.setKey(this._node, value));
	        this._node.execute(c);
	    };
	    ASTPropImpl.prototype.children = function () {
	        return [];
	    };
	    ASTPropImpl.prototype.addStringValue = function (value) {
	        var sc = jsyaml.createScalar(value);
	        var target = this.lowLevel();
	        //console.log('add to target: ' + target.kindName());
	        if (target.isScalar()) {
	            target = target.parent();
	        }
	        else if (target.isMapping()) {
	        }
	        //var llparent = this.lowLevel().parent();
	        //console.log('parent: ' + llparent.kind());
	        //var attr = new ASTPropImpl(sc, this.parent(), this.property().range(), this.property());
	        //this.parent().add(attr);
	        var command = new ll.CompositeCommand();
	        command.commands.push(ll.insertNode(target, sc, null, true));
	        this.lowLevel().execute(command);
	        this.parent().clearChildrenCache();
	    };
	    ASTPropImpl.prototype.addStructuredValue = function (sv) {
	        //var sc = jsyaml.createScalar(value);
	        var target = this.lowLevel();
	        //console.log('add to target: ' + target.kindName());
	        if (target.isScalar()) {
	            target = target.parent();
	        }
	        else if (target.isMapping()) {
	            var ln = this.lowLevel();
	        }
	        //var llparent = this.lowLevel().parent();
	        //console.log('parent: ' + llparent.kind());
	        //var attr = new ASTPropImpl(sc, this.parent(), this.property().range(), this.property());
	        //this.parent().add(attr);
	        var command = new ll.CompositeCommand();
	        command.commands.push(ll.insertNode(target, sv.lowLevel(), null, true));
	        this.lowLevel().execute(command);
	        this.parent().clearChildrenCache();
	    };
	    ASTPropImpl.prototype.addValue = function (value) {
	        if (!this.property().isMultiValue())
	            throw "setValue(string) only apply to multi-values properties";
	        if (typeof value == 'string') {
	            this.addStringValue(value);
	        }
	        else {
	            this.addStructuredValue(value);
	        }
	    };
	    ASTPropImpl.prototype.isEmbedded = function () {
	        var keyname = this.lowLevel().asMapping().key.value;
	        //console.log('propery: ' + this.property().name());
	        //console.log('mapping: ' + keyname);
	        return this.property().canBeValue() && keyname != this.property().name();
	    };
	    ASTPropImpl.prototype.remove = function () {
	        //if(!this.property().isMultiValue()) throw "setValue(string) only apply to multi-values properties";
	        //var sc = jsyaml.createScalar(value);
	        var llparent = this.lowLevel().parent();
	        //llparent.show('parent:');
	        //this.lowLevel().show('attribute:');
	        //console.log('parent: ' + llparent.kind());
	        //var attr = new ASTPropImpl(sc, this.parent(), this.property().range(), this.property());
	        //this.parent().add(attr);
	        if (!this.property().isMultiValue() && this.isEmbedded()) {
	            // it's embedded value, need to clean scalar instead
	            //console.log('embedded!');
	            this.setValue('');
	        }
	        else {
	            var command = new ll.CompositeCommand();
	            command.commands.push(ll.removeNode(llparent, this.lowLevel()));
	            this.lowLevel().execute(command);
	            this.parent().clearChildrenCache();
	        }
	    };
	    ASTPropImpl.prototype.setValues = function (values) {
	        var _this = this;
	        if (!this.property().isMultiValue())
	            throw "setValue(string[]) only apply to multi-values properties";
	        var node = this.parent();
	        if (this.isEmpty()) {
	        }
	        else {
	            var llnode = node.lowLevel();
	            var attrs = node.attributes(this.name());
	            attrs.forEach(function (attr) { return attr.remove(); });
	        }
	        values.forEach(function (val) { return node.attrOrCreate(_this.name()).addValue(val); });
	        /*
	         if(attrs.length == 1) {
	         var anode = <jsyaml.ASTNode>attrs[0].lowLevel();
	         //console.log('attribute : ' + anode.kindName());
	         //anode.show("ATTR:");
	         if(anode.isMapping()) {
	         // that's crazy but it means zero length array indeed )
	         // nothing to remove so...
	         } else {
	         attrs.forEach(attr => attr.remove());
	         }
	         } else {
	         attrs.forEach(attr => attr.remove());
	         }
	         */
	    };
	    ASTPropImpl.prototype.isEmpty = function () {
	        if (!this.property().isMultiValue())
	            throw "isEmpty() only apply to multi-values attributes";
	        //console.log('remove: ' + this.name());
	        var node = this.parent();
	        var llnode = node.lowLevel();
	        //node.lowLevel().show('Parent:');
	        var attrs = node.attributes(this.name());
	        //console.log('attributes: ' + attrs.length);
	        if (attrs.length == 0) {
	            return true;
	        }
	        else if (attrs.length == 1) {
	            var anode = attrs[0].lowLevel();
	            //console.log('attribute : ' + anode.kindName());
	            //anode.show("ATTR:");
	            if (anode.isMapping()) {
	                // that's crazy but it means zero length array indeed )
	                return true;
	            }
	            else {
	                return false;
	            }
	        }
	        else {
	            return false;
	        }
	    };
	    return ASTPropImpl;
	})(BasicASTNode);
	exports.ASTPropImpl = ASTPropImpl;
	var nodeBuilder = new builder.BasicNodeBuilder();
	var ASTNodeImpl = (function (_super) {
	    __extends(ASTNodeImpl, _super);
	    function ASTNodeImpl(node, parent, _def, _prop) {
	        _super.call(this, node, parent);
	        this._def = _def;
	        this._prop = _prop;
	        this._expanded = false;
	        this._allowQuestion = false;
	        this._subTypesCache = null;
	        this._auxChecked = false;
	        if (node) {
	            node.setHighLevelNode(this);
	        }
	    }
	    ASTNodeImpl.prototype.getKind = function () {
	        return 1 /* NODE */;
	    };
	    ASTNodeImpl.prototype.wrapperNode = function () {
	        if (!this._wrapperNode) {
	            this._wrapperNode = ModelFactory.buildWrapperNode(this);
	        }
	        return this._wrapperNode;
	    };
	    ASTNodeImpl.prototype.propertiesAllowedToUse = function () {
	        var _this = this;
	        return this.definition().allProperties().filter(function (x) { return _this.isAllowedToUse(x); });
	    };
	    ASTNodeImpl.prototype.isAllowedToUse = function (p) {
	        var _this = this;
	        var ok = true;
	        if (p.isSystem()) {
	            return false;
	        }
	        p.getContextRequirements().forEach(function (y) {
	            if (y.name.indexOf('(') != -1) {
	                //TODO HANDLE IT LATER
	                return true;
	            }
	            var vl = _this.computedValue(y.name);
	            if (vl) {
	                ok = ok && (vl == y.value);
	            }
	            else {
	                if (y.value) {
	                    ok = false;
	                }
	            }
	        });
	        return ok;
	    };
	    ASTNodeImpl.prototype.allowRecursive = function () {
	        if (this.definition().isUserDefined()) {
	            return true;
	        }
	        return false;
	    };
	    ASTNodeImpl.prototype.setWrapperNode = function (node) {
	        this._wrapperNode = node;
	    };
	    ASTNodeImpl.prototype.setAssociatedType = function (d) {
	        this._associatedDef = d;
	    };
	    ASTNodeImpl.prototype.associatedType = function () {
	        return this._associatedDef;
	    };
	    ASTNodeImpl.prototype.findById = function (id) {
	        var _this = this;
	        var v = this._knownIds;
	        if (!v) {
	            this._knownIds = {};
	            var all = search.allChildren(this);
	            all.forEach(function (x) { return _this._knownIds[x.id()] = x; });
	        }
	        return this._knownIds[id];
	    };
	    ASTNodeImpl.prototype.isAuxilary = function () {
	        var _this = this;
	        if (this._isAux) {
	            return true;
	        }
	        if (this._auxChecked) {
	            return false;
	        }
	        this._auxChecked = true;
	        var mr = _.find(this.lowLevel().children(), function (x) { return x.key() == "masterRef"; });
	        if (mr && mr.value()) {
	            this._isAux = true;
	            var val = mr.value();
	            var unit = this.lowLevel().unit().project().resolve(this.lowLevel().unit().path(), val);
	            var api = hl.fromUnit(unit);
	            if (api) {
	                var v = search.allChildren(api);
	                this._knownIds = {};
	                v.forEach(function (x) { return _this._knownIds[x.id()] = x; });
	            }
	            return true;
	        }
	        return false;
	    };
	    ASTNodeImpl.prototype.insideOfDeclaration = function () {
	        if (this.definition().isDeclaration()) {
	            return true;
	        }
	        if (this.parent()) {
	            return this.parent().insideOfDeclaration();
	        }
	    };
	    ASTNodeImpl.prototype.isAllowedId = function () {
	        var r = this.root();
	        if (this.id() == "") {
	            return true;
	        }
	        if (r.definition().name() == "Extension") {
	            return true;
	        }
	        if (r.isAuxilary()) {
	            if (this.property().name() == "annotationTypes" && this.definition().name() == "AnnotationType") {
	                return true;
	            }
	            if (this.property().name() == "types" && this.definition().isAssignableFrom("DataElement")) {
	                return true;
	            }
	            if (this.insideOfDeclaration()) {
	                var vl = this.computedValue("decls");
	                if (vl == "true") {
	                    return true;
	                }
	            }
	            if (r._knownIds) {
	                var m = r._knownIds[this.id()] != null;
	                if (!m) {
	                    if (this.parent() && this.parent().parent()) {
	                        if (this.parent().isAllowedId()) {
	                            return true;
	                        }
	                    }
	                }
	                return m;
	            }
	            if (this.parent() && this.parent().parent()) {
	                if (this.parent().isAllowedId()) {
	                    return true;
	                }
	            }
	            return false;
	        }
	        return true;
	    };
	    ASTNodeImpl.prototype.printDetails = function (indent) {
	        var result = "";
	        if (!indent)
	            indent = "";
	        var classname = this.definition().name();
	        var definitionClasName = this.property() ? this.property().range().name() : "";
	        var parentPropertyName = this.property() ? this.property().name() : "";
	        result += indent + parentPropertyName + " : " + classname + "[" + definitionClasName + "]" + "\n";
	        this.children().forEach(function (child) {
	            result += child.printDetails(indent + "\t");
	        });
	        return result;
	    };
	    ASTNodeImpl.prototype.getExtractedChildren = function () {
	        var r = this.root();
	        if (r.isAuxilary()) {
	            if (r._knownIds) {
	                var i = r._knownIds[this.id()];
	                if (i) {
	                    return i.children();
	                }
	            }
	            return [];
	        }
	        return [];
	    };
	    ASTNodeImpl.prototype.allowsQuestion = function () {
	        return this._allowQuestion || this.definition().getAllowQuestion();
	    };
	    ASTNodeImpl.prototype.findReferences = function () {
	        var rs = [];
	        search.refFinder(this.root(), this, rs);
	        //filtering out equal results
	        var filteredReferences = [];
	        rs.forEach(function (ref) {
	            if (!_.find(filteredReferences, function (existing) { return existing == ref; })) {
	                filteredReferences.push(ref);
	            }
	        });
	        return filteredReferences;
	    };
	    ASTNodeImpl.prototype.name = function () {
	        var ka = _.find(this.directChildren(), function (x) { return x.property() && x.property().isKey(); });
	        if (ka && ka instanceof ASTPropImpl) {
	            var c = ka.value();
	            if (c) {
	                var io = c.indexOf(':');
	                if (io != -1) {
	                    return c.substring(0, io);
	                }
	            }
	            return c;
	        }
	        return _super.prototype.name.call(this);
	    };
	    ASTNodeImpl.prototype.findElementAtOffset = function (n) {
	        return this._findNode(this, n, n);
	    };
	    ASTNodeImpl.prototype.isElement = function () {
	        return true;
	    };
	    ASTNodeImpl.prototype.universe = function () {
	        if (this._universe) {
	            return this._universe;
	        }
	        return this.definition().universe();
	    };
	    ASTNodeImpl.prototype.setUniverse = function (u) {
	        this._universe = u;
	    };
	    ASTNodeImpl.prototype.validate = function (v) {
	        var _this = this;
	        if (!this.definition()) {
	            return; //FIXME
	        }
	        if (!this.parent()) {
	            var u = this.universe();
	            var tv = u.getTypedVersion();
	            if (tv) {
	                if (tv.indexOf("#%") == 0) {
	                    if (tv != "#%RAML 0.8" && tv != "#%RAML 1.0") {
	                        var i = createIssue(9 /* NODE_HAS_VALUE */, "Unknown version of RAML expected to see one of '#%RAML 0.8' or '#%RAML 1.0'", this);
	                        v.accept(i);
	                    }
	                    var tl = u.getTopLevel();
	                    if (tl) {
	                        if (tl != this.definition().name()) {
	                            var i = createIssue(9 /* NODE_HAS_VALUE */, "Unknown top level type:" + tl, this);
	                            v.accept(i);
	                        }
	                    }
	                }
	            }
	            if (this.definition().name() == "Api" && !this.definition().isUserDefined()) {
	                if (this.definition().universe().version() != "RAML08") {
	                    var owl = new ovlval.OverloadingValidator();
	                    owl.validateApi(this.wrapperNode(), v);
	                }
	            }
	            var r = this.lowLevel().unit();
	            this.lowLevel().visit(function (x) {
	                if (x.unit() != r) {
	                    return false;
	                }
	                if (x.value() && x._node && x._node.value) {
	                    if (x._node.value.doubleQuoted) {
	                        var ind = (x.value() + "").indexOf(":");
	                        var nl = (x.value() + "").indexOf("\n");
	                        if (ind != -1 && nl != -1 && (!x.includePath() || x.includePath().length == 0)) {
	                            var i = createIssue(9 /* NODE_HAS_VALUE */, "Suspicious double quoted multiline scalar, it is likely that you forgot closing \" " + x.value(), _this, true);
	                            i.start = x._node.value.startPosition;
	                            i.end = x._node.value.endPosition;
	                            if (i.start == i.end) {
	                                i.end++;
	                            }
	                            v.accept(i);
	                        }
	                    }
	                }
	                return true;
	            });
	            linter.lintNode(this, v);
	        }
	        if (!this.isAllowedId()) {
	            if ((!this.property()) || this.property().name() != "annotations") {
	                if (this.definition().name() != "GlobalSchema") {
	                    var i = createIssue(10 /* ONLY_OVERRIDE_ALLOWED */, "This node does not override any node from master api:" + this.id(), this);
	                    v.accept(i);
	                }
	            }
	        }
	        var nc = this.definition();
	        if (!this.definition().getAllowAny()) {
	            _super.prototype.validate.call(this, v);
	        }
	        else {
	            this.validateIncludes(v);
	        }
	        ;
	        if (nc instanceof def.NodeClass) {
	            var anc = nc;
	            if (nc.isAssignableFrom("DataElement")) {
	                //var tpes=anc.allSuperTypes();
	                var props = this.elementsOfKind("properties");
	                if (props.length > 0) {
	                    var types = this.attributes("type");
	                    types.forEach(function (t) {
	                        var tp = typeExpression.getType(_this, t.value(), {});
	                        if (tp instanceof def.NodeClass) {
	                            var xnc = tp;
	                            var rps = xnc.allRuntimeProperties();
	                            rps.forEach(function (rp) {
	                                var override = _.find(props, function (x) { return x.name() == rp.name(); });
	                                if (override) {
	                                    var node = _this;
	                                    var i = createIssue(10 /* ONLY_OVERRIDE_ALLOWED */, "overriding property " + override.name() + " inhertied from " + t.value(), override);
	                                    v.accept(i);
	                                }
	                            });
	                        }
	                    });
	                }
	                var faceted = this.elementsOfKind("facets");
	                if (faceted.length > 0) {
	                    var types = this.attributes("type");
	                    types.forEach(function (t) {
	                        var tp = typeExpression.getType(_this, t.value(), {});
	                        if (tp instanceof def.NodeClass) {
	                            var xnc = tp;
	                            var rps = xnc.allProperties();
	                            rps.forEach(function (rp) {
	                                var override = _.find(faceted, function (x) { return x.name() == rp.name(); });
	                                if (override) {
	                                    var node = _this;
	                                    var i = createIssue(10 /* ONLY_OVERRIDE_ALLOWED */, "overriding facet " + override.name() + " inhertied from " + t.value(), override);
	                                    v.accept(i);
	                                }
	                            });
	                        }
	                    });
	                }
	            }
	            if (anc.isRuntime()) {
	                var facets = anc.getFixedFacets();
	                for (var fk in facets) {
	                    var facet = anc.getRepresentationOf().facet(fk);
	                    if (facet) {
	                        var fv = facet.getFacetValidator();
	                        if (fv) {
	                            var obj = this.lowLevel().dumpToObject();
	                            obj = obj[this.lowLevel().key()];
	                            try {
	                                var message = fv(obj, facets[fk]);
	                                if (typeof message == 'string') {
	                                    var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "" + message, this);
	                                    v.accept(i);
	                                }
	                            }
	                            catch (e) {
	                                var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, e.message, this);
	                                v.accept(i);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        checkPropertyQuard(this, v);
	        if (typeof this.value() == 'string' && !this.definition().allowValue()) {
	            if (this.parent()) {
	                var i = createIssue(9 /* NODE_HAS_VALUE */, "node " + this.name() + " can not be a scalar", this);
	                v.accept(i);
	            }
	        }
	        this.definition().requiredProperties().forEach(function (x) {
	            var r = x.range();
	            if (r instanceof def.Array) {
	                var ar = r;
	                r = ar.component;
	            }
	            if (r.isValueType()) {
	                var nm = _this.attr(x.name());
	                if (!nm) {
	                    var i = createIssue(3 /* MISSING_REQUIRED_PROPERTY */, "Missing required property " + x.name(), _this);
	                    v.accept(i);
	                }
	            }
	            else {
	                var el = _this.elementsOfKind(x.name());
	                if (!el || el.length == 0) {
	                    var i = createIssue(3 /* MISSING_REQUIRED_PROPERTY */, "Missing required property " + x.name(), _this);
	                    v.accept(i);
	                }
	            }
	        });
	        this.definition().getContextRequirements().forEach(function (x) {
	            if (!_this.checkContextValue(x.name, x.value, _this.toRuntimeModel())) {
	                v.accept(createIssue(8 /* MISSED_CONTEXT_REQUIREMENT */, x.name + " should be " + x.value + " to use type " + _this.definition().name(), _this));
	            }
	        });
	        if (this.definition().universe().version() == "RAML08") {
	            var m = {};
	            var els = this.directChildren().filter(function (x) { return x.isElement(); });
	            els.forEach(function (x) {
	                if (x["_computed"]) {
	                    return;
	                }
	                if (!x.name()) {
	                    return; //handling nodes with no key (documentation)
	                }
	                var rm = x.lowLevel().parent() ? x.lowLevel().parent().end() : "";
	                var k = x.name() + rm;
	                if (m[k]) {
	                    var i = createIssue(5 /* KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT */, x.name() + " already exists in this context", x);
	                    v.accept(i);
	                }
	                else {
	                    m[k] = 1;
	                }
	            });
	        }
	        else {
	            var m = {};
	            var els = this.directChildren().filter(function (x) { return x.isElement(); });
	            els.forEach(function (x) {
	                if (x["_computed"]) {
	                    return;
	                }
	                if (!x.name()) {
	                    return; //handling nodes with no key (documentation)
	                }
	                if (allowOwerride[x.property().name()]) {
	                    return;
	                }
	                var k = x.name() + x.property().name();
	                if (m[k]) {
	                    var i = createIssue(5 /* KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT */, x.name() + " already exists in this context", x);
	                    v.accept(i);
	                }
	                else {
	                    m[k] = 1;
	                }
	            });
	        }
	        var allLowlevel = this.lowLevel().children();
	        var mm = _.groupBy(allLowlevel, function (x) { return x.key(); });
	        var pr = this.directChildren().filter(function (x) { return x.isAttr(); });
	        var gr = _.groupBy(pr, function (x) { return x.name(); });
	        var all = this.directChildren();
	        var allG = _.groupBy(all, function (x) { return x.name(); });
	        var computedAnnotationsMultiplValues = false;
	        Object.keys(mm).forEach(function (x) {
	            if (x.charAt(0) == '(') {
	                if (mm[x].length > 1) {
	                    if (!computedAnnotationsMultiplValues) {
	                        computedAnnotationsMultiplValues = true;
	                        pr.forEach(function (z) {
	                            if (z.property().isAnnotation()) {
	                                var annotationRange = z.property().range();
	                                var attr = z;
	                                var refsTo = attr.findReferenceDeclaration();
	                                if (refsTo != null) {
	                                    var refNode = refsTo;
	                                    var multiple = refNode.attr("allowMultiple");
	                                    if (multiple) {
	                                        var mv = multiple.value();
	                                        if (mv == 'true') {
	                                            delete mm[attr.lowLevel().key()];
	                                        }
	                                    }
	                                }
	                            }
	                        });
	                    }
	                }
	            }
	        });
	        Object.keys(mm).forEach(function (x) {
	            if (x) {
	                if (mm[x].length > 1 && !allG[x]) {
	                    var i = createIssue(4 /* PROPERTY_EXPECT_TO_HAVE_SINGLE_VALUE */, x + " should have a single value", _this);
	                    i.start = mm[x][0].keyStart();
	                    i.end = mm[x][0].keyEnd();
	                    v.accept(i);
	                }
	            }
	        });
	        Object.keys(gr).forEach(function (x) {
	            if (gr[x].length > 1 && !gr[x][0].property().isMultiValue()) {
	                gr[x].forEach(function (y) {
	                    var i = createIssue(4 /* PROPERTY_EXPECT_TO_HAVE_SINGLE_VALUE */, y.property().name() + " should have a single value", y);
	                    v.accept(i);
	                });
	            }
	        });
	        if (this._def && this.property() && this.property().name() == "types") {
	            if (buildIns[this.name()]) {
	                var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "You can not redeclare build in types", this);
	                v.accept(i);
	            }
	            var at = this.attributes("type");
	            if (at) {
	                var fn = false;
	                at.forEach(function (x) {
	                    if (x.value() == _this.name()) {
	                        var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "Recurrent type definition", _this.attr("type") ? _this.attr("type") : _this);
	                        v.accept(i);
	                        fn = true;
	                        return;
	                    }
	                });
	                if (fn) {
	                    return;
	                }
	            }
	            try {
	                this.traverseDec(this._def, v, 0);
	            }
	            catch (e) {
	            }
	            if (!this._associatedDef) {
	                if (_.find(this.definition().allSuperTypes(), function (x) { return x.name() == "DataElement"; })) {
	                    this._associatedDef = typeBuilder.typeFromNode(this);
	                }
	            }
	            if (this._associatedDef) {
	                var st = this._associatedDef.superTypes();
	                var nameMap = {};
	                st.forEach(function (x) {
	                    nameMap[x.name()] = x;
	                });
	                var newSt = [];
	                for (var nm in nameMap) {
	                    newSt.push(nameMap[nm]);
	                }
	                st = newSt;
	                if (st.length > 1) {
	                    if (_.find(st, function (x) { return _this.isPrimitive(x); })) {
	                        if (_.find(st, function (x) { return _this.isObject(x); })) {
	                            var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "You can not inherit both from types of different kind", this.attr("type") ? this.attr("type") : this);
	                            v.accept(i);
	                            return;
	                        }
	                    }
	                    if (_.find(st, function (x) { return _this.isArray(x); })) {
	                        if (_.find(st, function (x) { return !_this.isArray(x); })) {
	                            var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "You can not inherit both from types of different kind", this.attr("type") ? this.attr("type") : this);
	                            v.accept(i);
	                            return;
	                        }
	                    }
	                    if (_.filter(st, function (x) { return _this.isPrimitive(x); }).length > 1) {
	                        var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "You can not inherit from two primitive types", this.attr("type") ? this.attr("type") : this);
	                        v.accept(i);
	                        return;
	                    }
	                }
	            }
	        }
	    };
	    ASTNodeImpl.prototype.isPrimitive = function (q) {
	        return !this.isArray(q) && !this.isObject(q) && !this.isUnion(q) && q.name() != "DataElement";
	    };
	    ASTNodeImpl.prototype.isObject = function (q) {
	        return q.name() == "ObjectField" || _.find(q.allSuperTypes(), function (x) { return x.name() == 'ObjectField'; }) != null;
	    };
	    ASTNodeImpl.prototype.isArray = function (q) {
	        return _.find(q.allSuperTypes(), function (x) { return x instanceof defs.Array; }) != null;
	    };
	    ASTNodeImpl.prototype.isUnion = function (q) {
	        return _.find(q.allSuperTypes(), function (x) { return x instanceof defs.Union; }) != null;
	    };
	    /**
	     * !!!You cannot inherit from types of different kind at the same moment ( kinds are: union types, array types, object types, scalar types )
	     * !!!You cannot inherit from types extending union types ( ex: you cannot extend from Pet if Pet = Dog | Cat )
	     * You cannot inherit from multiple primitive types
	     * !!! You cannot inherit from a type that extends Array type
	     * Facets are always inherited
	     * You can fix a previously defined facet to a value if the facet is defined on a superclass
	     * Properties are only allowed on object types
	     * You cannot create cyclic dependencies when inheriting
	     * @param d
	     * @param v
	     * @param level
	     * @param visited
	     */
	    ASTNodeImpl.prototype.traverseDec = function (d, v, level, visited) {
	        var _this = this;
	        if (visited === void 0) { visited = {}; }
	        if (d == null) {
	            return;
	        }
	        if (d instanceof def.Array && level > 0) {
	            var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "Extending from types extending array types is not allowed", this.attr("type") ? this.attr("type") : this);
	            v.accept(i);
	            return;
	        }
	        if (d instanceof def.Union && level > 0) {
	            var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "Extending from types extending union types is not allowed", this.attr("type") ? this.attr("type") : this);
	            v.accept(i);
	            return;
	        }
	        if (visited[d.name()]) {
	            var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "Recurrent type definition", this.attr("type") ? this.attr("type") : this);
	            v.accept(i);
	            throw new Error();
	        }
	        visited[d.name()] = this.definition();
	        try {
	            if (d.name() == this.name() && level > 0) {
	                var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "Recurrent type definition", this.attr("type") ? this.attr("type") : this);
	                v.accept(i);
	                throw new Error();
	            }
	            if (d instanceof defs.Array) {
	                this.traverseDec(d.component, v, level + 1, visited);
	                return;
	            }
	            if (d instanceof defs.Union) {
	                var lleft = level + 1;
	                var lright = level + 1;
	                var union = d;
	                if (d.left instanceof defs.Union) {
	                    var ul = d.left;
	                    if (union.getDeclaringNode() == ul.getDeclaringNode()) {
	                        lleft = level;
	                    }
	                }
	                if (d.right instanceof defs.Union) {
	                    var ul = d.right;
	                    if (union.getDeclaringNode() == ul.getDeclaringNode()) {
	                        lright = level;
	                    }
	                }
	                if (lleft == level + 1) {
	                    this.traverseDec(d.left, v, lleft, visited);
	                }
	                if (lright == level + 1) {
	                    this.traverseDec(d.right, v, lright, visited);
	                }
	                return;
	            }
	            var mn = d.allSuperTypes();
	            mn.forEach(function (yy) {
	                if (yy instanceof defs.AbstractType) {
	                    var node = yy.getDeclaringNode();
	                    if (node || yy instanceof defs.Array || yy instanceof defs.Union) {
	                        _this.traverseDec(yy, v, level + 1, visited);
	                    }
	                }
	            });
	        }
	        finally {
	            delete visited[d.name()];
	        }
	    };
	    ASTNodeImpl.prototype._findNode = function (n, offset, end) {
	        var _this = this;
	        if (n == null) {
	            return null;
	        }
	        if (n.lowLevel()) {
	            //var node:ASTNode=<ASTNode>n;
	            if (n.lowLevel().start() <= offset && n.lowLevel().end() >= end) {
	                var res = n;
	                //TODO INCLUDES
	                n.elements().forEach(function (x) {
	                    if (x.lowLevel().unit() != n.lowLevel().unit()) {
	                        return;
	                    }
	                    var m = _this._findNode(x, offset, end);
	                    if (m) {
	                        res = m;
	                    }
	                });
	                return res;
	            }
	        }
	        return null;
	    };
	    ASTNodeImpl.prototype.isStub = function () {
	        return (!this.lowLevel().unit()) || this.lowLevel().unit().isStubUnit();
	    };
	    ASTNodeImpl.prototype.findInsertionPointLowLevel = function (llnode, property, attr) {
	        //console.log('LL find insertion: node is attr: ' + attr);
	        //always insert attributes at start
	        var llchilds = this.lowLevel().children();
	        var insertionPoint = null;
	        var embed = property && property.isEmbedMap();
	        if (embed && _.find(this.lowLevel().children(), function (x) { return x.key() == property.name(); })) {
	            embed = false;
	        }
	        if (attr || embed) {
	            //var index = this.findLastAttribute();
	            var last = this.findLastAttribute();
	            //console.log('last: ' + last);
	            //for (var i = 0; i < llchilds.length; i++) {
	            //    var ll = <jsyaml.ASTNode>llchilds[i];
	            //    ll.show('child:');
	            //    if(ll.isMapping())
	            //if (!ch[i].isAttr()){
	            //    break;
	            //} else{
	            //    insertionPoint=ch[i].lowLevel();
	            //}
	            //}
	            if (!last) {
	                //insertionPoint = new jsyaml.InsertionPoint(jsyaml.InsertionPointType.START);
	                insertionPoint = jsyaml.InsertionPoint.atStart();
	            }
	            else {
	                insertionPoint = last;
	            }
	        }
	        return insertionPoint;
	    };
	    ASTNodeImpl.prototype.findInsertionPoint = function (node) {
	        //console.log('node: ' + node.property().name());
	        //console.log('HL: find isertion: node is attr: ' + node.isAttr());
	        //console.log('node1: ' + node.lowLevel().text());
	        //always insert attributes at start
	        if (!this.isStub()) {
	            this.clearChildrenCache();
	        }
	        var ch = this.children();
	        var toRet = null;
	        var embed = node.property() && node.property().isEmbedMap();
	        if (embed && _.find(this.lowLevel().children(), function (x) { return x.key() == node.property().name(); })) {
	            embed = false;
	        }
	        //console.log('node2: ' + node.lowLevel().text());
	        if (node.isAttr() || embed) {
	            for (var i = 0; i < ch.length; i++) {
	                if (!ch[i].isAttr()) {
	                    break;
	                }
	                else {
	                    toRet = ch[i].lowLevel();
	                }
	            }
	            if (toRet == null) {
	                toRet = this.lowLevel();
	            }
	        }
	        //console.log('HL insertion: ' + toRet);
	        return toRet;
	    };
	    ASTNodeImpl.prototype.add = function (node) {
	        if (!this.isStub() && this.isEmptyRamlFile()) {
	            this.initRamlFile();
	        }
	        var llnode = node.lowLevel();
	        if (!this._children) {
	            this._children = [];
	        }
	        if (!node.property()) {
	            //now we should find correct property;
	            var an = node;
	            var allProps = this.definition().allProperties();
	            var cp = null;
	            allProps.forEach(function (x) {
	                var r = x.range();
	                if (r == an.definition()) {
	                    cp = x;
	                }
	                var isOk = _.find(an.definition().allSuperTypes(), function (x) { return x == r; });
	                if (isOk) {
	                    cp = x;
	                }
	            });
	            if (!cp) {
	                throw new Error("Unable to find correct child");
	            }
	            else {
	                an._prop = cp;
	            }
	        }
	        var insertionPoint = this.findInsertionPoint(node);
	        //console.log('high level op: ' + this.property() + '.add ' + node.property().name());
	        if (insertionPoint) {
	        }
	        //var newLowLevel:ll.ILowLevelASTNode=null;
	        var command = new ll.CompositeCommand();
	        //now we need to understand to which low level node it should go
	        //command.commands.push(ll.insertNode(this.lowLevel(), node.lowLevel()))
	        var insertionTarget = null;
	        if (node.property().isMerged() || node.property().range().isValueType()) {
	            //console.log('CASE 1');
	            //newLowLevel = node.lowLevel();
	            command.commands.push(ll.insertNode(this.lowLevel(), node.lowLevel(), insertionPoint));
	            insertionTarget = this.lowLevel();
	        }
	        else {
	            //console.log('CASE 2');
	            var name = node.property().name();
	            var target = this.lowLevel();
	            //target.show('TARGET:');
	            //llnode.show('NODE:');
	            var found = this.lowLevel().find(name);
	            insertionTarget = found;
	            if (!found) {
	                //console.log('node not found');
	                var nn = null;
	                //var nn: jsyaml.ASTNode = jsyaml.createSeqNode(name);
	                //var mapping = <yaml.YAMLMapping>nn._actualNode();
	                //var seq: yaml.YAMLSequence = <yaml.YAMLSequence>mapping.value;
	                //if(!seq.items) seq.items = [];
	                //seq.items.push((<jsyaml.ASTNode>node.lowLevel())._actualNode());
	                if (node.property().isEmbedMap()) {
	                    var v10 = this.definition().universe().version() == 'RAML10';
	                    if (llnode.isValueMap() && v10)
	                        nn = jsyaml.createMapNode(name);
	                    else
	                        nn = jsyaml.createSeqNode(name);
	                    //console.log('NN: ' + yaml.Kind[nn._actualNode().kind]);
	                    nn.addChild(node.lowLevel());
	                }
	                else {
	                    nn = jsyaml.createNode(name);
	                    nn.addChild(node.lowLevel());
	                }
	                //nn.show('WRAPPED NODE:');
	                //target.show('INSERT WRAPPED NODE TO:');
	                command.commands.push(ll.insertNode(target, nn, insertionPoint));
	                insertionTarget = target;
	            }
	            else {
	                //console.log('node found');
	                //found.show('INSERT2: ');
	                if (node.property().isEmbedMap()) {
	                    //newLowLevel=node.lowLevel();
	                    command.commands.push(ll.insertNode(found, node.lowLevel(), insertionPoint, true));
	                }
	                else {
	                    //newLowLevel=node.lowLevel();
	                    command.commands.push(ll.insertNode(found, node.lowLevel(), insertionPoint, false));
	                }
	            }
	        }
	        if (this.isStub()) {
	            var insertionIndex = this.findLastAttributeIndex();
	            if (insertionIndex < 0) {
	                this._children.push(node);
	            }
	            else {
	                //TODO behavior should be smarter we are ignoring insertion points now
	                this._children.splice(insertionIndex, 0, node);
	            }
	            command.commands.forEach(function (x) { return insertionTarget.addChild(x.value); });
	            return;
	        }
	        this.lowLevel().execute(command);
	        this._children.push(node);
	        //now we need to add new child to our children;
	        node.setParent(this);
	    };
	    ASTNodeImpl.prototype.remove = function (node) {
	        if (this.isStub()) {
	            if (node instanceof ASTNodeImpl) {
	                var cm = node;
	                if (cm.isInEdit) {
	                    return;
	                }
	            }
	            if (!this._children) {
	                return;
	            }
	            this._children = this._children.filter(function (x) { return x != node; });
	            return;
	        }
	        var command = new ll.CompositeCommand();
	        if (node instanceof ASTNodeImpl) {
	            var aNode = node;
	            if (!aNode.property().isMerged()) {
	                if (this.elementsOfKind(aNode.property().name()).length == 1) {
	                    command.commands.push(ll.removeNode(this.lowLevel(), aNode.lowLevel().parent().parent()));
	                }
	                else {
	                    command.commands.push(ll.removeNode(this.lowLevel(), aNode.lowLevel()));
	                }
	            }
	            else {
	                command.commands.push(ll.removeNode(this.lowLevel(), aNode.lowLevel()));
	            }
	        }
	        else {
	            command.commands.push(ll.removeNode(this.lowLevel(), node.lowLevel()));
	        }
	        this.lowLevel().execute(command);
	        //update high level
	        this._children = this._children.filter(function (x) { return x != node; });
	    };
	    ASTNodeImpl.prototype.dump = function (flavor) {
	        return this._node.dump();
	    };
	    ASTNodeImpl.prototype.patchType = function (d) {
	        this._def = d;
	        var ass = this._associatedDef;
	        this._associatedDef = null;
	        this._children = null;
	    };
	    ASTNodeImpl.prototype.children = function () {
	        if (this._children) {
	            var extra = this.getExtractedChildren();
	            var res = this._children.concat(extra);
	            return res;
	        }
	        if (this._node) {
	            this._children = nodeBuilder.process(this, this._node.children());
	            this._children = this._children.filter(function (x) { return x != null; });
	            //FIXME
	            var extra = this.getExtractedChildren();
	            var res = this._children.concat(extra);
	            return res;
	        }
	        return [];
	    };
	    ASTNodeImpl.prototype.directChildren = function () {
	        if (this._children) {
	            return this._children;
	        }
	        if (this._node) {
	            this._children = nodeBuilder.process(this, this._node.children());
	            return this._children;
	        }
	        return [];
	    };
	    ASTNodeImpl.prototype.resetChildren = function () {
	        this._children = null;
	    };
	    //createAttr(n:string,v:string){
	    //    var mapping=jsyaml.createMapping(n,v);
	    //    this._node.addChild(mapping);
	    //    this._children=null;
	    //}
	    ASTNodeImpl.prototype.findLastAttributeIndex = function () {
	        var last = -1;
	        var childs = this.lowLevel().children();
	        for (var i = 0; i < childs.length; i++) {
	            var node = childs[i];
	            if (!node.isMapping())
	                continue;
	            var name = node.asMapping().key.value;
	            var property = this.definition().property(name);
	            if (!property)
	                continue;
	            //console.log(property.name() + ': isval: ' + property.isValue() + '; multi: ' + property.isMultiValue() + '; range val: ' + property.range().isValueType());
	            //if((property.isValue() || /*property.isMultiValue()) ||*/ property.range().isValueType()) {
	            if (property.isValue() || property.range().isValueType()) {
	                last = i;
	            }
	        }
	        //console.log('last attr index1: ' + last);
	        return last;
	    };
	    ASTNodeImpl.prototype.findLastAttribute = function () {
	        var childs = this.lowLevel().children();
	        var index = this.findLastAttributeIndex();
	        //console.log('last attr index2: ' + index);
	        return (index < 0) ? null : childs[index];
	    };
	    ASTNodeImpl.prototype.isEmptyRamlFile = function () {
	        var llroot = this.lowLevel().root();
	        return llroot.isScalar();
	    };
	    ASTNodeImpl.prototype.initRamlFile = function () {
	        var llroot = this.lowLevel().root();
	        var command = new ll.CompositeCommand();
	        var newroot = jsyaml.createMap([]);
	        command.commands.push(ll.initRamlFile(this.lowLevel(), newroot));
	        this.lowLevel().execute(command);
	        var root = this.root();
	        //console.log('root: ' + root);
	        root._node = newroot;
	        root.clearChildrenCache();
	        //root.lowLevel().show('NEW ROOT:');
	    };
	    ASTNodeImpl.prototype.createAttr = function (n, v) {
	        var mapping = jsyaml.createMapping(n, v);
	        //console.log('create attribute: ' + n);
	        if (this.isStub()) {
	            //console.log('create-attr: stub case');
	            var insertionIndex = this.findLastAttributeIndex();
	            //console.log('stub insertion index: ' + insertionIndex);
	            this._node.addChild(mapping, insertionIndex + 1);
	        }
	        else {
	            //console.log('root: ' + llroot.kindName());
	            if (this.isEmptyRamlFile()) {
	                this.initRamlFile();
	            }
	            //console.log('create-attr: real node case');
	            //this._node.addChild(mapping);
	            //this.clearChildrenCache();
	            var command = new ll.CompositeCommand();
	            var insertionPoint = this.findInsertionPointLowLevel(mapping, this.definition().property(n), true);
	            //command.commands.push(ll.insertNode(this.lowLevel(), mapping, null));
	            //var toseq = this.property().isMultiValue();
	            command.commands.push(ll.insertNode(this.lowLevel(), mapping, insertionPoint));
	            this.lowLevel().execute(command);
	        }
	        this.clearChildrenCache();
	    };
	    ASTNodeImpl.prototype.isAttr = function () {
	        return false;
	    };
	    ASTNodeImpl.prototype.isUnknown = function () {
	        return false;
	    };
	    ASTNodeImpl.prototype.value = function () {
	        return this._node.value();
	    };
	    ASTNodeImpl.prototype.valuesOf = function (propName) {
	        var pr = this._def.property(propName);
	        if (pr != null) {
	            return this.elements().filter(function (x) { return x.property() == pr; });
	        }
	        return [];
	    };
	    ASTNodeImpl.prototype.attr = function (n) {
	        return _.find(this.attrs(), function (y) { return y.name() == n; });
	    };
	    ASTNodeImpl.prototype.attrOrCreate = function (name) {
	        var a = this.attr(name);
	        if (!a)
	            this.createAttr(name, '');
	        return this.attr(name);
	    };
	    ASTNodeImpl.prototype.attrValue = function (n) {
	        var a = this.attr(n);
	        return a ? a.value() : null;
	    };
	    ASTNodeImpl.prototype.attributes = function (n) {
	        return _.filter(this.attrs(), function (y) { return y.name() == n; });
	    };
	    ASTNodeImpl.prototype.attrs = function () {
	        return this.children().filter(function (x) { return x.isAttr(); });
	    };
	    /*
	    allAttrs():hl.IAttribute[]{
	        var attrs = <hl.IAttribute[]>this.children().filter(x=>x.isAttr());
	        var attributes = [];
	        //console.log('Attributes(' + this.definition().name() + '): ');
	        (<NodeClass>this.definition()).allProperties().forEach(x=>{
	            if(x.range().isValueType()&&!x.isSystem()){
	                var a = _.find(attrs,y=>y.name()==x.name());
	                //var a = this.attr(x.name());
	                if (a){
	                    //console.log('  real   : ' + x.name() + ' = ' + a.value());
	                    attributes.push(a);
	                } else {
	                    a = new VirtualAttribute(this, this.definition(), x, false);
	                    //console.log('  virtual: ' + x.name());
	                    attributes.push(a);
	                }
	            }
	        })
	        return attributes;
	    }
	    */
	    ASTNodeImpl.prototype.elements = function () {
	        return this.children().filter(function (x) { return !x.isAttr() && !x.isUnknown(); });
	    };
	    ASTNodeImpl.prototype.element = function (n) {
	        var r = this.elementsOfKind(n);
	        if (r.length > 0) {
	            return r[0];
	        }
	        return null;
	    };
	    ASTNodeImpl.prototype.elementsOfKind = function (n) {
	        var r = this.elements().filter(function (x) { return x.property().name() == n; });
	        return r;
	    };
	    ASTNodeImpl.prototype.definition = function () {
	        return this._def;
	    };
	    ASTNodeImpl.prototype.property = function () {
	        return this._prop;
	    };
	    ASTNodeImpl.prototype.isExpanded = function () {
	        return this._expanded;
	    };
	    ASTNodeImpl.prototype.copy = function () {
	        return new ASTNodeImpl(this.lowLevel().copy(), this.parent(), this.definition(), this.property());
	    };
	    ASTNodeImpl.prototype.clearChildrenCache = function () {
	        this._children = null;
	    };
	    return ASTNodeImpl;
	})(BasicASTNode);
	exports.ASTNodeImpl = ASTNodeImpl;
	function typeFromNode(node) {
	    return typeBuilder.typeFromNode(node);
	}
	exports.typeFromNode = typeFromNode;
	function createStub0(parent, property, key) {
	    var p = parent.definition().property(property);
	    if (!p)
	        return null;
	    var nc = p.range();
	    var node = nc.createStubNode(p, key);
	    return node;
	}
	exports.createStub0 = createStub0;
	function createStub(parent, property, key) {
	    var p = parent.definition().property(property);
	    if (!p)
	        return null;
	    var nc = p.range();
	    var node = nc.createStubNode(p, key);
	    node.isInEdit = true;
	    var su = parent.lowLevel().unit().stub();
	    node.lowLevel()._unit = su;
	    node._parent = parent.copy();
	    node._parent.lowLevel()._unit = su;
	    return node;
	}
	exports.createStub = createStub;
	function createResourceStub(parent, key) {
	    return createStub(parent, "resources", key);
	}
	exports.createResourceStub = createResourceStub;
	function createMethodStub(parent, key) {
	    return createStub(parent, 'methods', key);
	}
	exports.createMethodStub = createMethodStub;
	function createResponseStub(parent, key) {
	    return createStub(parent, 'responses', key);
	}
	exports.createResponseStub = createResponseStub;
	function createBodyStub(parent, key) {
	    return createStub(parent, 'body', key);
	}
	exports.createBodyStub = createBodyStub;
	function createUriParameterStub(parent, key) {
	    return createStub(parent, 'uriParameters', key);
	}
	exports.createUriParameterStub = createUriParameterStub;
	function createQueryParameterStub(parent, key) {
	    return createStub(parent, 'queryParameters', key);
	}
	exports.createQueryParameterStub = createQueryParameterStub;
	function createObjectFieldStub(parent, name) {
	    var type = parent.definition().universe().getType('ObjectField');
	    //var property = def.prop('types', 'xxx', <def.NodeClass>parent.definition(), type);
	    var property = parent.definition().property('types');
	    property = property.withRange(type);
	    console.log('property: ' + property.name());
	    var nc = property.range();
	    return nc.createStubNode(property, name);
	}
	exports.createObjectFieldStub = createObjectFieldStub;
	var allowOwerride = { resources: 1, queryParameters: 1, headers: 1, body: 1, methods: 1, responses: 1 };
	var buildIns = {
	    string: 1,
	    date: 1,
	    boolean: 1,
	    number: 1,
	    integer: 1,
	    object: 1,
	    array: 1,
	    union: 1,
	    file: 1,
	    value: 1,
	    any: 1,
	    scalar: 1
	};
	//# sourceMappingURL=highLevelImpl.js.map

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/tsd.d.ts" />
	var def = __webpack_require__(21);
	var td = __webpack_require__(22);
	var tsutil = __webpack_require__(23);
	var path = __webpack_require__(11);
	var mkdirp = __webpack_require__(40);
	var fs = __webpack_require__(12);
	var wrappedParserGen = __webpack_require__(24);
	var ParserGenerator = (function () {
	    function ParserGenerator(cfg, universe) {
	        this.cfg = cfg;
	        this.universe = universe;
	        this.mod = new td.TSAPIModule();
	        this.processed = {};
	        this.typeMap = {
	            'StringType': 'string',
	            'NumberType': 'number',
	            'BooleanType': 'boolean'
	        };
	    }
	    ParserGenerator.prototype.processEnum = function (u) {
	        var _this = this;
	        var typeName = u.name();
	        u.superTypes().forEach(function (x) { return _this.processType(x); });
	        var dcl = new td.TSEnumDecl(this.mod, typeName);
	        dcl.enumConstants = u.values;
	        var typePath = path.basename(u['_path']);
	        typePath = typePath.substring(0, typePath.lastIndexOf('.'));
	        dcl.meta['$$pkg'] = typePath;
	        u.subTypes().forEach(function (x) { return _this.processType(x); });
	    };
	    ParserGenerator.prototype.processType = function (u) {
	        var _this = this;
	        var typeName = u.name();
	        if (this.processed[typeName]) {
	            return;
	        }
	        this.processed[typeName] = u;
	        if (u instanceof def.EnumType) {
	            this.processEnum(u);
	            return;
	        }
	        u.superTypes().forEach(function (x) { return _this.processType(x); });
	        var idcl = new td.TSInterface(this.mod, typeName);
	        var dcl = new td.TSClassDecl(this.mod, typeName + "Impl");
	        var typePath = path.basename(u['_path']);
	        typePath = typePath.substring(0, typePath.lastIndexOf('.'));
	        idcl.meta['$$pkg'] = typePath;
	        dcl.meta['$$pkg'] = typePath;
	        dcl.implements.push(new td.TSSimpleTypeReference(td.Universe, idcl.name));
	        if (typeName == 'ValueType') {
	            idcl.meta['$$isValueType'] = true;
	            dcl.meta['$$isValueType'] = true;
	            var iMethod = new td.TSAPIElementDeclaration(idcl, 'value');
	            iMethod.isFunc = true;
	            iMethod.rangeType = new td.TSSimpleTypeReference(method, 'string');
	            var method = new td.TSAPIElementDeclaration(dcl, 'value');
	            method.rangeType = new td.TSSimpleTypeReference(method, 'string');
	            method.isFunc = true;
	            method._body = 'return super.attributeValue();';
	            method.meta['property'] = 'value';
	        }
	        if (typeName == 'Reference') {
	            idcl.meta['$$isValueType'] = true;
	            dcl.meta['$$isValueType'] = true;
	            var iMethod = new td.TSAPIElementDeclaration(idcl, 'value');
	            iMethod.isFunc = true;
	            iMethod.rangeType = new td.TSSimpleTypeReference(method, customTypeSuperclass);
	            var method = new td.TSAPIElementDeclaration(dcl, 'value');
	            method.rangeType = new td.TSSimpleTypeReference(method, customTypeSuperclass);
	            method.isFunc = true;
	            method._body = 'return super.customClassValue();';
	            dcl.meta['$$noSuper'] = true;
	            idcl.meta['$$noSuper'] = true;
	            method.meta['property'] = 'value';
	        }
	        else {
	            var map = {};
	            u.superTypes().filter(function (x) {
	                if (map[x.name()]) {
	                    return false;
	                }
	                map[x.name()] = true;
	                return true;
	            }).forEach(function (x) {
	                idcl.extends.push(new td.TSSimpleTypeReference(td.Universe, x.name()));
	                dcl.extends.push(new td.TSSimpleTypeReference(td.Universe, x.name() + "Impl"));
	            });
	            map = {};
	            u.properties().filter(function (x) {
	                if (map[x.name()]) {
	                    return false;
	                }
	                map[x.name()] = true;
	                return true;
	            }).forEach(function (x) {
	                _this.createMethodDecl(idcl, x);
	                var z = _this.createMethodDecl(dcl, x);
	                z._body = _this.generateBody(x, z);
	            });
	            if (dcl.extends.length == 0 && !u.isValueType()) {
	            }
	        }
	        u.subTypes().forEach(function (x) { return _this.processType(x); });
	        //if(this.cfg.raml08compatible){
	        //    this.handleRaml08Comapatibility(u,idcl,dcl);
	        //}
	    };
	    ParserGenerator.prototype.handleRaml08Comapatibility = function (u, idcl, dcl) {
	        if (u.name() == 'ObjectField') {
	            var deType = this.universe.getType('DataElement');
	            var prop = def.prop('formParameters', 'return form parameters', deType, deType).withMultiValue(true);
	            this.createMethodDecl(idcl, prop);
	            var z = this.createMethodDecl(dcl, prop);
	            z._body = this.generateBody(prop, z, 'properties');
	        }
	    };
	    ParserGenerator.prototype.generateBody = function (x, method, propName) {
	        var isEnum = this.processed[x.range().name()] instanceof def.EnumType;
	        var resolvedType = resolveArray(method.rangeType, !isEnum);
	        if (!propName) {
	            propName = x.name();
	        }
	        if (x.isValueProperty()) {
	            if (x.isMultiValue()) {
	                return "return super.getAttributes(\"" + propName + "\", " + resolvedType + ".class);";
	            }
	            else {
	                return "return super.getAttribute(\"" + propName + "\", " + resolvedType + ".class);";
	            }
	        }
	        else {
	            if (x.isMultiValue()) {
	                return "return super.getElements(\"" + propName + "\", " + resolvedType + ".class);";
	            }
	            else {
	                return "return super.getElement(\"" + propName + "\", " + resolvedType + ".class);";
	            }
	        }
	    };
	    ParserGenerator.prototype.createMethodDecl = function (dcl, x) {
	        var method = new td.TSAPIElementDeclaration(dcl, x.name());
	        method.meta['property'] = x.name();
	        method.isFunc = true;
	        var tname = "string";
	        if (x.isPrimitive()) {
	            tname = this.typeMap[x.range().name()];
	        }
	        else {
	            tname = x.range().name();
	            this.processType(x.range());
	        }
	        var iOpt = this.mod.getInterface(tname);
	        var ref = iOpt.isDefined() ? iOpt.getOrThrow().toReference() : new td.TSSimpleTypeReference(td.Universe, tname);
	        if (x.isMultiValue()) {
	            var aRef = new td.TSArrayReference();
	            aRef.componentType = ref;
	            method.rangeType = aRef;
	        }
	        else {
	            method.rangeType = ref;
	        }
	        return method;
	    };
	    return ParserGenerator;
	})();
	function def2Parser(u, cfg, universe) {
	    var generator = new ParserGenerator(cfg, universe);
	    generator.processType(u);
	    new Serializer(generator.mod, cfg).serializeAll();
	}
	exports.def2Parser = def2Parser;
	var ImplementationGenerator = (function () {
	    function ImplementationGenerator() {
	    }
	    ImplementationGenerator.prototype.generateASTAccessor = function (p) {
	        this.generatedCode.push("var val=this.ast.getValue(" + p.name() + "}");
	        this.generatedCode.push("return new " + p.range().name() + "Impl(val)");
	    };
	    return ImplementationGenerator;
	})();
	var Serializer = (function () {
	    function Serializer(module, cfg) {
	        this.module = module;
	        this.cfg = cfg;
	        this.pkgMap = {};
	    }
	    Serializer.prototype.serializeAll = function () {
	        var _this = this;
	        this.module.children().forEach(function (x) { return _this.pkgMap[x.name] = _this.cfg.rootPackage + ((x instanceof td.TSClassDecl) ? '.impl.' : '.model.') + x.meta['$$pkg']; });
	        this.serializeModelFactory();
	        this.module.children().forEach(function (x) { return _this.serializeElement(x); });
	    };
	    Serializer.prototype.serializeElement = function (model) {
	        if (model instanceof td.TSEnumDecl) {
	            this.serializeEnum(model);
	        }
	        else if (model instanceof td.TSClassDecl) {
	            this.serializeImplementation(model);
	        }
	        else if (model instanceof td.TSInterface) {
	            this.serializeInterface(model);
	        }
	    };
	    Serializer.prototype.serializeEnum = function (model) {
	        var currentPackage = this.pkgMap[model.name];
	        var content = "package " + currentPackage + ";\n\npublic enum " + model.name + " {\n\n" + model.enumConstants.map(function (x) { return '    ' + x; }).join(',\n') + "\n\n}";
	        this.write(content, model.name + '.java', currentPackage);
	    };
	    Serializer.prototype.serializeInterface = function (model) {
	        var _this = this;
	        var currentPackage = this.pkgMap[model.name];
	        var isValueNode = model.meta['$$isValueType'];
	        var extendsString = this.refsArrayToString(model.extends, "extends", isValueNode ? 'extends IJavaAttributeNode' : 'extends IJavaElementNode');
	        var childMethods = model.children().filter(function (x) { return x instanceof td.TSAPIElementDeclaration; });
	        var methods = childMethods.map(function (x) { return _this.interfaceMethodString(x); });
	        var hasArrays = model.children().filter(function (x) { return x.rangeType && x.rangeType.array(); }).length > 0;
	        var imports = hasArrays ? { 'import java.util.List;': true } : {};
	        if (childMethods.length > 0) {
	            imports['import javax.xml.bind.annotation.XmlElement;'] = true;
	        }
	        if (model.extends.length == 0) {
	            imports[("import " + this.cfg.rootPackage + ".core." + (isValueNode ? 'IJavaAttributeNode' : "IJavaElementNode") + ";")] = true;
	        }
	        model.extends.filter(function (x) { return _this.pkgMap[resolveArray(x)] != currentPackage; }).forEach(function (x) { return _this.appendImport(x, imports); });
	        model.children().filter(function (x) { return !_this.hasPrimitiveReturnType(x) && _this.pkgMap[resolveArray(x.rangeType)] != currentPackage; }).forEach(function (x) { return _this.appendImport(x.rangeType, imports); });
	        var content = "package " + currentPackage + ";\n\n" + (Object.keys(imports).length > 0 ? Object.keys(imports).join('\n') + '\n\n\n' : '') + "\npublic interface " + model.name + " " + extendsString + " {\n\n" + methods.join('\n\n\n') + "\n\n}";
	        this.write(content, model.name + '.java', currentPackage);
	    };
	    Serializer.prototype.refsArrayToString = function (arr, keyWord, defVal) {
	        if (defVal === void 0) { defVal = ''; }
	        return (arr && arr.length > 0) ? keyWord + arr.map(function (x) { return x.serializeToString(); }).map(function (x) { return ' ' + x; }).join(',') : defVal;
	    };
	    Serializer.prototype.interfaceMethodString = function (method) {
	        var returnType = getReturnTypeString(method.rangeType);
	        var methodName = escape(method.name);
	        return "    @XmlElement(name=\"" + method.meta['property'] + "\")\n    " + returnType + " " + methodName + "();";
	    };
	    Serializer.prototype.serializeImplementation = function (model) {
	        var _this = this;
	        var currentPackage = this.pkgMap[model.name];
	        var isValueNode = model.meta['$$isValueType'];
	        var extendsString = this.refsArrayToString(model.extends, "extends", isValueNode ? 'extends JavaAttributeNode' : 'extends JavaElementNode');
	        var implementsString = this.refsArrayToString(model.implements, "implements");
	        var methods = model.children().filter(function (x) { return x instanceof td.TSAPIElementDeclaration; }).map(function (x) { return _this.implementationMethodString(x); });
	        var hasArrays = model.children().filter(function (x) { return x.rangeType && x.rangeType.array(); }).length > 0;
	        var imports = hasArrays ? { 'import java.util.List;': true } : {};
	        imports['import javax.xml.bind.annotation.XmlElement;'] = true;
	        imports[("import " + this.cfg.rootPackage + ".core.JavaNodeFactory;")] = true;
	        if (model.extends.length == 0) {
	            imports[("import " + this.cfg.rootPackage + ".core." + (isValueNode ? 'JavaAttributeNode' : "JavaElementNode") + ";")] = true;
	        }
	        else {
	            model.extends.filter(function (x) { return _this.pkgMap[resolveArray(x)] != currentPackage; }).forEach(function (x) { return _this.appendImport(x, imports); });
	        }
	        model.implements.forEach(function (x) { return _this.appendImport(x, imports); });
	        model.children().filter(function (x) { return !_this.hasPrimitiveReturnType(x) && _this.pkgMap[resolveArray(x.rangeType)] != currentPackage; }).forEach(function (x) { return _this.appendImport(x.rangeType, imports, true); });
	        var content = "package " + currentPackage + ";\n\n" + (Object.keys(imports).length > 0 ? Object.keys(imports).join('\n') + '\n\n\n' : '') + "\npublic class " + model.name + " " + extendsString + " " + implementsString + " {\n\n    public " + model.name + "(Object jsNode, JavaNodeFactory factory){\n        super(jsNode,factory);\n    }\n\n    protected " + model.name + "(){\n        super();\n    }\n\n\n" + methods.join('\n\n\n') + "\n}";
	        this.write(content, model.name + '.java', currentPackage);
	    };
	    Serializer.prototype.appendImport = function (x, imports, addImpl) {
	        if (addImpl === void 0) { addImpl = false; }
	        var n = resolveArray(x);
	        imports[this.importString(n)] = true;
	        var isEnum = checkEnum(x);
	        if (!isEnum && addImpl && n != customTypeSuperclass) {
	            imports[this.importString(n + 'Impl', true)] = true;
	        }
	    };
	    Serializer.prototype.importString = function (n, isImpl) {
	        if (isImpl === void 0) { isImpl = false; }
	        var subPackage = (n == customTypeSuperclass) ? 'core' : (isImpl ? 'impl' : 'model');
	        var pkg = this.pkgMap[n] ? this.pkgMap[n] : "" + this.cfg.rootPackage + "." + subPackage;
	        var importStr = "import " + pkg + "." + n + ";";
	        return importStr;
	    };
	    Serializer.prototype.implementationMethodString = function (method) {
	        var returnType = getReturnTypeString(method.rangeType);
	        var methodName = escape(method.name);
	        return "    @XmlElement(name=\"" + method.meta['property'] + "\")\n    public " + returnType + " " + methodName + "(){\n        " + method._body + "\n    }";
	    };
	    Serializer.prototype.write = function (content, name, pkg) {
	        var dstPath = path.resolve(path.resolve(this.cfg.sourceFolderAbsolutePath, this.packagePath(pkg)), name);
	        mkdirp.sync(path.dirname(dstPath));
	        fs.writeFileSync(dstPath, content);
	    };
	    Serializer.prototype.packagePath = function (pkg) {
	        return pkg.replace(/\./g, '/');
	    };
	    Serializer.prototype.hasPrimitiveReturnType = function (method) {
	        var isArray = method.rangeType.array();
	        var rangeType = isArray ? method.rangeType.componentType : method.rangeType;
	        var returnType = rangeType.serializeToString();
	        return tsutil.tsToJavaTypeMap[returnType] != null;
	    };
	    Serializer.prototype.serializeModelFactory = function () {
	        var _this = this;
	        var currentPackage = this.cfg.rootPackage + '.registry';
	        var className = 'ModelRegistry';
	        var content = "package " + currentPackage + ";\n\nimport java.util.HashMap;\n\npublic class " + className + " {\n\n    protected static " + className + " instance;\n\n    public static " + className + " getInstance(){\n        if(instance==null){\n            instance = new " + className + "();\n        }\n        return instance;\n    }\n\n\n    protected " + className + "(){\n        this.init();\n    }\n\n    public String rootPackage(){\n        return \"" + this.cfg.rootPackage + "\";\n    }\n\n    protected HashMap<String,String> packageMap;\n\n    @SuppressWarnings(\"unchecked\")\n\tpublic <S> Class<? extends S> getModelClass(String simpleName, Class<S> clazz){\n        String pkg = this.packageMap.get(simpleName);\n        if(pkg==null){\n            return null;\n        }\n        String qualifiedName = pkg + \".\" + simpleName;\n        try {\n            Class<?> result = this.getClass().getClassLoader().loadClass(qualifiedName);\n            if(result!=null && clazz.isAssignableFrom(result)){\n            \treturn (Class<? extends S>) result;\n            }\n        }\n        catch(Exception e){}\n\n        return null;\n    }\n\n    protected void init(){\n\n        this.packageMap = new HashMap<String,String>();\n\n" + Object.keys(this.pkgMap).map(function (x) { return ("        this.packageMap.put( \"" + x + "\", \"" + _this.pkgMap[x] + "\" );"); }).join('\n\n') + "\n    }\n\n}";
	        this.write(content, className + '.java', currentPackage);
	    };
	    return Serializer;
	})();
	function getReturnTypeString(rangeType) {
	    var returnType = resolveArray(rangeType);
	    return rangeType.array() ? "List<" + returnType + ">" : returnType;
	}
	function resolveArray(rangeType, toImpl) {
	    if (toImpl === void 0) { toImpl = false; }
	    var isArray = rangeType.array();
	    rangeType = isArray ? rangeType.componentType : rangeType;
	    var returnType = rangeType.serializeToString();
	    var converted = tsutil.tsToJavaTypeMap[returnType];
	    if (converted) {
	        return converted;
	    }
	    return toImpl ? returnType + 'Impl' : returnType;
	}
	function checkEnum(rangeType) {
	    var isArray = rangeType.array();
	    rangeType = isArray ? rangeType.componentType : rangeType;
	    var isEnum = rangeType instanceof td.TSDeclaredInterfaceReference && rangeType.getOriginal() instanceof td.TSEnumDecl;
	    return isEnum;
	}
	var UserClass = (function () {
	    function UserClass(simpleName, qualifiedName) {
	        this.simpleName = simpleName;
	        this.qualifiedName = qualifiedName;
	    }
	    return UserClass;
	})();
	exports.UserClass = UserClass;
	var UserClassCollection = (function () {
	    function UserClassCollection() {
	        this.classes = {};
	    }
	    UserClassCollection.prototype.getClasses = function () {
	        var _this = this;
	        return Object.keys(this.classes).map(function (x) { return _this.classes[x]; });
	    };
	    UserClassCollection.prototype.hasClass = function (qName) {
	        return this.classes[qName] != null;
	    };
	    UserClassCollection.prototype.addClass = function (cl) {
	        this.classes[cl.qualifiedName] = cl;
	    };
	    UserClassCollection.prototype.getClass = function (qName) {
	        return this.classes[qName];
	    };
	    return UserClassCollection;
	})();
	exports.UserClassCollection = UserClassCollection;
	var customTypeSuperclass = 'CustomType';
	var UserClassGenerator = (function () {
	    function UserClassGenerator(rootPackage) {
	        this.generatedSubPackage = '.generated.model';
	        this.classCollection = new UserClassCollection();
	        this.rootPackage = rootPackage;
	    }
	    UserClassGenerator.prototype.generateUserClass = function (typeDef) {
	        var _this = this;
	        var className = escape(typeDef.name());
	        var qName = this.rootPackage + this.generatedSubPackage + '.' + className;
	        if (this.classCollection.hasClass(qName)) {
	            return qName;
	        }
	        var uc = new UserClass(className, qName);
	        this.classCollection.addClass(uc);
	        var imports = {
	            'import javax.xml.bind.annotation.XmlElement;': true,
	            'import org.eclipse.persistence.oxm.annotations.XmlDiscriminatorValue;': true
	        };
	        imports[("import " + this.rootPackage + ".core." + customTypeSuperclass + ";")] = true;
	        var fields = [];
	        var hasArray = false;
	        typeDef.properties().forEach(function (p) {
	            var pName = p.name();
	            var fieldName = escape(pName);
	            var range = p.range();
	            var arrDim = 0;
	            while (range instanceof def.Array) {
	                hasArray = true;
	                range = range.component;
	                arrDim++;
	            }
	            var fieldType;
	            if (range.isValueType()) {
	                if (wrappedParserGen.checkIfReference(range)) {
	                    var fTypeQName = _this.generateUserClass(range);
	                    fieldType = _this.classCollection.getClass(fTypeQName).simpleName;
	                    if (fTypeQName != qName) {
	                        imports[("import " + fTypeQName + ";")] = true;
	                    }
	                }
	                else {
	                    var ft = range.name().toLowerCase();
	                    if (ft.indexOf('boolean') >= 0) {
	                        fieldType = 'Boolean';
	                    }
	                    else if (ft.indexOf('number') >= 0) {
	                        fieldType = 'Double';
	                    }
	                    else {
	                        fieldType = 'String';
	                    }
	                }
	            }
	            else {
	                var fTypeQName = _this.generateUserClass(range);
	                fieldType = _this.classCollection.getClass(fTypeQName).simpleName;
	                if (fTypeQName != qName) {
	                    imports[("import " + fTypeQName + ";")] = true;
	                }
	            }
	            while (arrDim > 0) {
	                fieldType = "List<" + fieldType + ">";
	                arrDim--;
	            }
	            fields.push("    @XmlElement(name=\"" + pName + "\")\n    public " + fieldType + " " + fieldName + ";");
	        });
	        if (hasArray) {
	            imports['import java.util.List;'] = true;
	        }
	        uc.content = "package " + (this.rootPackage + this.generatedSubPackage) + ";\n\n" + Object.keys(imports).join('\n') + "\n\n@XmlDiscriminatorValue(\"" + className + "\")\npublic class " + className + " extends " + customTypeSuperclass + "{\n\n" + fields.join('\n\n\n') + "\n\n}\n";
	        return qName;
	    };
	    return UserClassGenerator;
	})();
	function generateClasses(def, rootPackage) {
	    var generator = new UserClassGenerator(rootPackage);
	    generator.generateUserClass(def);
	    return generator.classCollection.getClasses();
	}
	exports.generateClasses = generateClasses;
	function escape(str) {
	    return tsutil.escapeToJavaIdentifier(str);
	}
	exports.escape = escape;
	//# sourceMappingURL=javaParserGen.js.map

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/tsd.d.ts" />
	var yaml = __webpack_require__(19);
	var util = __webpack_require__(20);
	var llImpl = __webpack_require__(6);
	var CompilationUnit = (function () {
	    function CompilationUnit(_absolutePath, _path, _content, _project, _isTopoLevel) {
	        this._absolutePath = _absolutePath;
	        this._path = _path;
	        this._content = _content;
	        this._project = _project;
	        this._isTopoLevel = _isTopoLevel;
	        this._node = new AstNode(this, JSON.parse(this._content));
	    }
	    CompilationUnit.prototype.absolutePath = function () {
	        return this._absolutePath;
	    };
	    CompilationUnit.prototype.clone = function () {
	        return null;
	    };
	    CompilationUnit.prototype.contents = function () {
	        return this._content;
	    };
	    CompilationUnit.prototype.lexerErrors = function () {
	        return [];
	    };
	    CompilationUnit.prototype.path = function () {
	        return this._content;
	    };
	    CompilationUnit.prototype.isTopLevel = function () {
	        return this._isTopoLevel;
	    };
	    CompilationUnit.prototype.ast = function () {
	        return this._node;
	    };
	    CompilationUnit.prototype.isDirty = function () {
	        return true;
	    };
	    CompilationUnit.prototype.isRAMLUnit = function () {
	        return true;
	    };
	    CompilationUnit.prototype.project = function () {
	        return this._project;
	    };
	    CompilationUnit.prototype.updateContent = function (newContent) {
	    };
	    CompilationUnit.prototype.ramlVersion = function () {
	        throw 'not implemented';
	    };
	    CompilationUnit.prototype.resolve = function (p) {
	        return null;
	    }; // TODO FIXME 
	    return CompilationUnit;
	})();
	exports.CompilationUnit = CompilationUnit;
	//export interface IProject{
	//    units():ICompilationUnit[];//returns units with apis in this folder
	//
	//    execute(cmd:CompositeCommand)
	//
	//    executeTextChange(textCommand:TextChangeCommand);//this may result in broken nodes?
	//
	//    addListener(listener:IASTListener);
	//
	//    removeListener(listener:IASTListener)
	//
	//    addTextChangeListener(listener:ITextChangeCommandListener);
	//    removeTextChangeListener(listener:ITextChangeCommandListener);
	//}
	//export interface IASTListener{
	//    (delta:ASTDelta)
	//}
	//
	//export interface ITextChangeCommandListener{
	//    (delta:TextChangeCommand)
	//}
	//export class ASTDelta{
	//    commands:ASTChangeCommand[]
	//}
	//export interface ASTVisitor{
	//    (node:ILowLevelASTNode):boolean
	//}
	var AstNode = (function () {
	    function AstNode(_unit, _object, _parent, _key) {
	        var _this = this;
	        this._unit = _unit;
	        this._object = _object;
	        this._parent = _parent;
	        this._key = _key;
	        if (this._object instanceof Object) {
	            Object.keys(this._object).forEach(function (x) {
	                var u = unescapeKey(x);
	                if (u != x) {
	                    var val = _this._object[x];
	                    delete _this._object[x];
	                    _this._object[u] = val;
	                }
	            });
	        }
	    }
	    AstNode.prototype.start = function () {
	        return -1;
	    };
	    AstNode.prototype.end = function () {
	        return -1;
	    };
	    AstNode.prototype.value = function () {
	        return this._object;
	    };
	    AstNode.prototype.includeErrors = function () {
	        return [];
	    };
	    AstNode.prototype.includePath = function () {
	        return null;
	    };
	    AstNode.prototype.key = function () {
	        return this._key;
	    };
	    AstNode.prototype.children = function () {
	        var _this = this;
	        if (!this._object) {
	            return [];
	        }
	        if (Array.isArray(this._object)) {
	            return this._object.map(function (x) { return new AstNode(_this._unit, x, _this); });
	        }
	        else if (this._object instanceof Object) {
	            return Object.keys(this._object).map(function (x) { return new AstNode(_this._unit, _this._object[x], _this, x); });
	        }
	        else {
	            return [];
	        }
	    };
	    AstNode.prototype.parent = function () {
	        return this._parent;
	    };
	    AstNode.prototype.unit = function () {
	        return this._unit;
	    };
	    AstNode.prototype.anchorId = function () {
	        return null;
	    };
	    AstNode.prototype.errors = function () {
	        return [];
	    };
	    AstNode.prototype.anchoredFrom = function () {
	        return this;
	    };
	    AstNode.prototype.includedFrom = function () {
	        return this;
	    };
	    AstNode.prototype.visit = function (v) {
	        if (v(this)) {
	            this.children().forEach(function (x) { return x.visit(v); });
	        }
	    };
	    AstNode.prototype.dumpToObject = function () {
	        return this._object;
	    };
	    AstNode.prototype.addChild = function (n) {
	    };
	    AstNode.prototype.execute = function (cmd) {
	    };
	    AstNode.prototype.dump = function () {
	        return JSON.stringify(this._object);
	    };
	    AstNode.prototype.keyStart = function () {
	        return -1;
	    };
	    AstNode.prototype.keyEnd = function () {
	        return -1;
	    };
	    AstNode.prototype.valueStart = function () {
	        return -1;
	    };
	    AstNode.prototype.valueEnd = function () {
	        return -1;
	    };
	    AstNode.prototype.isValueLocal = function () {
	        return true;
	    };
	    AstNode.prototype.kind = function () {
	        if (Array.isArray(this._object)) {
	            return 3 /* SEQ */;
	        }
	        else if (this._object instanceof Object) {
	            return 2 /* MAP */;
	        }
	        else {
	            return 0 /* SCALAR */;
	        }
	    };
	    AstNode.prototype.valueKind = function () {
	        return null;
	    };
	    AstNode.prototype.show = function (msg) {
	    };
	    AstNode.prototype.setHighLevelParseResult = function (highLevelParseResult) {
	        this._highLevelParseResult = highLevelParseResult;
	    };
	    AstNode.prototype.highLevelParseResult = function () {
	        return this._highLevelParseResult;
	    };
	    AstNode.prototype.setHighLevelNode = function (highLevel) {
	        this._highLevelNode = highLevel;
	    };
	    AstNode.prototype.highLevelNode = function () {
	        return this._highLevelNode;
	    };
	    AstNode.prototype.text = function (unitText) {
	        throw "not implemented";
	    };
	    AstNode.prototype.copy = function () {
	        throw "not implemented";
	    };
	    AstNode.prototype.markup = function (json) {
	        throw "not implemented";
	    };
	    AstNode.prototype.nodeDefinition = function () {
	        return llImpl.getDefinitionForLowLevelNode(this);
	    };
	    return AstNode;
	})();
	exports.AstNode = AstNode;
	function serialize(node) {
	    if (node.children().length == 0) {
	        if (node.value()) {
	            return node.value();
	        }
	        return '';
	    }
	    if (!node.children()[0].key()) {
	        var arr = [];
	        node.children().forEach(function (x) {
	            arr.push(serialize(x));
	        });
	        return arr;
	    }
	    else {
	        var obj = {};
	        node.children().forEach(function (x) {
	            obj[escapeKey(x.key())] = serialize(x);
	        });
	        return obj;
	    }
	}
	exports.serialize = serialize;
	function escapeKey(key) {
	    if (!key) {
	        return key;
	    }
	    if (key.replace(/\d/g, '').trim().length == 0) {
	        return '__$EscapedKey$__' + key;
	    }
	    return key;
	}
	function unescapeKey(key) {
	    if (!key) {
	        return key;
	    }
	    if (util.stringStartsWith(key, '__$EscapedKey$__')) {
	        return key.substring('__$EscapedKey$__'.length);
	    }
	    return key;
	}
	//# sourceMappingURL=json2lowLevel.js.map

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, __dirname) {var fs = __webpack_require__(12);
	var path = __webpack_require__(11);
	var tsstruct = __webpack_require__(38);
	var ts2def = __webpack_require__(39);
	var universes = {};
	var locations = {
	    "RAML10": "./spec-1.0/api.ts",
	    "RAML08": "./spec-0.8/api.ts",
	    "Swagger2": "./spec-swagger-2.0/swagger.ts"
	};
	var jsonDefinitions = {
	    "RAML10": __webpack_require__(49),
	    "RAML08": __webpack_require__(50),
	    "Swagger2": __webpack_require__(51)
	};
	var getUniverse = (function () {
	    var x = function (key) {
	        if (universes[key]) {
	            return universes[key];
	        }
	        var src = getDecl(key);
	        var universe = ts2def.toDefSystem(src);
	        if (universe) {
	            universe.setUniverseVersion(key);
	            universes[key] = universe;
	        }
	        var mediaTypeParser = __webpack_require__(41);
	        global.mediaTypeParser = mediaTypeParser;
	        return universe;
	    };
	    x.availableUniverses = function () {
	        return Object.keys(locations);
	    };
	    x.clean = function () {
	        Object.keys(jsonDefinitions).forEach(function (x) {
	            jsonDefinitions[x] = null;
	            universes[x] = null;
	            fs.writeFileSync(path.resolve(__dirname, "./artifacts/" + x + ".json"), 'null');
	        });
	    };
	    return x;
	})();
	function getDecl(key) {
	    if (jsonDefinitions[key]) {
	        return toModule(jsonDefinitions[key]);
	    }
	    var tsPath = path.resolve(__dirname, locations[key]);
	    var decls = fs.readFileSync(tsPath).toString();
	    var src = tsstruct.parseStruct(decls, {}, tsPath);
	    var arr = toModulesCollection(src);
	    var jsonPath = path.resolve(path.resolve(path.dirname(tsPath), '../artifacts'), key + '.json');
	    fs.writeFileSync(jsonPath, JSON.stringify(arr, null, 2));
	    src = toModule(arr);
	    return src;
	}
	function toModulesCollection(mod, map, arr) {
	    if (map === void 0) { map = {}; }
	    if (arr === void 0) { arr = []; }
	    var name = mod['name'];
	    if (map[name]) {
	        return;
	    }
	    map[name] = mod;
	    arr.push(mod);
	    var imports = mod['imports'];
	    Object.keys(imports).forEach(function (x) {
	        var submod = imports[x];
	        var n = submod['name'];
	        imports[x] = n;
	        toModulesCollection(submod, map, arr);
	    });
	    return arr;
	}
	function toModule(arr) {
	    var main = arr[0];
	    var map = {};
	    arr.forEach(function (x) { return map[x['name']] = x; });
	    arr.forEach(function (x) {
	        var imports = x['imports'];
	        Object.keys(imports).forEach(function (y) {
	            var name = imports[y];
	            imports[y] = map[name];
	        });
	    });
	    return main;
	}
	module.exports = getUniverse;
	//# sourceMappingURL=universeProvider.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), ".."))

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }

	  return parts;
	}

	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};

	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;

	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();

	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }

	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }

	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)

	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');

	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};

	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';

	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');

	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }

	  return (isAbsolute ? '/' : '') + path;
	};

	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};

	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};


	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);

	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }

	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }

	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }

	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));

	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }

	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }

	  outputParts = outputParts.concat(toParts.slice(samePartsLength));

	  return outputParts.join('/');
	};

	exports.sep = '/';
	exports.delimiter = ':';

	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];

	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }

	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }

	  return root + dir;
	};


	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};


	exports.extname = function(path) {
	  return splitPath(path)[3];
	};

	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}

	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(72)))

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = fs;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = this.__extends || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var yaml = __webpack_require__(19);
	var json = __webpack_require__(9);
	var stringify = __webpack_require__(73);
	var impl = __webpack_require__(6);
	var util = __webpack_require__(20);
	var LowLevelProxyNode = (function () {
	    function LowLevelProxyNode(_parent, _transformer) {
	        this._parent = _parent;
	        this._transformer = _transformer;
	    }
	    LowLevelProxyNode.prototype.transformer = function () {
	        return this._transformer;
	    };
	    LowLevelProxyNode.prototype.original = function () {
	        return this._original;
	    };
	    LowLevelProxyNode.prototype.start = function () {
	        return this._original.start();
	    };
	    LowLevelProxyNode.prototype.end = function () {
	        return this._original.end();
	    };
	    LowLevelProxyNode.prototype.value = function () {
	        throw 'The method must be overridden';
	    };
	    LowLevelProxyNode.prototype.includeErrors = function () {
	        return this._original.includeErrors();
	    };
	    LowLevelProxyNode.prototype.includePath = function () {
	        return this._original.includePath();
	    };
	    LowLevelProxyNode.prototype.setKeyOverride = function (_key) {
	        this._keyOverride = _key;
	    };
	    LowLevelProxyNode.prototype.key = function () {
	        if (this._keyOverride) {
	            return this._keyOverride;
	        }
	        return this._original.key();
	    };
	    LowLevelProxyNode.prototype.children = function () {
	        throw 'The method must be overridden';
	    };
	    LowLevelProxyNode.prototype.parent = function () {
	        return this._parent;
	    };
	    LowLevelProxyNode.prototype.unit = function () {
	        return this._original.unit();
	    };
	    LowLevelProxyNode.prototype.anchorId = function () {
	        return this._original.anchorId();
	    };
	    LowLevelProxyNode.prototype.errors = function () {
	        return this._original.errors();
	    };
	    LowLevelProxyNode.prototype.anchoredFrom = function () {
	        return this._original.anchoredFrom();
	    };
	    LowLevelProxyNode.prototype.includedFrom = function () {
	        return this._original.includedFrom();
	    };
	    LowLevelProxyNode.prototype.visit = function (v) {
	        if (v(this)) {
	            this.children().forEach(function (x) { return x.visit(v); });
	        }
	    };
	    //TODO
	    LowLevelProxyNode.prototype.addChild = function (n) {
	    };
	    //TODO
	    LowLevelProxyNode.prototype.execute = function (cmd) {
	    };
	    //TODO
	    LowLevelProxyNode.prototype.dump = function () {
	        return null;
	    };
	    //TODO
	    LowLevelProxyNode.prototype.dumpToObject = function () {
	        return json.serialize(this);
	    };
	    LowLevelProxyNode.prototype.keyStart = function () {
	        return this._original.keyStart();
	    };
	    LowLevelProxyNode.prototype.keyEnd = function () {
	        return this._original.keyEnd();
	    };
	    LowLevelProxyNode.prototype.valueStart = function () {
	        return this._original.valueStart();
	    };
	    LowLevelProxyNode.prototype.valueEnd = function () {
	        return this._original.valueEnd();
	    };
	    LowLevelProxyNode.prototype.isValueLocal = function () {
	        return this._original.isValueLocal();
	    };
	    LowLevelProxyNode.prototype.kind = function () {
	        return this._original.kind();
	    };
	    LowLevelProxyNode.prototype.valueKind = function () {
	        return this._original.valueKind();
	    };
	    LowLevelProxyNode.prototype.show = function (msg) {
	        this._original.show(msg);
	    };
	    LowLevelProxyNode.prototype.setHighLevelParseResult = function (highLevelParseResult) {
	        this._highLevelParseResult = highLevelParseResult;
	    };
	    LowLevelProxyNode.prototype.highLevelParseResult = function () {
	        return this._highLevelParseResult;
	    };
	    LowLevelProxyNode.prototype.setHighLevelNode = function (highLevel) {
	        this._highLevelNode = highLevel;
	    };
	    LowLevelProxyNode.prototype.highLevelNode = function () {
	        return this._highLevelNode;
	    };
	    LowLevelProxyNode.prototype.text = function (unitText) {
	        throw "not implemented";
	    };
	    LowLevelProxyNode.prototype.copy = function () {
	        throw "not implemented";
	    };
	    LowLevelProxyNode.prototype.markup = function (json) {
	        throw "not implemented";
	    };
	    LowLevelProxyNode.prototype.nodeDefinition = function () {
	        return impl.getDefinitionForLowLevelNode(this);
	    };
	    return LowLevelProxyNode;
	})();
	exports.LowLevelProxyNode = LowLevelProxyNode;
	var LowLevelCompositeNode = (function (_super) {
	    __extends(LowLevelCompositeNode, _super);
	    function LowLevelCompositeNode(node, parent, transformer, fromMainTree) {
	        if (fromMainTree === void 0) { fromMainTree = true; }
	        _super.call(this, parent, transformer);
	        this.fromMainTree = fromMainTree;
	        this._adoptedNodes = [];
	        var originalParent = this.parent() ? this.parent().original() : null;
	        this._original = new LowLevelValueTransformingNode(node, originalParent, transformer);
	        this._adoptedNodes.push(this.original());
	    }
	    LowLevelCompositeNode.prototype.adoptedNodes = function () {
	        return this._adoptedNodes;
	    };
	    LowLevelCompositeNode.prototype.original = function () {
	        return this._original;
	    };
	    LowLevelCompositeNode.prototype.parent = function () {
	        return this._parent;
	    };
	    LowLevelCompositeNode.prototype.adopt = function (node, transformer) {
	        if (!transformer) {
	            transformer = this._transformer;
	        }
	        var originalParent = this.parent() ? this.parent().original() : null;
	        var tNode = new LowLevelValueTransformingNode(node, originalParent, transformer);
	        this._adoptedNodes.push(tNode);
	        if (this._children) {
	            this._children.forEach(function (x) { return x._parent = null; });
	        }
	        this._children = null;
	        if (this.highLevelNode()) {
	            this.highLevelNode().resetChildren();
	        }
	    };
	    LowLevelCompositeNode.prototype.value = function () {
	        var valuableNodes = this._adoptedNodes.filter(function (x) { return x.value(); });
	        if (valuableNodes.length > 0) {
	            return valuableNodes[0].value();
	        }
	        return this._original.value();
	    };
	    LowLevelCompositeNode.prototype.children = function () {
	        var _this = this;
	        if (this._children) {
	            return this._children;
	        }
	        var result = [];
	        var canBeMap = false;
	        var canBeSeq = false;
	        this._adoptedNodes.forEach(function (x) {
	            if (x.children() && x.children().length > 0) {
	                canBeSeq = true;
	                if (x.children()[0].key()) {
	                    canBeMap = true;
	                }
	            }
	        });
	        if (canBeMap) {
	            result = this.collectChildrenWithKeys();
	        }
	        else if (canBeSeq) {
	            result = this.collectChildrenWithKeys();
	            var map = {};
	            this._adoptedNodes.forEach(function (x, i) { return x.children().filter(function (y) { return !y.key(); }).forEach(function (y) {
	                var key = _this.buildKey(y);
	                if (map[key]) {
	                    return;
	                }
	                map[key] = true;
	                var transformer = x.transformer() ? x.transformer() : _this.transformer();
	                var ch = (y instanceof LowLevelValueTransformingNode) ? y.original() : y;
	                result.push(new LowLevelCompositeNode(ch, _this, transformer, i == 0));
	            }); });
	        }
	        else {
	            result = [];
	        }
	        this._children = result;
	        return result;
	    };
	    LowLevelCompositeNode.prototype.buildKey = function (y) {
	        var obj = json.serialize(y);
	        var def = this.nodeDefinition();
	        if (def && (def.name() == 'TraitRef' || def.name() == 'ResourceTypeRef')) {
	            if (typeof obj == 'object') {
	                var keys = Object.keys(obj);
	                if (keys.length > 0) {
	                    obj = keys[0];
	                }
	            }
	        }
	        return stringify(obj);
	    };
	    LowLevelCompositeNode.prototype.collectChildrenWithKeys = function () {
	        var _this = this;
	        var result = [];
	        var m = {};
	        this._adoptedNodes.forEach(function (x, i) {
	            x.original().children().forEach(function (y) {
	                var key = y.key();
	                if (!key) {
	                    return;
	                }
	                if (util.stringEndsWith(key, '?')) {
	                    key = key.substring(0, key.length - 1);
	                }
	                var arr = m[key];
	                if (!arr) {
	                    arr = [];
	                    m[key] = arr;
	                }
	                arr.push({ node: y, transformer: x.transformer(), fromOriginalTree: _this.fromMainTree && i == 0 });
	            });
	        });
	        Object.keys(m).forEach(function (key) {
	            var arr = m[key];
	            var allOptional = true;
	            var hasChildFromOriginalTree = false;
	            arr.forEach(function (x) {
	                allOptional = allOptional && util.stringEndsWith(x.node.key(), '?');
	                hasChildFromOriginalTree = hasChildFromOriginalTree || x.fromOriginalTree;
	            });
	            if (hasChildFromOriginalTree || !allOptional) {
	                var originalTransformer = arr[0].transformer ? arr[0].transformer : _this.transformer();
	                var originalChild = new LowLevelCompositeNode(arr[0].node, _this, originalTransformer, hasChildFromOriginalTree);
	                for (var i = 1; i < arr.length; i++) {
	                    originalChild.adopt(arr[i].node, arr[i].transformer);
	                }
	                result.push(originalChild);
	            }
	        });
	        return result;
	    };
	    LowLevelCompositeNode.prototype.valueKind = function () {
	        if (this._original.kind() != 1 /* MAPPING */) {
	            return null;
	        }
	        for (var i = 0; i < this._adoptedNodes.length; i++) {
	            var node = this._adoptedNodes[i];
	            if (node.value()) {
	                return node.valueKind();
	            }
	        }
	        return null;
	    };
	    LowLevelCompositeNode.prototype.includePath = function () {
	        for (var i = 0; i < this._adoptedNodes.length; i++) {
	            var node = this._adoptedNodes[i];
	            if (node.value()) {
	                return node.includePath();
	            }
	        }
	        return null;
	    };
	    LowLevelCompositeNode.prototype.key = function () {
	        var keys = this._adoptedNodes.map(function (x) { return x.key(); }).filter(function (x) { return x != null && !util.stringEndsWith(x, '?'); });
	        if (keys.length > 0) {
	            return keys[0];
	        }
	        return _super.prototype.key.call(this);
	    };
	    return LowLevelCompositeNode;
	})(LowLevelProxyNode);
	exports.LowLevelCompositeNode = LowLevelCompositeNode;
	var LowLevelValueTransformingNode = (function (_super) {
	    __extends(LowLevelValueTransformingNode, _super);
	    function LowLevelValueTransformingNode(node, parent, transformer) {
	        _super.call(this, parent, transformer);
	        this._original = node;
	    }
	    LowLevelValueTransformingNode.prototype.value = function () {
	        var val = this.original().value();
	        var t = this.transformer();
	        if (t) {
	            val = t.transform(val);
	            if (t.error()) {
	                var msg = t.error();
	                console.log(t.error());
	            }
	        }
	        return val;
	    };
	    LowLevelValueTransformingNode.prototype.children = function () {
	        var _this = this;
	        return this.original().children().map(function (x) { return new LowLevelValueTransformingNode(x, _this, _this._transformer); });
	    };
	    LowLevelValueTransformingNode.prototype.parent = function () {
	        return this._parent;
	    };
	    return LowLevelValueTransformingNode;
	})(LowLevelProxyNode);
	exports.LowLevelValueTransformingNode = LowLevelValueTransformingNode;
	//# sourceMappingURL=LowLevelASTProxy.js.map

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = this.__extends || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var hl = __webpack_require__(17);
	var core = __webpack_require__(18);
	var BasicNodeImpl = (function (_super) {
	    __extends(BasicNodeImpl, _super);
	    function BasicNodeImpl(node) {
	        _super.call(this, node);
	    }
	    BasicNodeImpl.prototype.wrapperClassName = function () {
	        return 'BasicNodeImpl';
	    };
	    BasicNodeImpl.prototype.parent = function () {
	        return _super.prototype.parent.call(this);
	    };
	    return BasicNodeImpl;
	})(core.BasicSuperNodeImpl);
	exports.BasicNodeImpl = BasicNodeImpl;
	var RAMLLanguageElementImpl = (function (_super) {
	    __extends(RAMLLanguageElementImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function RAMLLanguageElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createRAMLLanguageElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    RAMLLanguageElementImpl.prototype.wrapperClassName = function () {
	        return "RAMLLanguageElementImpl";
	    };
	    /**
	     *
	     **/
	    //description
	    RAMLLanguageElementImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    return RAMLLanguageElementImpl;
	})(BasicNodeImpl);
	exports.RAMLLanguageElementImpl = RAMLLanguageElementImpl;
	var ValueTypeImpl = (function () {
	    /**
	     *
	     **/
	    //constructor
	    function ValueTypeImpl(attr) {
	        this.attr = attr;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ValueTypeImpl.prototype.wrapperClassName = function () {
	        return "ValueTypeImpl";
	    };
	    /**
	     *
	     **/
	    //value
	    ValueTypeImpl.prototype.value = function () {
	        return this.attr.value();
	    };
	    /**
	     *
	     **/
	    //highLevel
	    ValueTypeImpl.prototype.highLevel = function () {
	        return this.attr;
	    };
	    return ValueTypeImpl;
	})();
	exports.ValueTypeImpl = ValueTypeImpl;
	var NumberTypeImpl = (function (_super) {
	    __extends(NumberTypeImpl, _super);
	    function NumberTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    NumberTypeImpl.prototype.wrapperClassName = function () {
	        return "NumberTypeImpl";
	    };
	    return NumberTypeImpl;
	})(ValueTypeImpl);
	exports.NumberTypeImpl = NumberTypeImpl;
	var BooleanTypeImpl = (function (_super) {
	    __extends(BooleanTypeImpl, _super);
	    function BooleanTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    BooleanTypeImpl.prototype.wrapperClassName = function () {
	        return "BooleanTypeImpl";
	    };
	    return BooleanTypeImpl;
	})(ValueTypeImpl);
	exports.BooleanTypeImpl = BooleanTypeImpl;
	var ReferenceImpl = (function (_super) {
	    __extends(ReferenceImpl, _super);
	    function ReferenceImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ReferenceImpl.prototype.wrapperClassName = function () {
	        return "ReferenceImpl";
	    };
	    /**
	     *
	     **/
	    //value
	    ReferenceImpl.prototype.value = function () {
	        return core.toStructuredValue(this.attr);
	    };
	    return ReferenceImpl;
	})(ValueTypeImpl);
	exports.ReferenceImpl = ReferenceImpl;
	var ResourceTypeRefImpl = (function (_super) {
	    __extends(ResourceTypeRefImpl, _super);
	    function ResourceTypeRefImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ResourceTypeRefImpl.prototype.wrapperClassName = function () {
	        return "ResourceTypeRefImpl";
	    };
	    return ResourceTypeRefImpl;
	})(ReferenceImpl);
	exports.ResourceTypeRefImpl = ResourceTypeRefImpl;
	var TraitRefImpl = (function (_super) {
	    __extends(TraitRefImpl, _super);
	    function TraitRefImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    TraitRefImpl.prototype.wrapperClassName = function () {
	        return "TraitRefImpl";
	    };
	    return TraitRefImpl;
	})(ReferenceImpl);
	exports.TraitRefImpl = TraitRefImpl;
	var SecuritySchemaRefImpl = (function (_super) {
	    __extends(SecuritySchemaRefImpl, _super);
	    function SecuritySchemaRefImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    SecuritySchemaRefImpl.prototype.wrapperClassName = function () {
	        return "SecuritySchemaRefImpl";
	    };
	    return SecuritySchemaRefImpl;
	})(ReferenceImpl);
	exports.SecuritySchemaRefImpl = SecuritySchemaRefImpl;
	var StringTypeImpl = (function (_super) {
	    __extends(StringTypeImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function StringTypeImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    StringTypeImpl.prototype.wrapperClassName = function () {
	        return "StringTypeImpl";
	    };
	    return StringTypeImpl;
	})(ValueTypeImpl);
	exports.StringTypeImpl = StringTypeImpl;
	var UriTemplateImpl = (function (_super) {
	    __extends(UriTemplateImpl, _super);
	    function UriTemplateImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    UriTemplateImpl.prototype.wrapperClassName = function () {
	        return "UriTemplateImpl";
	    };
	    return UriTemplateImpl;
	})(StringTypeImpl);
	exports.UriTemplateImpl = UriTemplateImpl;
	var RelativeUriImpl = (function (_super) {
	    __extends(RelativeUriImpl, _super);
	    function RelativeUriImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    RelativeUriImpl.prototype.wrapperClassName = function () {
	        return "RelativeUriImpl";
	    };
	    return RelativeUriImpl;
	})(UriTemplateImpl);
	exports.RelativeUriImpl = RelativeUriImpl;
	var FullUriTemplateImpl = (function (_super) {
	    __extends(FullUriTemplateImpl, _super);
	    function FullUriTemplateImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    FullUriTemplateImpl.prototype.wrapperClassName = function () {
	        return "FullUriTemplateImpl";
	    };
	    return FullUriTemplateImpl;
	})(UriTemplateImpl);
	exports.FullUriTemplateImpl = FullUriTemplateImpl;
	var FixedUriImpl = (function (_super) {
	    __extends(FixedUriImpl, _super);
	    function FixedUriImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    FixedUriImpl.prototype.wrapperClassName = function () {
	        return "FixedUriImpl";
	    };
	    return FixedUriImpl;
	})(StringTypeImpl);
	exports.FixedUriImpl = FixedUriImpl;
	var SchemaStringImpl = (function (_super) {
	    __extends(SchemaStringImpl, _super);
	    function SchemaStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    SchemaStringImpl.prototype.wrapperClassName = function () {
	        return "SchemaStringImpl";
	    };
	    return SchemaStringImpl;
	})(StringTypeImpl);
	exports.SchemaStringImpl = SchemaStringImpl;
	var JSonSchemaStringImpl = (function (_super) {
	    __extends(JSonSchemaStringImpl, _super);
	    function JSonSchemaStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    JSonSchemaStringImpl.prototype.wrapperClassName = function () {
	        return "JSonSchemaStringImpl";
	    };
	    return JSonSchemaStringImpl;
	})(SchemaStringImpl);
	exports.JSonSchemaStringImpl = JSonSchemaStringImpl;
	var XMLSchemaStringImpl = (function (_super) {
	    __extends(XMLSchemaStringImpl, _super);
	    function XMLSchemaStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    XMLSchemaStringImpl.prototype.wrapperClassName = function () {
	        return "XMLSchemaStringImpl";
	    };
	    return XMLSchemaStringImpl;
	})(SchemaStringImpl);
	exports.XMLSchemaStringImpl = XMLSchemaStringImpl;
	var ExampleStringImpl = (function (_super) {
	    __extends(ExampleStringImpl, _super);
	    function ExampleStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ExampleStringImpl.prototype.wrapperClassName = function () {
	        return "ExampleStringImpl";
	    };
	    return ExampleStringImpl;
	})(StringTypeImpl);
	exports.ExampleStringImpl = ExampleStringImpl;
	var JSONExampleImpl = (function (_super) {
	    __extends(JSONExampleImpl, _super);
	    function JSONExampleImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    JSONExampleImpl.prototype.wrapperClassName = function () {
	        return "JSONExampleImpl";
	    };
	    return JSONExampleImpl;
	})(ExampleStringImpl);
	exports.JSONExampleImpl = JSONExampleImpl;
	var XMLExampleImpl = (function (_super) {
	    __extends(XMLExampleImpl, _super);
	    function XMLExampleImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    XMLExampleImpl.prototype.wrapperClassName = function () {
	        return "XMLExampleImpl";
	    };
	    return XMLExampleImpl;
	})(ExampleStringImpl);
	exports.XMLExampleImpl = XMLExampleImpl;
	var StatusCodeImpl = (function (_super) {
	    __extends(StatusCodeImpl, _super);
	    function StatusCodeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    StatusCodeImpl.prototype.wrapperClassName = function () {
	        return "StatusCodeImpl";
	    };
	    return StatusCodeImpl;
	})(StringTypeImpl);
	exports.StatusCodeImpl = StatusCodeImpl;
	var MimeTypeImpl = (function (_super) {
	    __extends(MimeTypeImpl, _super);
	    function MimeTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    MimeTypeImpl.prototype.wrapperClassName = function () {
	        return "MimeTypeImpl";
	    };
	    return MimeTypeImpl;
	})(StringTypeImpl);
	exports.MimeTypeImpl = MimeTypeImpl;
	var MarkdownStringImpl = (function (_super) {
	    __extends(MarkdownStringImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function MarkdownStringImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    MarkdownStringImpl.prototype.wrapperClassName = function () {
	        return "MarkdownStringImpl";
	    };
	    return MarkdownStringImpl;
	})(StringTypeImpl);
	exports.MarkdownStringImpl = MarkdownStringImpl;
	var SecuritySchemaImpl = (function (_super) {
	    __extends(SecuritySchemaImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function SecuritySchemaImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchema(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    SecuritySchemaImpl.prototype.wrapperClassName = function () {
	        return "SecuritySchemaImpl";
	    };
	    /**
	     *
	     **/
	    //name
	    SecuritySchemaImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     *
	     **/
	    //setName
	    SecuritySchemaImpl.prototype.setName = function (param) {
	        {
	            this.highLevel().attrOrCreate("name").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //type
	    SecuritySchemaImpl.prototype["type"] = function () {
	        return _super.prototype.attribute.call(this, 'type', this.toString);
	    };
	    /**
	     *
	     **/
	    //setType
	    SecuritySchemaImpl.prototype.setType = function (param) {
	        {
	            this.highLevel().attrOrCreate("type").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //description
	    SecuritySchemaImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //describedBy
	    SecuritySchemaImpl.prototype.describedBy = function () {
	        return _super.prototype.element.call(this, 'describedBy');
	    };
	    /**
	     *
	     **/
	    //settings
	    SecuritySchemaImpl.prototype.settings = function () {
	        return _super.prototype.element.call(this, 'settings');
	    };
	    return SecuritySchemaImpl;
	})(RAMLLanguageElementImpl);
	exports.SecuritySchemaImpl = SecuritySchemaImpl;
	var RAMLSimpleElementImpl = (function (_super) {
	    __extends(RAMLSimpleElementImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function RAMLSimpleElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createRAMLSimpleElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    RAMLSimpleElementImpl.prototype.wrapperClassName = function () {
	        return "RAMLSimpleElementImpl";
	    };
	    return RAMLSimpleElementImpl;
	})(BasicNodeImpl);
	exports.RAMLSimpleElementImpl = RAMLSimpleElementImpl;
	var GlobalSchemaImpl = (function (_super) {
	    __extends(GlobalSchemaImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function GlobalSchemaImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createGlobalSchema(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    GlobalSchemaImpl.prototype.wrapperClassName = function () {
	        return "GlobalSchemaImpl";
	    };
	    /**
	     *
	     **/
	    //key
	    GlobalSchemaImpl.prototype.key = function () {
	        return _super.prototype.attribute.call(this, 'key', this.toString);
	    };
	    /**
	     *
	     **/
	    //setKey
	    GlobalSchemaImpl.prototype.setKey = function (param) {
	        {
	            this.highLevel().attrOrCreate("key").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //value
	    GlobalSchemaImpl.prototype.value = function () {
	        return _super.prototype.attribute.call(this, 'value', function (attr) { return new SchemaStringImpl(attr); });
	    };
	    return GlobalSchemaImpl;
	})(RAMLSimpleElementImpl);
	exports.GlobalSchemaImpl = GlobalSchemaImpl;
	var DocumentationItemImpl = (function (_super) {
	    __extends(DocumentationItemImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function DocumentationItemImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createDocumentationItem(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    DocumentationItemImpl.prototype.wrapperClassName = function () {
	        return "DocumentationItemImpl";
	    };
	    /**
	     *
	     **/
	    //title
	    DocumentationItemImpl.prototype.title = function () {
	        return _super.prototype.attribute.call(this, 'title', this.toString);
	    };
	    /**
	     *
	     **/
	    //setTitle
	    DocumentationItemImpl.prototype.setTitle = function (param) {
	        {
	            this.highLevel().attrOrCreate("title").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //content
	    DocumentationItemImpl.prototype.content = function () {
	        return _super.prototype.attribute.call(this, 'content', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    return DocumentationItemImpl;
	})(RAMLSimpleElementImpl);
	exports.DocumentationItemImpl = DocumentationItemImpl;
	var SecuritySchemaSettingsImpl = (function (_super) {
	    __extends(SecuritySchemaSettingsImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function SecuritySchemaSettingsImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchemaSettings(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    SecuritySchemaSettingsImpl.prototype.wrapperClassName = function () {
	        return "SecuritySchemaSettingsImpl";
	    };
	    return SecuritySchemaSettingsImpl;
	})(RAMLSimpleElementImpl);
	exports.SecuritySchemaSettingsImpl = SecuritySchemaSettingsImpl;
	var OAuth1SecuritySchemeSettingsImpl = (function (_super) {
	    __extends(OAuth1SecuritySchemeSettingsImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function OAuth1SecuritySchemeSettingsImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth1SecuritySchemeSettings(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    OAuth1SecuritySchemeSettingsImpl.prototype.wrapperClassName = function () {
	        return "OAuth1SecuritySchemeSettingsImpl";
	    };
	    /**
	     *
	     **/
	    //requestTokenUri
	    OAuth1SecuritySchemeSettingsImpl.prototype.requestTokenUri = function () {
	        return _super.prototype.attribute.call(this, 'requestTokenUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //authorizationUri
	    OAuth1SecuritySchemeSettingsImpl.prototype.authorizationUri = function () {
	        return _super.prototype.attribute.call(this, 'authorizationUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //tokenCredentialsUri
	    OAuth1SecuritySchemeSettingsImpl.prototype.tokenCredentialsUri = function () {
	        return _super.prototype.attribute.call(this, 'tokenCredentialsUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    return OAuth1SecuritySchemeSettingsImpl;
	})(SecuritySchemaSettingsImpl);
	exports.OAuth1SecuritySchemeSettingsImpl = OAuth1SecuritySchemeSettingsImpl;
	var OAuth2SecuritySchemeSettingsImpl = (function (_super) {
	    __extends(OAuth2SecuritySchemeSettingsImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function OAuth2SecuritySchemeSettingsImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth2SecuritySchemeSettings(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    OAuth2SecuritySchemeSettingsImpl.prototype.wrapperClassName = function () {
	        return "OAuth2SecuritySchemeSettingsImpl";
	    };
	    /**
	     *
	     **/
	    //accessTokenUri
	    OAuth2SecuritySchemeSettingsImpl.prototype.accessTokenUri = function () {
	        return _super.prototype.attribute.call(this, 'accessTokenUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //authorizationUri
	    OAuth2SecuritySchemeSettingsImpl.prototype.authorizationUri = function () {
	        return _super.prototype.attribute.call(this, 'authorizationUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //authorizationGrants
	    OAuth2SecuritySchemeSettingsImpl.prototype.authorizationGrants = function () {
	        return _super.prototype.attributes.call(this, 'authorizationGrants', this.toString);
	    };
	    /**
	     *
	     **/
	    //setAuthorizationGrants
	    OAuth2SecuritySchemeSettingsImpl.prototype.setAuthorizationGrants = function (param) {
	        {
	            this.highLevel().attrOrCreate("authorizationGrants").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //scopes
	    OAuth2SecuritySchemeSettingsImpl.prototype.scopes = function () {
	        return _super.prototype.attributes.call(this, 'scopes', this.toString);
	    };
	    /**
	     *
	     **/
	    //setScopes
	    OAuth2SecuritySchemeSettingsImpl.prototype.setScopes = function (param) {
	        {
	            this.highLevel().attrOrCreate("scopes").setValue("" + param);
	            return this;
	        }
	    };
	    return OAuth2SecuritySchemeSettingsImpl;
	})(SecuritySchemaSettingsImpl);
	exports.OAuth2SecuritySchemeSettingsImpl = OAuth2SecuritySchemeSettingsImpl;
	var SecuritySchemaPartImpl = (function (_super) {
	    __extends(SecuritySchemaPartImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function SecuritySchemaPartImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchemaPart(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    SecuritySchemaPartImpl.prototype.wrapperClassName = function () {
	        return "SecuritySchemaPartImpl";
	    };
	    return SecuritySchemaPartImpl;
	})(RAMLSimpleElementImpl);
	exports.SecuritySchemaPartImpl = SecuritySchemaPartImpl;
	var ResourceTypeImpl = (function (_super) {
	    __extends(ResourceTypeImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function ResourceTypeImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createResourceType(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ResourceTypeImpl.prototype.wrapperClassName = function () {
	        return "ResourceTypeImpl";
	    };
	    /**
	     *
	     **/
	    //name
	    ResourceTypeImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     *
	     **/
	    //setName
	    ResourceTypeImpl.prototype.setName = function (param) {
	        {
	            this.highLevel().attrOrCreate("name").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //usage
	    ResourceTypeImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /**
	     *
	     **/
	    //setUsage
	    ResourceTypeImpl.prototype.setUsage = function (param) {
	        {
	            this.highLevel().attrOrCreate("usage").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //methods
	    ResourceTypeImpl.prototype.methods = function () {
	        return _super.prototype.elements.call(this, 'methods');
	    };
	    /**
	     *
	     **/
	    //is
	    ResourceTypeImpl.prototype.is = function () {
	        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //type
	    ResourceTypeImpl.prototype["type"] = function () {
	        return _super.prototype.attribute.call(this, 'type', function (attr) { return new ResourceTypeRefImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //securedBy
	    ResourceTypeImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //uriParameters
	    ResourceTypeImpl.prototype.uriParameters = function () {
	        return _super.prototype.elements.call(this, 'uriParameters');
	    };
	    return ResourceTypeImpl;
	})(RAMLLanguageElementImpl);
	exports.ResourceTypeImpl = ResourceTypeImpl;
	var HasNormalParametersImpl = (function (_super) {
	    __extends(HasNormalParametersImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function HasNormalParametersImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createHasNormalParameters(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    HasNormalParametersImpl.prototype.wrapperClassName = function () {
	        return "HasNormalParametersImpl";
	    };
	    /**
	     *
	     **/
	    //queryParameters
	    HasNormalParametersImpl.prototype.queryParameters = function () {
	        return _super.prototype.elements.call(this, 'queryParameters');
	    };
	    /**
	     *
	     **/
	    //displayName
	    HasNormalParametersImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     *
	     **/
	    //setDisplayName
	    HasNormalParametersImpl.prototype.setDisplayName = function (param) {
	        {
	            this.highLevel().attrOrCreate("displayName").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //headers
	    HasNormalParametersImpl.prototype.headers = function () {
	        return _super.prototype.elements.call(this, 'headers');
	    };
	    return HasNormalParametersImpl;
	})(RAMLLanguageElementImpl);
	exports.HasNormalParametersImpl = HasNormalParametersImpl;
	var ParameterImpl = (function (_super) {
	    __extends(ParameterImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function ParameterImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createParameter(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ParameterImpl.prototype.wrapperClassName = function () {
	        return "ParameterImpl";
	    };
	    /**
	     *
	     **/
	    //name
	    ParameterImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     *
	     **/
	    //setName
	    ParameterImpl.prototype.setName = function (param) {
	        {
	            this.highLevel().attrOrCreate("name").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //displayName
	    ParameterImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     *
	     **/
	    //setDisplayName
	    ParameterImpl.prototype.setDisplayName = function (param) {
	        {
	            this.highLevel().attrOrCreate("displayName").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //type
	    ParameterImpl.prototype["type"] = function () {
	        return _super.prototype.attribute.call(this, 'type', this.toString);
	    };
	    /**
	     *
	     **/
	    //setType
	    ParameterImpl.prototype.setType = function (param) {
	        {
	            this.highLevel().attrOrCreate("type").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //location
	    ParameterImpl.prototype.location = function () {
	        return _super.prototype.attribute.call(this, 'location', function (attr) { return new ParameterLocationImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //required
	    ParameterImpl.prototype.required = function () {
	        return _super.prototype.attribute.call(this, 'required', this.toBoolean);
	    };
	    /**
	     *
	     **/
	    //setRequired
	    ParameterImpl.prototype.setRequired = function (param) {
	        {
	            this.highLevel().attrOrCreate("required").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //default
	    ParameterImpl.prototype["default"] = function () {
	        return _super.prototype.attribute.call(this, 'default', this.toString);
	    };
	    /**
	     *
	     **/
	    //setDefault
	    ParameterImpl.prototype.setDefault = function (param) {
	        {
	            this.highLevel().attrOrCreate("default").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //example
	    ParameterImpl.prototype.example = function () {
	        return _super.prototype.attribute.call(this, 'example', this.toString);
	    };
	    /**
	     *
	     **/
	    //setExample
	    ParameterImpl.prototype.setExample = function (param) {
	        {
	            this.highLevel().attrOrCreate("example").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //repeat
	    ParameterImpl.prototype.repeat = function () {
	        return _super.prototype.attribute.call(this, 'repeat', this.toBoolean);
	    };
	    /**
	     *
	     **/
	    //setRepeat
	    ParameterImpl.prototype.setRepeat = function (param) {
	        {
	            this.highLevel().attrOrCreate("repeat").setValue("" + param);
	            return this;
	        }
	    };
	    return ParameterImpl;
	})(RAMLLanguageElementImpl);
	exports.ParameterImpl = ParameterImpl;
	var ParameterLocationImpl = (function () {
	    /**
	     *
	     **/
	    //constructor
	    function ParameterLocationImpl(attr) {
	        this.attr = attr;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ParameterLocationImpl.prototype.wrapperClassName = function () {
	        return "ParameterLocationImpl";
	    };
	    return ParameterLocationImpl;
	})();
	exports.ParameterLocationImpl = ParameterLocationImpl;
	var StrElementImpl = (function (_super) {
	    __extends(StrElementImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function StrElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createStrElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    StrElementImpl.prototype.wrapperClassName = function () {
	        return "StrElementImpl";
	    };
	    /**
	     *
	     **/
	    //pattern
	    StrElementImpl.prototype.pattern = function () {
	        return _super.prototype.attribute.call(this, 'pattern', this.toString);
	    };
	    /**
	     *
	     **/
	    //setPattern
	    StrElementImpl.prototype.setPattern = function (param) {
	        {
	            this.highLevel().attrOrCreate("pattern").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //enum
	    StrElementImpl.prototype.enum = function () {
	        return _super.prototype.attributes.call(this, 'enum', this.toString);
	    };
	    /**
	     *
	     **/
	    //setEnum
	    StrElementImpl.prototype.setEnum = function (param) {
	        {
	            this.highLevel().attrOrCreate("enum").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //minLength
	    StrElementImpl.prototype.minLength = function () {
	        return _super.prototype.attribute.call(this, 'minLength', this.toNumber);
	    };
	    /**
	     *
	     **/
	    //setMinLength
	    StrElementImpl.prototype.setMinLength = function (param) {
	        {
	            this.highLevel().attrOrCreate("minLength").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //maxLength
	    StrElementImpl.prototype.maxLength = function () {
	        return _super.prototype.attribute.call(this, 'maxLength', this.toNumber);
	    };
	    /**
	     *
	     **/
	    //setMaxLength
	    StrElementImpl.prototype.setMaxLength = function (param) {
	        {
	            this.highLevel().attrOrCreate("maxLength").setValue("" + param);
	            return this;
	        }
	    };
	    return StrElementImpl;
	})(ParameterImpl);
	exports.StrElementImpl = StrElementImpl;
	var BooleanElementImpl = (function (_super) {
	    __extends(BooleanElementImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function BooleanElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createBooleanElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    BooleanElementImpl.prototype.wrapperClassName = function () {
	        return "BooleanElementImpl";
	    };
	    return BooleanElementImpl;
	})(ParameterImpl);
	exports.BooleanElementImpl = BooleanElementImpl;
	var NumberElementImpl = (function (_super) {
	    __extends(NumberElementImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function NumberElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createNumberElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    NumberElementImpl.prototype.wrapperClassName = function () {
	        return "NumberElementImpl";
	    };
	    /**
	     *
	     **/
	    //minimum
	    NumberElementImpl.prototype.minimum = function () {
	        return _super.prototype.attribute.call(this, 'minimum', this.toNumber);
	    };
	    /**
	     *
	     **/
	    //setMinimum
	    NumberElementImpl.prototype.setMinimum = function (param) {
	        {
	            this.highLevel().attrOrCreate("minimum").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //maximum
	    NumberElementImpl.prototype.maximum = function () {
	        return _super.prototype.attribute.call(this, 'maximum', this.toNumber);
	    };
	    /**
	     *
	     **/
	    //setMaximum
	    NumberElementImpl.prototype.setMaximum = function (param) {
	        {
	            this.highLevel().attrOrCreate("maximum").setValue("" + param);
	            return this;
	        }
	    };
	    return NumberElementImpl;
	})(ParameterImpl);
	exports.NumberElementImpl = NumberElementImpl;
	var IntegerElementImpl = (function (_super) {
	    __extends(IntegerElementImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function IntegerElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createIntegerElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    IntegerElementImpl.prototype.wrapperClassName = function () {
	        return "IntegerElementImpl";
	    };
	    return IntegerElementImpl;
	})(NumberElementImpl);
	exports.IntegerElementImpl = IntegerElementImpl;
	var DateElementImpl = (function (_super) {
	    __extends(DateElementImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function DateElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createDateElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    DateElementImpl.prototype.wrapperClassName = function () {
	        return "DateElementImpl";
	    };
	    return DateElementImpl;
	})(ParameterImpl);
	exports.DateElementImpl = DateElementImpl;
	var FileElementImpl = (function (_super) {
	    __extends(FileElementImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function FileElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createFileElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    FileElementImpl.prototype.wrapperClassName = function () {
	        return "FileElementImpl";
	    };
	    return FileElementImpl;
	})(ParameterImpl);
	exports.FileElementImpl = FileElementImpl;
	var MethodBaseImpl = (function (_super) {
	    __extends(MethodBaseImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function MethodBaseImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createMethodBase(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    MethodBaseImpl.prototype.wrapperClassName = function () {
	        return "MethodBaseImpl";
	    };
	    /**
	     *
	     **/
	    //responses
	    MethodBaseImpl.prototype.responses = function () {
	        return _super.prototype.elements.call(this, 'responses');
	    };
	    /**
	     *
	     **/
	    //body
	    MethodBaseImpl.prototype.body = function () {
	        return _super.prototype.elements.call(this, 'body');
	    };
	    /**
	     *
	     **/
	    //is
	    MethodBaseImpl.prototype.is = function () {
	        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //securedBy
	    MethodBaseImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
	    };
	    return MethodBaseImpl;
	})(HasNormalParametersImpl);
	exports.MethodBaseImpl = MethodBaseImpl;
	var ResponseImpl = (function (_super) {
	    __extends(ResponseImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function ResponseImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createResponse(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ResponseImpl.prototype.wrapperClassName = function () {
	        return "ResponseImpl";
	    };
	    /**
	     *
	     **/
	    //code
	    ResponseImpl.prototype.code = function () {
	        return _super.prototype.attribute.call(this, 'code', function (attr) { return new StatusCodeImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //headers
	    ResponseImpl.prototype.headers = function () {
	        return _super.prototype.elements.call(this, 'headers');
	    };
	    /**
	     *
	     **/
	    //body
	    ResponseImpl.prototype.body = function () {
	        return _super.prototype.elements.call(this, 'body');
	    };
	    return ResponseImpl;
	})(RAMLLanguageElementImpl);
	exports.ResponseImpl = ResponseImpl;
	var BodyLikeImpl = (function (_super) {
	    __extends(BodyLikeImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function BodyLikeImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createBodyLike(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    BodyLikeImpl.prototype.wrapperClassName = function () {
	        return "BodyLikeImpl";
	    };
	    /**
	     *
	     **/
	    //name
	    BodyLikeImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     *
	     **/
	    //setName
	    BodyLikeImpl.prototype.setName = function (param) {
	        {
	            this.highLevel().attrOrCreate("name").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //schema
	    BodyLikeImpl.prototype.schema = function () {
	        return _super.prototype.attribute.call(this, 'schema', function (attr) { return new SchemaStringImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //example
	    BodyLikeImpl.prototype.example = function () {
	        return _super.prototype.attribute.call(this, 'example', function (attr) { return new ExampleStringImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //formParameters
	    BodyLikeImpl.prototype.formParameters = function () {
	        return _super.prototype.elements.call(this, 'formParameters');
	    };
	    return BodyLikeImpl;
	})(RAMLLanguageElementImpl);
	exports.BodyLikeImpl = BodyLikeImpl;
	var XMLBodyImpl = (function (_super) {
	    __extends(XMLBodyImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function XMLBodyImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createXMLBody(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    XMLBodyImpl.prototype.wrapperClassName = function () {
	        return "XMLBodyImpl";
	    };
	    /**
	     *
	     **/
	    //schema
	    XMLBodyImpl.prototype.schema = function () {
	        return _super.prototype.attribute.call(this, 'schema', function (attr) { return new XMLSchemaStringImpl(attr); });
	    };
	    return XMLBodyImpl;
	})(BodyLikeImpl);
	exports.XMLBodyImpl = XMLBodyImpl;
	var JSONBodyImpl = (function (_super) {
	    __extends(JSONBodyImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function JSONBodyImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createJSONBody(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    JSONBodyImpl.prototype.wrapperClassName = function () {
	        return "JSONBodyImpl";
	    };
	    /**
	     *
	     **/
	    //schema
	    JSONBodyImpl.prototype.schema = function () {
	        return _super.prototype.attribute.call(this, 'schema', function (attr) { return new JSonSchemaStringImpl(attr); });
	    };
	    return JSONBodyImpl;
	})(BodyLikeImpl);
	exports.JSONBodyImpl = JSONBodyImpl;
	var TraitImpl = (function (_super) {
	    __extends(TraitImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function TraitImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createTrait(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    TraitImpl.prototype.wrapperClassName = function () {
	        return "TraitImpl";
	    };
	    /**
	     *
	     **/
	    //name
	    TraitImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     *
	     **/
	    //setName
	    TraitImpl.prototype.setName = function (param) {
	        {
	            this.highLevel().attrOrCreate("name").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //usage
	    TraitImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /**
	     *
	     **/
	    //setUsage
	    TraitImpl.prototype.setUsage = function (param) {
	        {
	            this.highLevel().attrOrCreate("usage").setValue("" + param);
	            return this;
	        }
	    };
	    return TraitImpl;
	})(MethodBaseImpl);
	exports.TraitImpl = TraitImpl;
	var MethodImpl = (function (_super) {
	    __extends(MethodImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function MethodImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createMethod(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    MethodImpl.prototype.wrapperClassName = function () {
	        return "MethodImpl";
	    };
	    /**
	     *
	     **/
	    //method
	    MethodImpl.prototype.method = function () {
	        return _super.prototype.attribute.call(this, 'method', this.toString);
	    };
	    /**
	     *
	     **/
	    //setMethod
	    MethodImpl.prototype.setMethod = function (param) {
	        {
	            this.highLevel().attrOrCreate("method").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //protocols
	    MethodImpl.prototype.protocols = function () {
	        return _super.prototype.attributes.call(this, 'protocols', this.toString);
	    };
	    /**
	     *
	     **/
	    //setProtocols
	    MethodImpl.prototype.setProtocols = function (param) {
	        {
	            this.highLevel().attrOrCreate("protocols").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //securedBy
	    MethodImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
	    };
	    return MethodImpl;
	})(MethodBaseImpl);
	exports.MethodImpl = MethodImpl;
	var ResourceImpl = (function (_super) {
	    __extends(ResourceImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function ResourceImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createResource(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ResourceImpl.prototype.wrapperClassName = function () {
	        return "ResourceImpl";
	    };
	    /**
	     *
	     **/
	    //relativeUri
	    ResourceImpl.prototype.relativeUri = function () {
	        return _super.prototype.attribute.call(this, 'relativeUri', function (attr) { return new RelativeUriImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //type
	    ResourceImpl.prototype["type"] = function () {
	        return _super.prototype.attribute.call(this, 'type', function (attr) { return new ResourceTypeRefImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //is
	    ResourceImpl.prototype.is = function () {
	        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //securedBy
	    ResourceImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //uriParameters
	    ResourceImpl.prototype.uriParameters = function () {
	        return _super.prototype.elements.call(this, 'uriParameters');
	    };
	    /**
	     *
	     **/
	    //methods
	    ResourceImpl.prototype.methods = function () {
	        return _super.prototype.elements.call(this, 'methods');
	    };
	    /**
	     *
	     **/
	    //resources
	    ResourceImpl.prototype.resources = function () {
	        return _super.prototype.elements.call(this, 'resources');
	    };
	    /**
	     *
	     **/
	    //displayName
	    ResourceImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     *
	     **/
	    //setDisplayName
	    ResourceImpl.prototype.setDisplayName = function (param) {
	        {
	            this.highLevel().attrOrCreate("displayName").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //baseUriParameters
	    ResourceImpl.prototype.baseUriParameters = function () {
	        return _super.prototype.elements.call(this, 'baseUriParameters');
	    };
	    return ResourceImpl;
	})(RAMLLanguageElementImpl);
	exports.ResourceImpl = ResourceImpl;
	var ApiImpl = (function (_super) {
	    __extends(ApiImpl, _super);
	    /**
	     *
	     **/
	    //constructor
	    function ApiImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createApi(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /**
	     *
	     **/
	    //wrapperClassName
	    ApiImpl.prototype.wrapperClassName = function () {
	        return "ApiImpl";
	    };
	    /**
	     *
	     **/
	    //title
	    ApiImpl.prototype.title = function () {
	        return _super.prototype.attribute.call(this, 'title', this.toString);
	    };
	    /**
	     *
	     **/
	    //setTitle
	    ApiImpl.prototype.setTitle = function (param) {
	        {
	            this.highLevel().attrOrCreate("title").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //version
	    ApiImpl.prototype.version = function () {
	        return _super.prototype.attribute.call(this, 'version', this.toString);
	    };
	    /**
	     *
	     **/
	    //setVersion
	    ApiImpl.prototype.setVersion = function (param) {
	        {
	            this.highLevel().attrOrCreate("version").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //baseUri
	    ApiImpl.prototype.baseUri = function () {
	        return _super.prototype.attribute.call(this, 'baseUri', function (attr) { return new FullUriTemplateImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //baseUriParameters
	    ApiImpl.prototype.baseUriParameters = function () {
	        return _super.prototype.elements.call(this, 'baseUriParameters');
	    };
	    /**
	     *
	     **/
	    //uriParameters
	    ApiImpl.prototype.uriParameters = function () {
	        return _super.prototype.elements.call(this, 'uriParameters');
	    };
	    /**
	     *
	     **/
	    //protocols
	    ApiImpl.prototype.protocols = function () {
	        return _super.prototype.attributes.call(this, 'protocols', this.toString);
	    };
	    /**
	     *
	     **/
	    //setProtocols
	    ApiImpl.prototype.setProtocols = function (param) {
	        {
	            this.highLevel().attrOrCreate("protocols").setValue("" + param);
	            return this;
	        }
	    };
	    /**
	     *
	     **/
	    //mediaType
	    ApiImpl.prototype.mediaType = function () {
	        return _super.prototype.attribute.call(this, 'mediaType', function (attr) { return new MimeTypeImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //schemas
	    ApiImpl.prototype.schemas = function () {
	        return _super.prototype.elements.call(this, 'schemas');
	    };
	    /**
	     *
	     **/
	    //traits
	    ApiImpl.prototype.traits = function () {
	        return _super.prototype.elements.call(this, 'traits');
	    };
	    /**
	     *
	     **/
	    //securedBy
	    ApiImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
	    };
	    /**
	     *
	     **/
	    //securitySchemes
	    ApiImpl.prototype.securitySchemes = function () {
	        return _super.prototype.elements.call(this, 'securitySchemes');
	    };
	    /**
	     *
	     **/
	    //resourceTypes
	    ApiImpl.prototype.resourceTypes = function () {
	        return _super.prototype.elements.call(this, 'resourceTypes');
	    };
	    /**
	     *
	     **/
	    //resources
	    ApiImpl.prototype.resources = function () {
	        return _super.prototype.elements.call(this, 'resources');
	    };
	    /**
	     *
	     **/
	    //documentation
	    ApiImpl.prototype.documentation = function () {
	        return _super.prototype.elements.call(this, 'documentation');
	    };
	    return ApiImpl;
	})(RAMLLanguageElementImpl);
	exports.ApiImpl = ApiImpl;
	function createApi(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Api");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createRAMLLanguageElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("RAMLLanguageElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createSecuritySchema(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("SecuritySchema");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createSecuritySchemaPart(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("SecuritySchemaPart");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createRAMLSimpleElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("RAMLSimpleElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createGlobalSchema(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("GlobalSchema");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createDocumentationItem(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("DocumentationItem");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createSecuritySchemaSettings(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("SecuritySchemaSettings");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createOAuth1SecuritySchemeSettings(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("OAuth1SecuritySchemeSettings");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createOAuth2SecuritySchemeSettings(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("OAuth2SecuritySchemeSettings");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createResourceType(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("ResourceType");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createMethod(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Method");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createMethodBase(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("MethodBase");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createHasNormalParameters(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("HasNormalParameters");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createParameter(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Parameter");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createStrElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("StrElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createBooleanElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("BooleanElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createNumberElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("NumberElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createIntegerElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("IntegerElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createDateElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("DateElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createFileElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("FileElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createResponse(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Response");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createBodyLike(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("BodyLike");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createXMLBody(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("XMLBody");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createJSONBody(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("JSONBody");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createTrait(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Trait");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	function createResource(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Resource");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	//# sourceMappingURL=raml08parser.js.map

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var ramlPathMatch = __webpack_require__(53);
	var hl = __webpack_require__(17);
	var hlimpl = __webpack_require__(7);
	var Opt = __webpack_require__(5);
	var util = __webpack_require__(20);
	var typeexpression = __webpack_require__(34);
	var search = __webpack_require__(35);
	var ll = __webpack_require__(6);
	var path = __webpack_require__(11);
	function resolveType(p) {
	    var tpe = typeexpression.typeFromNode(p.highLevel());
	    return tpe.toRuntime();
	}
	exports.resolveType = resolveType;
	function load(pth) {
	    var m = new ll.Project(path.dirname(pth));
	    var unit = m.unit(path.basename(pth));
	    if (unit) {
	        if (unit.isRAMLUnit()) {
	            return hl.fromUnit(unit).wrapperNode();
	        }
	    }
	    return null;
	}
	exports.load = load;
	function completeRelativeUri(res) {
	    var uri = '';
	    var parent = res;
	    do {
	        res = parent; //(parent instanceof RamlWrapper.ResourceImpl) ? <RamlWrapper.Resource>parent : null;
	        uri = res.relativeUri().value() + uri;
	        parent = res.parent();
	    } while (parent['relativeUri']);
	    return uri;
	}
	exports.completeRelativeUri = completeRelativeUri;
	function absoluteUri(res) {
	    var uri = '';
	    var parent = res;
	    do {
	        res = parent; //(parent instanceof RamlWrapper.ResourceImpl) ? <RamlWrapper.Resource>parent : null;
	        uri = res.relativeUri().value() + uri;
	        parent = res.parent();
	    } while (parent['relativeUri']);
	    uri = uri.replace(/\/\//g, '/');
	    var buri = parent.baseUri();
	    var base = buri ? buri.value() : "";
	    base = base ? base : '';
	    if (util.stringEndsWith(base, '/')) {
	        uri = uri.substring(1);
	    }
	    uri = base + uri;
	    return uri;
	}
	exports.absoluteUri = absoluteUri;
	function qName(c) {
	    return hlimpl.qName(c.highLevel(), c.highLevel().root());
	}
	exports.qName = qName;
	function allTraits(a) {
	    return search.globalDeclarations(a.highLevel()).filter(function (x) { return x.definition().name() == "Trait"; }).map(function (x) { return x.wrapperNode(); });
	}
	exports.allTraits = allTraits;
	function allResourceTypes(a) {
	    return search.globalDeclarations(a.highLevel()).filter(function (x) { return x.definition().name() == "ResourceType"; }).map(function (x) { return x.wrapperNode(); });
	}
	exports.allResourceTypes = allResourceTypes;
	function relativeUriSegments(res) {
	    var result = [];
	    var parent = res;
	    do {
	        res = parent; //(parent instanceof RamlWrapper.ResourceImpl) ? <RamlWrapper.Resource>parent : null;
	        result.push(res.relativeUri().value());
	        parent = res.parent();
	    } while (parent['relativeUri']);
	    return result.reverse();
	}
	exports.relativeUriSegments = relativeUriSegments;
	function parentResource(method) {
	    return method.parent();
	}
	exports.parentResource = parentResource;
	function parent(resource) {
	    var parent = resource.parent();
	    if (isApi(parent)) {
	        return Opt.empty();
	    }
	    return new Opt(parent);
	}
	exports.parent = parent;
	function getChildResource(container, relPath) {
	    if (container == null) {
	        return Opt.empty();
	    }
	    var resources = container.resources();
	    if (!resources) {
	        return Opt.empty();
	    }
	    resources = resources.filter(function (x) { return x.relativeUri().value() == relPath; });
	    if (resources.length == 0) {
	        return Opt.empty();
	    }
	    return new Opt(resources[0]);
	}
	exports.getChildResource = getChildResource;
	function getResource(container, path) {
	    if (!container) {
	        return null;
	    }
	    var opt = Opt.empty();
	    for (var i = 0; i < path.length; i++) {
	        opt = getChildResource(container, path[i]);
	        if (!opt.isDefined()) {
	            return opt;
	        }
	        container = opt.getOrThrow();
	    }
	    return opt;
	}
	exports.getResource = getResource;
	function getChildMethod(resource, method) {
	    if (!resource) {
	        return null;
	    }
	    return resource.methods().filter(function (x) { return x.method() == method; });
	}
	exports.getChildMethod = getChildMethod;
	function getMethod(container, path, method) {
	    var resource = getResource(container, path);
	    return getChildMethod(resource.getOrElse(null), method);
	}
	exports.getMethod = getMethod;
	function isApi(obj) {
	    return (obj['title'] && obj['version'] && obj['baseUri']);
	}
	;
	function ownerApi(method) {
	    var obj = method;
	    while (!isApi(obj)) {
	        obj = obj.parent();
	    }
	    return obj;
	}
	exports.ownerApi = ownerApi;
	function methodId(method) {
	    return completeRelativeUri(parentResource(method)) + ' ' + method.method().toLowerCase();
	}
	exports.methodId = methodId;
	function isOkRange(response) {
	    return parseInt(response.code().value()) < 400;
	}
	exports.isOkRange = isOkRange;
	function allResources(api) {
	    var resources = [];
	    var visitor = function (res) {
	        resources.push(res);
	        res.resources().forEach(function (x) { return visitor(x); });
	    };
	    api.resources().forEach(function (x) { return visitor(x); });
	    return resources;
	}
	exports.allResources = allResources;
	function matchUri(apiRootRelativeUri, resource) {
	    var allParameters = {};
	    var opt = new Opt(resource);
	    while (opt.isDefined()) {
	        var res = opt.getOrThrow();
	        uriParameters(res).forEach(function (x) { return allParameters[x.name()] = new ParamWrapper(x); });
	        opt = parent(res);
	    }
	    var result = ramlPathMatch(completeRelativeUri(resource), allParameters, {})(apiRootRelativeUri);
	    if (result) {
	        return new Opt(Object.keys(result.params).map(function (x) { return new ParamValue(x, result['params'][x]); }));
	    }
	    return Opt.empty();
	}
	exports.matchUri = matchUri;
	var schemaContentChars = ['{', '<'];
	function schema(body, api) {
	    var schemaNode = body.schema();
	    if (!schemaNode) {
	        return Opt.empty();
	    }
	    var schemaString = schemaNode;
	    var isContent = false;
	    schemaContentChars.forEach(function (x) {
	        try {
	            isContent = isContent || schemaString.indexOf(x) >= 0;
	        }
	        catch (e) {
	        }
	    });
	    var schDef;
	    if (isContent) {
	        schDef = new SchemaDef(schemaString);
	    }
	    else {
	        var globalSchemes = api.schemas().filter(function (x) { return x.key() == schemaString; });
	        if (globalSchemes.length > 0) {
	            schDef = new SchemaDef(globalSchemes[0].value().value(), globalSchemes[0].key());
	        }
	        else {
	            return Opt.empty();
	        }
	    }
	    return new Opt(schDef);
	}
	exports.schema = schema;
	function uriParameters(resource) {
	    var uri = resource.relativeUri().value();
	    var params = resource.uriParameters();
	    return extractParams(params, uri, resource);
	}
	exports.uriParameters = uriParameters;
	function baseUriParameters(api) {
	    var uri = api.baseUri() ? api.baseUri().value() : '';
	    var params = api.baseUriParameters();
	    return extractParams(params, uri, api);
	}
	exports.baseUriParameters = baseUriParameters;
	function absoluteUriParameters(res) {
	    var params = [];
	    var parent = res;
	    do {
	        res = parent;
	        var uri = res.relativeUri().value();
	        var uriParams = res.uriParameters();
	        params = extractParams(uriParams, uri, res).concat(params);
	        parent = res.parent();
	    } while (parent['relativeUri']);
	    var api = parent;
	    var baseUri = api.baseUri().value();
	    var baseUriParams = api.baseUriParameters();
	    params = extractParams(baseUriParams, baseUri, api).concat(params);
	    return params;
	}
	exports.absoluteUriParameters = absoluteUriParameters;
	function extractParams(params, uri, resource) {
	    if (!uri) {
	        return [];
	    }
	    var describedParams = {};
	    params.forEach(function (x) { return describedParams[x.name()] = x; });
	    var allParams = [];
	    var prev = 0;
	    for (var i = uri.indexOf('{'); i >= 0; i = uri.indexOf('{', prev)) {
	        prev = uri.indexOf('}', ++i);
	        var paramName = uri.substring(i, prev);
	        if (describedParams[paramName]) {
	            allParams.push(describedParams[paramName]);
	        }
	        else {
	            allParams.push(new HelperUriParam(paramName, resource));
	        }
	    }
	    return allParams;
	}
	;
	var HelperUriParam = (function () {
	    function HelperUriParam(_name, _parent) {
	        this._name = _name;
	        this._parent = _parent;
	    }
	    HelperUriParam.prototype.wrapperClassName = function () {
	        return "HelperUriParam";
	    };
	    HelperUriParam.prototype.name = function () {
	        return this._name;
	    };
	    HelperUriParam.prototype["type"] = function () {
	        return ["string"];
	    };
	    HelperUriParam.prototype.location = function () {
	        return { wrapperClassName: function () { return "HelperModelLocation"; } };
	    };
	    HelperUriParam.prototype.locationKind = function () {
	        return { wrapperClassName: function () { return "HelperLocationKind"; } };
	    };
	    HelperUriParam.prototype["default"] = function () {
	        return null;
	    };
	    HelperUriParam.prototype.xml = function () {
	        return null;
	    };
	    HelperUriParam.prototype.sendDefaultByClient = function () {
	        return false;
	    };
	    HelperUriParam.prototype.example = function () {
	        return '';
	    };
	    HelperUriParam.prototype.schema = function () {
	        return null;
	    };
	    HelperUriParam.prototype.formParameters = function () {
	        return [];
	    };
	    HelperUriParam.prototype.examples = function () {
	        return [];
	    };
	    HelperUriParam.prototype.repeat = function () {
	        return false;
	    };
	    HelperUriParam.prototype.enum = function () {
	        return [];
	    };
	    HelperUriParam.prototype.collectionFormat = function () {
	        return 'multi';
	    };
	    HelperUriParam.prototype.required = function () {
	        return true;
	    };
	    HelperUriParam.prototype.readOnly = function () {
	        return false;
	    };
	    HelperUriParam.prototype.facets = function () {
	        return [];
	    };
	    HelperUriParam.prototype.scope = function () {
	        return [];
	    };
	    //xml(  ):RamlWrapper.XMLInfo{ return null; }
	    HelperUriParam.prototype.validWhen = function () {
	        return null;
	    };
	    HelperUriParam.prototype.requiredWhen = function () {
	        return null;
	    };
	    HelperUriParam.prototype.displayName = function () {
	        return this._name;
	    };
	    HelperUriParam.prototype.description = function () {
	        return null;
	    };
	    HelperUriParam.prototype.annotations = function () {
	        return [];
	    };
	    HelperUriParam.prototype.usage = function () {
	        return null;
	    };
	    HelperUriParam.prototype.parent = function () {
	        return this._parent;
	    };
	    HelperUriParam.prototype.highLevel = function () {
	        return null;
	    };
	    HelperUriParam.prototype.errors = function () {
	        return [];
	    };
	    return HelperUriParam;
	})();
	exports.HelperUriParam = HelperUriParam;
	var SchemaDef = (function () {
	    function SchemaDef(_content, _name) {
	        this._content = _content;
	        this._name = _name;
	    }
	    SchemaDef.prototype.name = function () {
	        return this._name;
	    };
	    SchemaDef.prototype.content = function () {
	        return this._content;
	    };
	    return SchemaDef;
	})();
	exports.SchemaDef = SchemaDef;
	var ParamValue = (function () {
	    function ParamValue(key, value) {
	        this.key = key;
	        this.value = value;
	    }
	    return ParamValue;
	})();
	exports.ParamValue = ParamValue;
	var ParamWrapper = (function () {
	    function ParamWrapper(_param) {
	        this._param = _param;
	        this.description = _param.description() ? _param.description().value() : this.description;
	        this.displayName = _param.displayName();
	        //        this.enum = _param.enum();
	        this.type = _param.type().length > 0 ? _param.type()[0] : "string";
	        this.example = _param.example();
	        this.repeat = _param.repeat();
	        this.required = _param.required();
	        this.default = _param.default();
	    }
	    return ParamWrapper;
	})();
	//# sourceMappingURL=wrapperHelper.js.map

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	var hl = __webpack_require__(17);
	var hlImpl = __webpack_require__(7);
	var typeExpr = __webpack_require__(31);
	var ramlSignatureParser = __webpack_require__(52);
	var wrapper = __webpack_require__(3);
	function validate(s, node, cb) {
	    var result = ramlSignatureParser.parse(s);
	    if (result.args) {
	        result.args.forEach(function (x) {
	            var ind = x.name.indexOf(".");
	            if (ind == -1) {
	                if (x.name != "body") {
	                    cb.accept(hlImpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Only body parameter may be not qualified", node, false));
	                }
	            }
	            else {
	                var qualifier = x.name.substring(0, ind);
	                if (qualifier != "uri" && qualifier != 'header' && qualifier != 'query') {
	                    cb.accept(hlImpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "qualifer should be one of 'query', 'header' or 'uri'", node, false));
	                }
	            }
	            typeExpr.validateNode(x.type, node, cb);
	        });
	    }
	    if (result.returnType) {
	        typeExpr.validateNode(result.returnType, node, cb);
	    }
	}
	exports.validate = validate;
	function convertToTrait(s, defaultCode) {
	    if (defaultCode === void 0) { defaultCode = "200"; }
	    var trait = new wrapper.TraitImpl("tr");
	    s.args.forEach(function (x) {
	        convertArgument(trait, x);
	    });
	    if (s.returnType) {
	        if (s.returnType.type == "responses") {
	            var rsc = s.returnType;
	            rsc.codes.forEach(function (x) {
	                var rs = new wrapper.ResponseImpl(x.code);
	                var da = new wrapper.DataElementImpl("application/json");
	                da.setType(typeExpr.nodeToString(x.expr));
	                rs.add(da);
	                trait.add(rs);
	            });
	        }
	        else {
	            var rs = new wrapper.ResponseImpl(defaultCode);
	            var da = new wrapper.DataElementImpl("application/json");
	            da.setType(typeExpr.nodeToString(s.returnType));
	            rs.add(da);
	            trait.add(rs);
	        }
	    }
	    return trait;
	}
	exports.convertToTrait = convertToTrait;
	function convertArgument(tr, arg) {
	    //hlimpl.createMethodStub()
	    var dot = arg.name.indexOf(".");
	    var type = null;
	    var aName = arg.name;
	    if (dot != -1) {
	        type = arg.name.substr(0, dot);
	        aName = arg.name.substr(dot + 1);
	    }
	    var c = new wrapper.DataElementImpl(aName);
	    if (aName == "body") {
	        c = new wrapper.DataElementImpl("application/json");
	    }
	    c.setType(typeExpr.nodeToString(arg.type));
	    if (type == "query") {
	        tr.addToProp(c, "queryParameters");
	    }
	    else if (type == "header") {
	        tr.addToProp(c, "headers");
	    }
	    else if (type == "uri") {
	        tr.addToProp(c, "uriParameters");
	    }
	    else if (type == "body") {
	        tr.addToProp(c, "body");
	    }
	    else {
	        if (aName == "body") {
	            tr.addToProp(c, "body");
	        }
	    }
	    return c;
	}
	function parse(node) {
	    try {
	        if (typeof node.value() == "string") {
	            var result = ramlSignatureParser.parse(node.value());
	            return result;
	        }
	    }
	    catch (e) {
	        return null;
	    }
	}
	exports.parse = parse;
	//# sourceMappingURL=ramlSignature.js.map

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	var ds = __webpack_require__(21);
	(function (NodeKind) {
	    NodeKind[NodeKind["BASIC"] = 0] = "BASIC";
	    NodeKind[NodeKind["NODE"] = 1] = "NODE";
	    NodeKind[NodeKind["ATTRIBUTE"] = 2] = "ATTRIBUTE";
	})(exports.NodeKind || (exports.NodeKind = {}));
	var NodeKind = exports.NodeKind;
	(function (IssueCode) {
	    IssueCode[IssueCode["UNRESOLVED_REFERENCE"] = 0] = "UNRESOLVED_REFERENCE";
	    IssueCode[IssueCode["YAML_ERROR"] = 1] = "YAML_ERROR";
	    IssueCode[IssueCode["UNKNOWN_NODE"] = 2] = "UNKNOWN_NODE";
	    IssueCode[IssueCode["MISSING_REQUIRED_PROPERTY"] = 3] = "MISSING_REQUIRED_PROPERTY";
	    IssueCode[IssueCode["PROPERTY_EXPECT_TO_HAVE_SINGLE_VALUE"] = 4] = "PROPERTY_EXPECT_TO_HAVE_SINGLE_VALUE";
	    //TODO IMPLEMENT
	    IssueCode[IssueCode["KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT"] = 5] = "KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT";
	    IssueCode[IssueCode["UNABLE_TO_RESOLVE_INCLUDE_FILE"] = 6] = "UNABLE_TO_RESOLVE_INCLUDE_FILE";
	    IssueCode[IssueCode["INVALID_VALUE_SCHEMA"] = 7] = "INVALID_VALUE_SCHEMA";
	    IssueCode[IssueCode["MISSED_CONTEXT_REQUIREMENT"] = 8] = "MISSED_CONTEXT_REQUIREMENT";
	    IssueCode[IssueCode["NODE_HAS_VALUE"] = 9] = "NODE_HAS_VALUE";
	    IssueCode[IssueCode["ONLY_OVERRIDE_ALLOWED"] = 10] = "ONLY_OVERRIDE_ALLOWED";
	})(exports.IssueCode || (exports.IssueCode = {}));
	var IssueCode = exports.IssueCode;
	;
	var Problem = (function () {
	    function Problem() {
	        this.code = 0;
	    }
	    Problem.prototype.isOk = function () {
	        return this.code == 0;
	    };
	    return Problem;
	})();
	exports.Problem = Problem;
	function ast2Object(node) {
	    var result = {};
	    node.attrs().forEach(function (x) {
	        result[x.property().name()] = x.value();
	    });
	    node.elements().forEach(function (x) {
	        var m = result[x.property().name()];
	        if (Array.isArray(m)) {
	            m.push(ast2Object(x));
	        }
	        result[x.property().name()] = x.property().isMultiValue() ? [ast2Object(x)] : ast2Object(x);
	    });
	    return result;
	}
	exports.ast2Object = ast2Object;
	exports.universeProvider = __webpack_require__(10);
	var hlImpl = __webpack_require__(7);
	exports.getDefinitionSystemType = function (contents, ast) {
	    var spec = "";
	    var ptype = "Api";
	    var num = 0;
	    var pt = 0;
	    for (var n = 0; n < contents.length; n++) {
	        var c = contents.charAt(n);
	        if (c == '\r' || c == '\n') {
	            if (spec) {
	                ptype = contents.substring(pt, n).trim();
	            }
	            else {
	                spec = contents.substring(0, n).trim();
	            }
	            break;
	        }
	        if (c == ' ') {
	            num++;
	            if (!spec && num == 2) {
	                spec = contents.substring(0, n);
	                pt = n;
	            }
	        }
	    }
	    var localUniverse = spec == "#%RAML 1.0" ? new ds.Universe("RAML10", exports.universeProvider("RAML10"), "RAML10") : new ds.Universe("RAML08", exports.universeProvider("RAML08"));
	    if (ast) {
	        if (ast.children().filter(function (x) { return x.key() == "swagger"; }).length > 0) {
	            localUniverse = new ds.Universe("Swagger", exports.universeProvider("Swagger2"), "Swagger");
	            ptype = "SwaggerObject";
	        }
	    }
	    if (ptype == 'API') {
	        ptype = "Api";
	    }
	    if (ptype == 'NamedExample') {
	        ptype = "ExampleSpec";
	    }
	    if (ptype == 'DataType') {
	        ptype = "DataElement";
	    }
	    if (ptype == 'SecurityScheme') {
	        ptype = "SecuritySchema";
	    }
	    localUniverse.setTopLevel(ptype);
	    localUniverse.setTypedVersion(spec);
	    // localUniverse.setDescription(spec);
	    return { ptype: ptype, localUniverse: localUniverse };
	};
	function fromUnit(l) {
	    if (l == null)
	        return null;
	    var contents = l.contents();
	    var ast = l.ast();
	    var __ret = exports.getDefinitionSystemType(contents, ast);
	    var ptype = __ret.ptype;
	    var localUniverse = __ret.localUniverse;
	    var apiType = localUniverse.type(ptype);
	    if (!apiType)
	        apiType = localUniverse.type("Api");
	    var api = new hlImpl.ASTNodeImpl(ast, null, apiType, null);
	    api.setUniverse(localUniverse);
	    return api;
	}
	exports.fromUnit = fromUnit;
	function globalId(h) {
	    if (h.parent()) {
	        return globalId(h.parent()) + "/" + h.localId();
	    }
	}
	exports.globalId = globalId;
	function nodeAtPosition(h, position) {
	    var ch = h.children();
	    var len = ch.length;
	    var res = null;
	    for (var num = 0; num < len; num++) {
	        var cn = ch[num];
	        if (cn.lowLevel().start() > position) {
	            break;
	        }
	        if (cn.lowLevel().end() < position) {
	            continue;
	        }
	        var nm = nodeAtPosition(cn, position);
	        if (nm != null) {
	            return nm;
	        }
	        return cn;
	    }
	}
	exports.nodeAtPosition = nodeAtPosition;
	/**
	 * Shortcut for checking node type
	 * @param node
	 */
	function kindBasic(node) {
	    return node.getKind() == 0 /* BASIC */;
	}
	exports.kindBasic = kindBasic;
	/**
	 * Shortcut for checking node type
	 * @param node
	 */
	function kindAttribute(node) {
	    return node.getKind() == 2 /* ATTRIBUTE */;
	}
	exports.kindAttribute = kindAttribute;
	/**
	 * Shortcut for checking node type
	 * @param node
	 */
	function kindNode(node) {
	    return node.getKind() == 1 /* NODE */;
	}
	exports.kindNode = kindNode;
	function isResourceNode(node) {
	    return kindNode(node) && node.definition && node.definition().name() == "Resource";
	}
	exports.isResourceNode = isResourceNode;
	function isResourceWithSignature(node) {
	    if (!isResourceNode(node)) {
	        return false;
	    }
	    var hNode = node;
	    var uriAttribute = hNode.attr("relativeUri");
	    if (uriAttribute && uriAttribute.value() && typeof uriAttribute.value() == "string" && uriAttribute.value().indexOf(".") >= 0) {
	        var signature = hNode.attrValue("signature");
	        if (!signature)
	            return false;
	        if (typeof signature == "string" && signature.length == 0)
	            return false;
	        return true;
	    }
	    return false;
	}
	exports.isResourceWithSignature = isResourceWithSignature;
	function isRAML10(node) {
	    var text = node.lowLevel().unit().contents();
	    return text.indexOf("#%RAML 1.0") >= 0;
	}
	exports.isRAML10 = isRAML10;
	function isRAML08(node) {
	    var text = node.lowLevel().unit().contents();
	    return text.indexOf("#%RAML 0.8") >= 0;
	}
	exports.isRAML08 = isRAML08;
	/**
	 * Shortcut for checking node type and getting it as attribute
	 * Returns null for non-attributes
	 * @param node
	 */
	function asAttribute(node) {
	    if (!node.getKind) {
	        return null;
	    }
	    if (node.getKind() != 2 /* ATTRIBUTE */) {
	        return null;
	    }
	    return node;
	}
	exports.asAttribute = asAttribute;
	/**
	 * Shortcut for checking node type
	 * @param node
	 */
	function asNode(node) {
	    if (!node.getKind) {
	        return null;
	    }
	    if (node.getKind() != 1 /* NODE */) {
	        return null;
	    }
	    return node;
	}
	exports.asNode = asNode;
	/**
	 * Checks if specified node is library
	 * @param node
	 * @returns {IHighLevelNode|boolean}
	 */
	function isLibrary(node) {
	    return asNode(node) && asNode(node).definition().name() == "Library";
	}
	exports.isLibrary = isLibrary;
	/**
	 * Check is specified node is library and returns library name. Returns null otherwise.
	 * @param node
	 * @returns {any}
	 */
	function getLibraryName(node) {
	    if (!isLibrary(node)) {
	        return null;
	    }
	    return asNode(node).attrValue("name");
	}
	exports.getLibraryName = getLibraryName;
	//# sourceMappingURL=highLevelAST.js.map

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var hlImpl = __webpack_require__(7);
	var jsyaml = __webpack_require__(6);
	var BasicSuperNodeImpl = (function () {
	    function BasicSuperNodeImpl(_node) {
	        this._node = _node;
	        _node.setWrapperNode(this);
	    }
	    BasicSuperNodeImpl.prototype.wrapperClassName = function () {
	        return 'BasicSuperNodeImpl';
	    };
	    BasicSuperNodeImpl.prototype.parent = function () {
	        var parent = this._node.parent();
	        return parent ? parent.wrapperNode() : null;
	    };
	    BasicSuperNodeImpl.prototype.highLevel = function () {
	        return this._node;
	    };
	    BasicSuperNodeImpl.prototype.attributes = function (name, constr) {
	        var attrs = this._node.attributes(name);
	        if (!attrs) {
	            return null;
	        }
	        if (constr) {
	            return attrs.map(function (x) { return constr(x); });
	        }
	        else {
	            return attrs.map(function (x) { return x.value(); });
	        }
	    };
	    BasicSuperNodeImpl.prototype.attribute = function (name, constr) {
	        var attr = this._node.attr(name);
	        if (!attr) {
	            return null;
	        }
	        if (constr) {
	            return constr(attr);
	        }
	        else {
	            return attr.value();
	        }
	    };
	    BasicSuperNodeImpl.prototype.elements = function (name) {
	        var elements = this._node.elementsOfKind(name);
	        if (!elements) {
	            return null;
	        }
	        return elements.map(function (x) { return x.wrapperNode(); });
	    };
	    BasicSuperNodeImpl.prototype.element = function (name) {
	        var element = this._node.element(name);
	        if (!element) {
	            return null;
	        }
	        return element.wrapperNode();
	    };
	    BasicSuperNodeImpl.prototype.add = function (node) {
	        this.highLevel().add(node.highLevel());
	    };
	    BasicSuperNodeImpl.prototype.addToProp = function (node, prop) {
	        var hl = node.highLevel();
	        var pr = this.highLevel().definition().property(prop);
	        hl._prop = pr;
	        this.highLevel().add(hl);
	    };
	    BasicSuperNodeImpl.prototype.remove = function (node) {
	        this.highLevel().remove(node.highLevel());
	    };
	    BasicSuperNodeImpl.prototype.dump = function () {
	        return this.highLevel().dump("yaml");
	    };
	    BasicSuperNodeImpl.prototype.toString = function (attr) {
	        var obj = attr.value();
	        return obj != null ? obj.toString() : obj;
	    };
	    BasicSuperNodeImpl.prototype.toBoolean = function (attr) {
	        var obj = attr.value();
	        return obj != null ? obj.toString() == 'true' : obj;
	    };
	    BasicSuperNodeImpl.prototype.toNumber = function (attr) {
	        var obj = attr.value();
	        if (!obj) {
	            return obj;
	        }
	        try {
	            var nValue = parseFloat(obj.toString());
	            return nValue;
	        }
	        catch (e) {
	        }
	        return Number.MAX_VALUE;
	    };
	    BasicSuperNodeImpl.prototype.errors = function () {
	        var result = [].concat(this._node.errors());
	        this._node.attrs().forEach(function (x) { return result = result.concat(x.errors()); });
	        return result;
	    };
	    return BasicSuperNodeImpl;
	})();
	exports.BasicSuperNodeImpl = BasicSuperNodeImpl;
	function toStructuredValue(node) {
	    var value = node.value();
	    if (typeof value === 'string') {
	        var mockNode = jsyaml.createNode(value.toString());
	        mockNode._actualNode().startPosition = node.lowLevel().valueStart();
	        mockNode._actualNode().endPosition = node.lowLevel().valueEnd();
	        var stv = new hlImpl.StructuredValue(mockNode, node.parent(), node.property());
	        return stv;
	    }
	    else {
	        return value;
	    }
	}
	exports.toStructuredValue = toStructuredValue;
	//# sourceMappingURL=parserCore.js.map

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/tsd.d.ts" />
	(function (Kind) {
	    Kind[Kind["SCALAR"] = 0] = "SCALAR";
	    Kind[Kind["MAPPING"] = 1] = "MAPPING";
	    Kind[Kind["MAP"] = 2] = "MAP";
	    Kind[Kind["SEQ"] = 3] = "SEQ";
	    Kind[Kind["ANCHOR_REF"] = 4] = "ANCHOR_REF";
	    Kind[Kind["INCLUDE_REF"] = 5] = "INCLUDE_REF";
	})(exports.Kind || (exports.Kind = {}));
	var Kind = exports.Kind;
	function newMapping(key, value) {
	    var end = (value ? value.endPosition : key.endPosition + 1); //FIXME.workaround, end should be defied by position of ':'
	    //console.log('key: ' + key.value + ' ' + key.startPosition + '..' + key.endPosition + ' ' + value + ' end: ' + end);
	    var node = {
	        key: key,
	        value: value,
	        startPosition: key.startPosition,
	        endPosition: end,
	        kind: 1 /* MAPPING */,
	        parent: null,
	        errors: []
	    };
	    return node;
	}
	exports.newMapping = newMapping;
	function newAnchorRef(key, start, end, value) {
	    return {
	        errors: [],
	        referencesAnchor: key,
	        value: value,
	        startPosition: start,
	        endPosition: end,
	        kind: 4 /* ANCHOR_REF */,
	        parent: null
	    };
	}
	exports.newAnchorRef = newAnchorRef;
	function newScalar(v) {
	    if (v === void 0) { v = ""; }
	    return {
	        errors: [],
	        startPosition: -1,
	        endPosition: -1,
	        value: v,
	        kind: 0 /* SCALAR */,
	        parent: null,
	        doubleQuoted: false
	    };
	}
	exports.newScalar = newScalar;
	function newItems() {
	    return {
	        errors: [],
	        startPosition: -1,
	        endPosition: -1,
	        items: [],
	        kind: 3 /* SEQ */,
	        parent: null
	    };
	}
	exports.newItems = newItems;
	function newSeq() {
	    return newItems();
	}
	exports.newSeq = newSeq;
	function newMap(mappings) {
	    return {
	        errors: [],
	        startPosition: -1,
	        endPosition: -1,
	        mappings: mappings ? mappings : [],
	        kind: 2 /* MAP */,
	        parent: null
	    };
	}
	exports.newMap = newMap;
	//# sourceMappingURL=yamlAST.js.map

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	var _ = __webpack_require__(47);
	var Opt = __webpack_require__(5);
	exports.defined = function (x) { return (x !== null) && (x !== undefined); };
	/**
	 * Arrays of Objects are common in RAML08.
	 * @param x
	 * @returns {{}}
	 */
	function flattenArrayOfObjects(x) {
	    var res = {};
	    x.forEach(function (v) { return Object.keys(v).forEach(function (k) { return res[k] = v[k]; }); });
	    return res;
	}
	exports.flattenArrayOfObjects = flattenArrayOfObjects;
	function find(xs, f) {
	    return new Opt(_.find(xs || [], f));
	}
	exports.find = find;
	exports.isInstance = function (v, C) { return (v instanceof C) ? [v] : []; };
	exports.ifInstanceOf = function (v, C, f) { return (v instanceof C) ? f(v) : null; };
	function toTuples(map) {
	    return Object.keys(map).map(function (k) { return [k, map[k]]; });
	}
	exports.toTuples = toTuples;
	function fromTuples(tuples) {
	    var obj = {};
	    tuples.forEach(function (x) { return obj[x[0]] = x[1]; });
	    return obj;
	}
	exports.fromTuples = fromTuples;
	exports.collectInstancesOf = function (xs, C) { return tap([], function (res) { return xs.forEach(function (v) { return exports.ifInstanceOf(v, C, function (x) { return res.push(x); }); }); }); };
	exports.collectInstancesOfInMap = function (map, C) {
	    return Object.keys(map).map(function (k) { return [k, map[k]]; }).filter(function (x) { return x[1] instanceof C; }).map(function (x) { return x; });
	};
	exports.asArray = function (v) { return exports.defined(v) ? ((v instanceof Array) ? v : [v]) : []; };
	exports.shallowCopy = function (obj) { return tap({}, function (copy) { return Object.keys(obj).forEach(function (k) { return copy[k] = obj[k]; }); }); };
	exports.flatMap = function (xs, f) { return exports.flatten(xs.map(f)); };
	exports.flatten = function (xss) { return Array.prototype.concat.apply([], xss); };
	exports.takeWhile = function (xs, f) { return tap([], function (res) {
	    for (var i = 0; i < xs.length; i++) {
	        if (!f(xs[i]))
	            break;
	        res.push(xs[i]);
	    }
	}); };
	function tap(v, f) {
	    f(v);
	    return v;
	}
	exports.tap = tap;
	function kv(obj, iter) {
	    if (typeof obj === 'object')
	        Object.keys(obj).forEach(function (k) { return iter(k, obj[k]); });
	}
	exports.kv = kv;
	function indexed(objects, key, delKey) {
	    if (delKey === void 0) { delKey = false; }
	    var obj = {};
	    objects.forEach(function (original) {
	        var copy = exports.shallowCopy(original);
	        if (delKey)
	            delete copy[key];
	        obj[original[key]] = copy;
	    });
	    return obj;
	}
	exports.indexed = indexed;
	function stringEndsWith(str, search) {
	    var dif = str.length - search.length;
	    return dif >= 0 && str.lastIndexOf(search) === dif;
	}
	exports.stringEndsWith = stringEndsWith;
	function stringStartsWith(str, search) {
	    return str.length - search.length >= 0 && str.substring(0, search.length) === search;
	}
	exports.stringStartsWith = stringStartsWith;
	function lazypropkeyfilter(k) {
	    return k[k.length - 1] == "_"; // ends with underscore
	}
	exports.lazypropkeyfilter = lazypropkeyfilter;
	function lazyprop(obj, key, func) {
	    var result, ready = false;
	    obj[key] = function () {
	        if (!ready) {
	            ready = true;
	            result = func.apply(obj);
	        }
	        return result;
	    };
	}
	function lazyprops(obj, keyfilter) {
	    if (keyfilter === void 0) { keyfilter = lazypropkeyfilter; }
	    for (var k in obj) {
	        if (keyfilter(k)) {
	            exports.ifInstanceOf(obj[k], Function, function (vf) { return (vf.length === 0) ? lazyprop(obj, k, vf) : null; });
	        }
	    }
	}
	exports.lazyprops = lazyprops;
	function iff(v, f) {
	    if (v !== undefined)
	        f(v);
	}
	exports.iff = iff;
	function isRAMLUrl(str) {
	    if (typeof str !== 'string' || str == '')
	        return false;
	    return stringEndsWith(str, ".raml");
	}
	exports.isRAMLUrl = isRAMLUrl;
	function getAllRequiredExternalModulesFromCode(code) {
	    var match;
	    var mods = [];
	    // both quoting styles
	    var r1 = new RegExp("require\\('([^']+)'\\)", "gi");
	    while (match = r1.exec(code)) {
	        mods.push(match[1]);
	    }
	    var r2 = new RegExp('require\\("([^"]+)"\\)', "gi");
	    while (match = r2.exec(code)) {
	        mods.push(match[1]);
	    }
	    mods = _.unique(mods).filter(function (x) { return x != ""; });
	    mods.sort();
	    return mods;
	}
	exports.getAllRequiredExternalModulesFromCode = getAllRequiredExternalModulesFromCode;
	exports.serial = (function () {
	    var i = 0;
	    return function () { return i++; };
	})();
	function isEssential(arg) {
	    return typeof arg !== 'undefined' && arg != null;
	}
	exports.isEssential = isEssential;
	function firstToUpper(q) {
	    if (q.length == 0) {
	        return q;
	    }
	    return q.charAt(0).toUpperCase() + q.substr(1);
	}
	exports.firstToUpper = firstToUpper;
	function updateObject(source, target, addNewFields) {
	    if (addNewFields === void 0) { addNewFields = false; }
	    var keySet = Object.keys(target);
	    if (addNewFields) {
	        var map = {};
	        keySet.forEach(function (x) { return map[x] = true; });
	        Object.keys(source).forEach(function (x) { return map[x] = true; });
	        keySet = Object.keys(map);
	    }
	    keySet.forEach(function (x) {
	        var value = source[x];
	        if (value instanceof Object) {
	            if (!target[x]) {
	                target[x] = {};
	            }
	            updateObject(value, target[x], true);
	        }
	        else if (value != undefined) {
	            target[x] = source[x];
	        }
	    });
	}
	exports.updateObject = updateObject;
	;
	/**
	 * In 'str' replace all occurences of 'map' keys to their values.
	 */
	function replaceMap(str, map) {
	    Object.keys(map).forEach(function (x) { return str = replace(str, x, map[x]); });
	    return str;
	}
	exports.replaceMap = replaceMap;
	/**
	 * Replace all occurences of 'x' in 'str' to 'r' without thinking if 'x' can be passed without
	 * escaping as argument to RegExp constructor
	 */
	function replace(str, x, r) {
	    var result = '';
	    var prev = 0;
	    for (var i = str.indexOf(x); i < str.length && i >= 0; i = str.indexOf(x, prev)) {
	        result += str.substring(prev, i);
	        result += r;
	        prev = i + x.length;
	    }
	    result += str.substring(prev, str.length);
	    return result;
	}
	exports.replace = replace;
	//# sourceMappingURL=index.js.map

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = this.__extends || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var _ = __webpack_require__(47);
	var hlimpl = __webpack_require__(7);
	var jsyaml = __webpack_require__(6);
	var su = __webpack_require__(54);
	var selector = __webpack_require__(55);
	var typeBuilder = __webpack_require__(34);
	var ramlexp = __webpack_require__(56);
	var defs = __webpack_require__(21);
	var search = __webpack_require__(35);
	var Annotation = (function () {
	    function Annotation(_name) {
	        this._name = _name;
	    }
	    Annotation.prototype.name = function () {
	        return this._name;
	    };
	    return Annotation;
	})();
	exports.Annotation = Annotation;
	var Described = (function () {
	    function Described(_name, _description) {
	        if (_description === void 0) { _description = ""; }
	        this._name = _name;
	        this._description = _description;
	        this._issues = [];
	        this._toClarify = [];
	        this._itCovers = [];
	        this._tags = [];
	    }
	    Described.prototype.name = function () {
	        return this._name;
	    };
	    Described.prototype.description = function () {
	        return this._description;
	    };
	    Described.prototype.withIssue = function (description) {
	        this._issues.push(description);
	        return this;
	    };
	    Described.prototype.withTag = function (description) {
	        this._tags.push(description);
	        return this;
	    };
	    Described.prototype.withClarify = function (description) {
	        this._toClarify.push(description);
	        return this;
	    };
	    Described.prototype.getCoveredStuff = function () {
	        return this._itCovers;
	    };
	    Described.prototype.withThisFeatureCovers = function (description) {
	        this._itCovers.push(description);
	        return this;
	    };
	    Described.prototype.withVersion = function (verstion) {
	        this._version = verstion;
	    };
	    Described.prototype.version = function () {
	        return this._version;
	    };
	    Described.prototype.issues = function () {
	        return this._issues;
	    };
	    Described.prototype.toClarify = function () {
	        return this._toClarify;
	    };
	    Described.prototype.tags = function () {
	        return this._tags;
	    };
	    Described.prototype.withDescription = function (d) {
	        this._description = d;
	        return this;
	    };
	    return Described;
	})();
	exports.Described = Described;
	var ValueRequirement = (function () {
	    function ValueRequirement(name, value) {
	        this.name = name;
	        this.value = value;
	    }
	    return ValueRequirement;
	})();
	exports.ValueRequirement = ValueRequirement;
	var AbstractType = (function (_super) {
	    __extends(AbstractType, _super);
	    function AbstractType(_name, _universe, _path) {
	        _super.call(this, _name);
	        this._universe = _universe;
	        this._path = _path;
	        this._superTypes = [];
	        this._subTypes = [];
	        this._annotations = [];
	        this._requirements = [];
	        this._aliases = [];
	        this._defining = [];
	        this.fixedFacets = {};
	        this._methods = [];
	    }
	    AbstractType.prototype.isRuntime = function () {
	        return false;
	    };
	    AbstractType.prototype.union = function () {
	        return null;
	    };
	    AbstractType.prototype.isUserDefined = function () {
	        return false;
	    };
	    AbstractType.prototype.isArray = function () {
	        return false;
	    };
	    AbstractType.prototype.isUnion = function () {
	        return false;
	    };
	    AbstractType.prototype.fixFacet = function (name, v) {
	        this.fixedFacets[name] = v;
	    };
	    AbstractType.prototype.getFixedFacets = function () {
	        if (this._af) {
	            return this._af;
	        }
	        var sp = this.allSuperTypes();
	        var mm = {};
	        for (var q in this.fixedFacets) {
	            mm[q] = this.fixedFacets[q];
	        }
	        sp.forEach(function (x) {
	            if (x instanceof NodeClass) {
	                x.contributeFacets(mm);
	                var ff = x.fixedFacets;
	                for (var q in ff) {
	                    mm[q] = ff[q];
	                }
	            }
	        });
	        this.contributeFacets(mm);
	        this._af = mm;
	        return mm;
	    };
	    AbstractType.prototype.contributeFacets = function (x) {
	    };
	    AbstractType.prototype.setDeclaringNode = function (n) {
	        this._node = n;
	    };
	    AbstractType.prototype.getDeclaringNode = function () {
	        return this._node;
	    };
	    AbstractType.prototype.toRuntime = function () {
	        return this;
	    };
	    AbstractType.prototype.setConsumesRefs = function (b) {
	        this._consumesRef = b;
	    };
	    AbstractType.prototype.definingPropertyIsEnough = function (v) {
	        this._defining.push(v);
	    };
	    AbstractType.prototype.getDefining = function () {
	        return this._defining;
	    };
	    AbstractType.prototype.getConsumesRefs = function () {
	        return this._consumesRef;
	    };
	    AbstractType.prototype.addAlias = function (al) {
	        this._aliases.push(al);
	    };
	    AbstractType.prototype.getAliases = function () {
	        return this._aliases;
	    };
	    AbstractType.prototype.isValid = function (h, v, p) {
	        return true;
	    };
	    AbstractType.prototype.getPath = function () {
	        return this._path;
	    };
	    AbstractType.prototype.withFunctionalDescriminator = function (code) {
	        this._fDesc = code;
	    };
	    AbstractType.prototype.addMethod = function (name, text) {
	        this._methods.push({ name: name, text: text });
	    };
	    AbstractType.prototype.methods = function () {
	        return this._methods;
	    };
	    AbstractType.prototype.setNameAtRuntime = function (name) {
	        this._nameAtRuntime = name;
	    };
	    AbstractType.prototype.getNameAtRuntime = function () {
	        return this._nameAtRuntime;
	    };
	    AbstractType.prototype.getFunctionalDescriminator = function () {
	        return this._fDesc;
	    };
	    AbstractType.prototype.getRuntimeExtenders = function () {
	        return [];
	    };
	    AbstractType.prototype.universe = function () {
	        return this._universe;
	    };
	    AbstractType.prototype.superTypes = function () {
	        return [].concat(this._superTypes);
	    };
	    AbstractType.prototype.isAssignableFrom = function (typeName) {
	        if (this.name() == typeName) {
	            if (this.isUserDefined()) {
	                return false;
	            }
	            return true;
	        }
	        var currentSuperTypes = this.allSuperTypes();
	        for (var i = 0; i < currentSuperTypes.length; i++) {
	            if (currentSuperTypes[i].name() == typeName) {
	                return true;
	            }
	        }
	        return false;
	    };
	    AbstractType.prototype.subTypes = function () {
	        return [].concat(this._subTypes);
	    };
	    AbstractType.prototype.allSubTypes = function () {
	        var rs = [];
	        this.subTypes().forEach(function (x) {
	            rs.push(x);
	            rs = rs.concat(x.allSubTypes());
	        });
	        return _.unique(rs);
	    };
	    AbstractType.prototype.allSuperTypes = function () {
	        var rs = [];
	        this.allSuperTypesRecurrent(this, {}, rs);
	        return _.unique(rs);
	    };
	    AbstractType.prototype.allSuperTypesRecurrent = function (t, m, result) {
	        var _this = this;
	        t.superTypes().forEach(function (x) {
	            result.push(x);
	            if (!m[x.name()]) {
	                m[x.name()] = x;
	                _this.allSuperTypesRecurrent(x, m, result);
	            }
	        });
	    };
	    AbstractType.prototype.addRequirement = function (name, value) {
	        this._requirements.push(new ValueRequirement(name, value));
	    };
	    //FIXME simplify it
	    AbstractType.prototype.valueRequirements = function () {
	        return this._requirements;
	    };
	    AbstractType.prototype.annotations = function () {
	        return this._annotations;
	    };
	    return AbstractType;
	})(Described);
	exports.AbstractType = AbstractType;
	var ValueType = (function (_super) {
	    __extends(ValueType, _super);
	    function ValueType(name, _universe, path, description, _restriction) {
	        if (description === void 0) { description = ""; }
	        if (_restriction === void 0) { _restriction = null; }
	        _super.call(this, name, _universe, path);
	        this._restriction = _restriction;
	        this._declaredBy = [];
	    }
	    ValueType.prototype.hasStructure = function () {
	        if (this.name() == "structure") {
	            return true;
	        }
	        return false;
	    };
	    ValueType.prototype.isValid = function (h, v, p) {
	        try {
	            if (this.name() == "AnnotationRef") {
	                var targets = p.referenceTargets(h);
	                var actualAnnotation = _.find(targets, function (x) { return hlimpl.qName(x, h) == v; });
	                if (actualAnnotation != null) {
	                    var attrs = actualAnnotation.attributes("allowedTargets");
	                    if (attrs) {
	                        var aVals = attrs.map(function (x) { return x.value(); });
	                        if (aVals.length > 0) {
	                            var found = false;
	                            //no we should actually check that we are applying annotation properly
	                            var tps = h.definition().allSuperTypes();
	                            tps = tps.concat([h.definition()]);
	                            var tpNames = tps.map(function (x) { return x.name(); });
	                            aVals.forEach(function (x) {
	                                //FIXME this is deeply wrong code
	                                if (x == "API") {
	                                    x = "Api";
	                                }
	                                if (x == "NamedExample") {
	                                    x = "ExampleSpec";
	                                }
	                                if (x == "SecurityScheme") {
	                                    x = "SecuritySchema";
	                                }
	                                if (x == "SecuritySchemeSettings") {
	                                    x = "SecuritySchemaSettings";
	                                }
	                                if (_.find(tpNames, function (y) { return y == x; })) {
	                                    found = true;
	                                }
	                                else {
	                                    if (x == "Parameter") {
	                                        if (h.computedValue("location")) {
	                                            found = true;
	                                        }
	                                    }
	                                    if (x == "Field") {
	                                        if (h.computedValue("field")) {
	                                            found = true;
	                                        }
	                                    }
	                                }
	                            });
	                            if (!found) {
	                                return new Error("annotation " + v + " can not be placed at this location, allowed targets are:" + aVals);
	                            }
	                        }
	                    }
	                }
	                return tm;
	            }
	            if (this.name() == "SchemaString") {
	                var tm = su.createSchema(v);
	                if (tm instanceof Error) {
	                    tm.canBeRef = true;
	                }
	                return tm;
	            }
	            if (this.name() == "StatusCode") {
	                if (v.length != 3) {
	                    return new Error("Status code should be 3 digits number with optional 'x' as wildcards");
	                }
	                for (var i = 0; i < v.length; i++) {
	                    var c = v[i];
	                    if (!_.find(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'x', 'X'], function (x) { return x == c; })) {
	                        return new Error("Status code should be 3 digits number with optional 'x' as wildcards");
	                    }
	                }
	            }
	            if (this.name() == "JSonSchemaString") {
	                var jsshema = su.getJSONSchema(v);
	                if (jsshema instanceof Error) {
	                    jsshema.canBeRef = true;
	                }
	                return jsshema;
	            }
	            if (this.name() == "XMLSchemaString") {
	                var xmlschema = su.getXMLSchema(v);
	                if (xmlschema instanceof Error) {
	                    xmlschema.canBeRef = true;
	                }
	                return xmlschema;
	            }
	            if (this.name() == "BooleanType") {
	                if (!(v == 'true' || v == 'false')) {
	                    return new Error("'true' or 'false' is expected here");
	                }
	            }
	            if (this.name() == "NumberType") {
	                var q = parseFloat(v);
	                if (isNaN(q)) {
	                    return new Error("number is expected here");
	                }
	            }
	            if (this.name() == 'ramlexpression') {
	                try {
	                    if (p.name() == 'condition') {
	                        if (h.computedValue("response")) {
	                            h = h.parent().parent().parent();
	                        }
	                        else {
	                            h = h.parent().parent();
	                        }
	                    }
	                    if (p.name() == 'validWhen' || p.name() == 'requiredWhen') {
	                        h = h.parent();
	                    }
	                    ramlexp.validate(v, h);
	                }
	                catch (e) {
	                    return e;
	                }
	            }
	            if (this.name() == "pointer") {
	                var pointer = search.resolveRamlPointer(h, v);
	                if (!pointer) {
	                    return new Error("Unable to resolve raml pointer:" + v);
	                }
	                else {
	                    var dp = p;
	                    var sl = dp.getSelector(h);
	                    if (sl) {
	                        var pp = h;
	                        if (pp.definition().isAnnotation()) {
	                            pp = pp.parent();
	                        }
	                        var options = sl.apply(pp);
	                        if (!_.find(options, function (x) { return x == pointer; })) {
	                            return new Error("Pointer does not fits to scope " + v);
	                        }
	                    }
	                }
	            }
	            if (this.name() == "RAMLSelector") {
	                try {
	                    var sl = selector.parse(h, v);
	                    return sl;
	                }
	                catch (e) {
	                    return new Error("Unable to parse RAML selector :" + e.message);
	                }
	            }
	            return true;
	        }
	        catch (e) {
	            e.canBeRef = true; //FIXME
	            return e;
	        }
	    };
	    ValueType.prototype.isValueType = function () {
	        return true;
	    };
	    ValueType.prototype.isUnionType = function () {
	        return false;
	    };
	    ValueType.prototype.properties = function () {
	        return [];
	    };
	    ValueType.prototype.allProperties = function () {
	        return [];
	    };
	    ValueType.prototype.globallyDeclaredBy = function () {
	        return this._declaredBy;
	    };
	    ValueType.prototype.setGloballyDeclaredBy = function (c) {
	        this._declaredBy.push(c);
	    };
	    ValueType.prototype.getValueRestriction = function () {
	        return this._restriction;
	    };
	    ValueType.prototype.match = function (r) {
	        return false;
	    };
	    return ValueType;
	})(AbstractType);
	exports.ValueType = ValueType;
	var EnumType = (function (_super) {
	    __extends(EnumType, _super);
	    function EnumType() {
	        _super.apply(this, arguments);
	        this.values = [];
	    }
	    return EnumType;
	})(ValueType);
	exports.EnumType = EnumType;
	var ReferenceType = (function (_super) {
	    __extends(ReferenceType, _super);
	    function ReferenceType(name, path, referenceTo, _universe) {
	        _super.call(this, name, _universe, path);
	        this.referenceTo = referenceTo;
	    }
	    ReferenceType.prototype.getReferencedType = function () {
	        return this.universe().getType(this.referenceTo);
	    };
	    ReferenceType.prototype.hasStructure = function () {
	        var rt = this.getReferencedType();
	        if (rt) {
	            return rt.isInlinedTemplates() || (rt.findMembersDeterminer() != null) || rt.name() == "SecuritySchema"; //FIXME
	        }
	        else {
	            return false;
	        }
	    };
	    return ReferenceType;
	})(ValueType);
	exports.ReferenceType = ReferenceType;
	var ScriptingHookType = (function (_super) {
	    __extends(ScriptingHookType, _super);
	    function ScriptingHookType(name, path, refTo, _universe) {
	        _super.call(this, name, _universe, path);
	        this.refTo = refTo;
	    }
	    ScriptingHookType.prototype.getReferencedType = function () {
	        return this.universe().getType(this.refTo);
	    };
	    return ScriptingHookType;
	})(ValueType);
	exports.ScriptingHookType = ScriptingHookType;
	var NodeClass = (function (_super) {
	    __extends(NodeClass, _super);
	    function NodeClass(_name, universe, path, _description) {
	        if (_description === void 0) { _description = ""; }
	        _super.call(this, _name, universe, path);
	        this._properties = [];
	        this._declaresType = null;
	        this._runtimeExtenders = [];
	        this._inlinedTemplates = false;
	        this._contextReq = [];
	        this._allowQuestion = false;
	        this._canInherit = [];
	    }
	    NodeClass.prototype.isRuntime = function () {
	        return this._isRuntime;
	    };
	    NodeClass.prototype.isUserDefined = function () {
	        return false;
	    };
	    NodeClass.prototype.getRepresentationOf = function () {
	        return this._representationOf;
	    };
	    NodeClass.prototype.toRuntime = function () {
	        var c = new NodeClass(this.name(), this.universe(), "");
	        c._isRuntime = true;
	        c._representationOf = this;
	        //c._properties=this.allRuntimeProperties();
	        return c;
	    };
	    NodeClass.prototype.allFacets = function (ps) {
	        if (ps === void 0) { ps = {}; }
	        if (this._allFacets) {
	            return this._allFacets;
	        }
	        if (ps[this.name()]) {
	            return [];
	        }
	        ps[this.name()] = this;
	        var n = {};
	        if (this.superTypes().length > 0) {
	            this.superTypes().forEach(function (x) {
	                if (x instanceof NodeClass) {
	                    x.allFacets(ps).forEach(function (y) { return n[y.name()] = y; });
	                }
	            });
	        }
	        this._properties.forEach(function (x) { return n[x.name()] = x; });
	        this._allFacets = Object.keys(n).map(function (x) { return n[x]; });
	        //this.contributeToFacets(this._allFacets);
	        return this._allFacets;
	    };
	    NodeClass.prototype.facet = function (name) {
	        return _.find(this.allFacets(), function (x) { return x.name() == name; });
	    };
	    NodeClass.prototype.isDeclaration = function () {
	        if (this._inlinedTemplates) {
	            return true;
	        }
	        if (this._convertsToGlobal) {
	            return true;
	        }
	        if (this._declaresType) {
	            return true;
	        }
	        if (this.name() == "Library") {
	            return true;
	        }
	        return false;
	    };
	    NodeClass.prototype.isAnnotation = function () {
	        if (this._annotationChecked) {
	            return this._isAnnotation;
	        }
	        this._annotationChecked = true;
	        this._isAnnotation = (_.find(this.allSuperTypes(), function (x) { return x.name() == "Annotation"; }) != null);
	        return this._isAnnotation;
	    };
	    NodeClass.prototype.allowValue = function () {
	        if (this._allowValueSet) {
	            return this._allowValue;
	        }
	        if (_.find(this.allProperties(), function (x) { return x.isValue() || x.canBeValue(); })) {
	            this._allowValue = true;
	            this._allowValueSet = true;
	            return true;
	        }
	        this._allowValueSet = true;
	        return false;
	    };
	    NodeClass.prototype.printDetails = function () {
	        var result = "";
	        result += this.name() + "\n";
	        this.properties().forEach(function (property) {
	            result += "  " + property.name() + ":" + property.range() + "\n";
	        });
	        return result;
	    };
	    NodeClass.prototype.withCanInherit = function (clazz) {
	        this._canInherit.push(clazz);
	    };
	    NodeClass.prototype.getCanInherit = function () {
	        return this._canInherit;
	    };
	    NodeClass.prototype.getReferenceIs = function () {
	        return this._referenceIs;
	    };
	    NodeClass.prototype.withReferenceIs = function (fname) {
	        this._referenceIs = fname;
	    };
	    NodeClass.prototype.withAllowQuestion = function () {
	        this._allowQuestion = true;
	    };
	    NodeClass.prototype.requiredProperties = function () {
	        return this.allProperties().filter(function (x) { return x.isRequired(); });
	    };
	    NodeClass.prototype.getAllowQuestion = function () {
	        return this._allowQuestion;
	    };
	    NodeClass.prototype.withAllowAny = function () {
	        this._allowAny = true;
	    };
	    NodeClass.prototype.getAllowAny = function () {
	        return this._allowAny;
	    };
	    NodeClass.prototype.withActuallyExports = function (pname) {
	        this._actuallyExports = pname;
	    };
	    NodeClass.prototype.withConvertsToGlobal = function (pname) {
	        this._convertsToGlobal = pname;
	    };
	    NodeClass.prototype.getConvertsToGlobal = function () {
	        return this._convertsToGlobal;
	    };
	    NodeClass.prototype.getActuallyExports = function () {
	        return this._actuallyExports;
	    };
	    NodeClass.prototype.withContextRequirement = function (name, value) {
	        this._contextReq.push({ name: name, value: value });
	    };
	    NodeClass.prototype.getContextRequirements = function () {
	        return this._contextReq;
	    };
	    NodeClass.prototype.isGlobalDeclaration = function () {
	        if (this._actuallyExports) {
	            return true;
	        }
	        if (this._inlinedTemplates) {
	            return true;
	        }
	        if (this._declaresType) {
	            return true;
	        }
	        return false;
	    };
	    NodeClass.prototype.findMembersDeterminer = function () {
	        return _.find(this.allProperties(), function (x) { return x.isThisPropertyDeclaresTypeFields(); });
	    };
	    NodeClass.prototype.isTypeSystemMember = function () {
	        return this._declaresType != null;
	    };
	    NodeClass.prototype.hasStructure = function () {
	        return true;
	    };
	    NodeClass.prototype.getExtendedType = function () {
	        return this.universe().type(this._declaresType);
	    };
	    NodeClass.prototype.setInlinedTemplates = function (b) {
	        this._inlinedTemplates = b;
	        return this;
	    };
	    NodeClass.prototype.isInlinedTemplates = function () {
	        return this._inlinedTemplates;
	    };
	    NodeClass.prototype.setExtendedTypeName = function (name) {
	        this._declaresType = name;
	        var tp = this.universe().type(name);
	        if (tp instanceof NodeClass) {
	            var nc = tp;
	            nc._runtimeExtenders.push(this);
	        }
	    };
	    //private vReqInitied=false;
	    NodeClass.prototype.getRuntimeExtenders = function () {
	        return this._runtimeExtenders;
	    };
	    NodeClass.prototype.createStubNode = function (p, key) {
	        if (key === void 0) { key = null; }
	        var lowLevel = jsyaml.createNode(key ? key : "key");
	        var nm = new hlimpl.ASTNodeImpl(lowLevel, null, this, p);
	        this.allProperties().forEach(function (x) {
	            if (x.range().isValueType() && !x.isSystem()) {
	                var a = nm.attr(x.name());
	                if (!a) {
	                }
	            }
	        });
	        nm.children();
	        return nm;
	    };
	    NodeClass.prototype.createProperty = function (parent, key) {
	        if (key === void 0) { key = null; }
	        var lowLevel = jsyaml.createNode(key ? key : "key");
	        var p = new Property('zzz');
	        return p;
	    };
	    NodeClass.prototype.descriminatorValue = function () {
	        if (this.valueRequirements().length == 0) {
	            return this.name();
	        }
	        return this.valueRequirements()[0].value;
	    };
	    NodeClass.prototype.match = function (r, alreadyFound) {
	        var _this = this;
	        //this.vReqInitied=true;
	        if (r.isAttr() || r.isUnknown()) {
	            return false;
	        }
	        var el = r;
	        //if (this.name()=="ObjectField"){
	        //   var tp= el.attr("type");
	        //    if (tp&&tp.value()) {
	        //        //FIXME
	        //        if (!_.find(["string","boolean","file","number","integer","date","pointer","script"], x=>x==tp.value())) {
	        //            return true;
	        //        }
	        //    }
	        //}
	        var hasSuperType = _.find(this.superTypes(), function (x) {
	            var dp = _.find(x.allProperties(), function (x) { return x.isDescriminating(); });
	            if (dp) {
	                var a = el.attr(dp.name());
	                if (a) {
	                    if (a.value() == _this.name()) {
	                        return true;
	                    }
	                }
	            }
	            return false;
	        });
	        if (hasSuperType) {
	            return true;
	        }
	        if (this.valueRequirements().length == 0) {
	            return false;
	        }
	        var matches = true;
	        //descriminating constraint
	        this.valueRequirements().forEach(function (x) {
	            var a = el.attr(x.name);
	            if (a) {
	                if (a.value() == x.value) {
	                }
	                else {
	                    if (_this.getConsumesRefs()) {
	                        var vl = a.value();
	                        var allSubs = [];
	                        _this.superTypes().forEach(function (x) { return x.allSubTypes().forEach(function (y) {
	                            allSubs.push(y);
	                        }); });
	                        var allSubNames = [];
	                        _.unique(allSubs).forEach(function (x) {
	                            allSubNames.push(x.name());
	                            x.valueRequirements().forEach(function (y) {
	                                allSubNames.push(y.value);
	                            });
	                            x.getAliases().forEach(function (y) { return allSubNames.push(y); });
	                        });
	                        if (_.find(allSubNames, function (x) { return x == vl; })) {
	                            matches = false;
	                        }
	                    }
	                    else {
	                        matches = false;
	                    }
	                }
	            }
	            else {
	                var m = _this.getDefining();
	                var ms = false;
	                m.forEach(function (x) {
	                    el.lowLevel().children().forEach(function (y) {
	                        if (y.key() == x) {
	                            ms = true;
	                        }
	                        if (y.key() == "$ref") {
	                            if (el.definition().universe().version() == "Swagger") {
	                                var resolved = search.resolveReference(y, y.value());
	                                if (resolved) {
	                                    if (_.find(resolved.children(), function (z) { return z.key() == x; })) {
	                                        ms = true;
	                                    }
	                                }
	                            }
	                        }
	                    });
	                });
	                if (ms) {
	                    matches = true;
	                    return;
	                }
	                if (!alreadyFound) {
	                    var pr = _this.property(x.name);
	                    if (pr && pr.defaultValue() == x.value) {
	                    }
	                    else {
	                        matches = false;
	                    }
	                }
	            }
	        });
	        return matches;
	    };
	    NodeClass.prototype.allProperties = function (ps) {
	        if (ps === void 0) { ps = {}; }
	        if (this._props) {
	            return this._props;
	        }
	        if (ps[this.name()]) {
	            return [];
	        }
	        ps[this.name()] = this;
	        var n = {};
	        if (this.superTypes().length > 0) {
	            this.superTypes().forEach(function (x) {
	                if (x instanceof NodeClass) {
	                    x.allProperties(ps).forEach(function (y) { return n[y.name()] = y; });
	                }
	                else {
	                    x.allProperties().forEach(function (y) { return n[y.name()] = y; });
	                }
	            });
	        }
	        for (var x in this.getFixedFacets()) {
	            delete n[x];
	        }
	        this._properties.forEach(function (x) { return n[x.name()] = x; });
	        this._props = Object.keys(n).map(function (x) { return n[x]; });
	        return this._props;
	    };
	    NodeClass.prototype.isValueType = function () {
	        return false;
	    };
	    NodeClass.prototype.isAbstract = function () {
	        return this._isAbstract;
	    };
	    NodeClass.prototype.isUnionType = function () {
	        return false;
	    };
	    NodeClass.prototype.property = function (propName) {
	        return _.find(this.allProperties(), function (x) { return x.name() == propName; });
	    };
	    NodeClass.prototype.properties = function () {
	        return [].concat(this._properties);
	    };
	    NodeClass.prototype.getKeyProp = function () {
	        return _.find(this.allProperties(), function (x) { return x.isKey(); });
	    };
	    NodeClass.prototype.registerProperty = function (p) {
	        if (p.domain() != this) {
	            throw new Error("Should be already owned by this");
	        }
	        if (this._properties.indexOf(p) != -1) {
	            throw new Error("Already included");
	        }
	        this._properties.push(p);
	    };
	    NodeClass.prototype.allRuntimeProperties = function (ps) {
	        if (ps === void 0) { ps = {}; }
	        return [];
	    };
	    return NodeClass;
	})(AbstractType);
	exports.NodeClass = NodeClass;
	var UserDefinedClass = (function (_super) {
	    __extends(UserDefinedClass, _super);
	    function UserDefinedClass(name, universe, hl, path, description) {
	        _super.call(this, name, universe, path, description);
	        this.uc = false;
	        this.setDeclaringNode(hl);
	    }
	    UserDefinedClass.prototype.addRuntimeProperty = function (p) {
	        this._runtimeProperties.push(p);
	    };
	    UserDefinedClass.prototype.isArray = function () {
	        return _.find(this.allSuperTypes(), function (x) { return x.isArray(); }) != null;
	    };
	    UserDefinedClass.prototype.isUnion = function () {
	        return _.find(this.allSuperTypes(), function (x) {
	            var mm = x;
	            if (mm.uc) {
	                return false;
	            }
	            mm.uc = true;
	            try {
	                return x.isUnion();
	            }
	            finally {
	                mm.uc = false;
	            }
	        }) != null;
	    };
	    UserDefinedClass.prototype.isUserDefined = function () {
	        return true;
	    };
	    UserDefinedClass.prototype.contributeFacets = function (x) {
	        this.findFacets(this.getDeclaringNode(), x);
	    };
	    UserDefinedClass.prototype.findFacets = function (node, x) {
	        if (node) {
	            var chd = node.lowLevel().children();
	            var mi = _.find(chd, function (x) { return x.key() == "minProperties"; });
	            if (mi) {
	                x[mi.key()] = mi;
	            }
	            var mi = _.find(chd, function (x) { return x.key() == "maxProperties"; });
	            if (mi) {
	                x[mi.key()] = mi;
	            }
	        }
	    };
	    UserDefinedClass.prototype.initRuntime = function () {
	        var _this = this;
	        this._runtimeProperties = [];
	        var node = this.getDeclaringNode();
	        if (node) {
	            var el = node.elementsOfKind("properties");
	            el.forEach(function (x) {
	                var prop = typeBuilder.elementToProp(x, true);
	                _this.addRuntimeProperty(prop);
	            });
	        }
	    };
	    UserDefinedClass.prototype.isValueType = function () {
	        if (this.isRuntime()) {
	            return this._value;
	        }
	        if (this.isAssignableFrom("ObjectField")) {
	            return false;
	        }
	        return true;
	    };
	    UserDefinedClass.prototype.componentType = function () {
	        var x = this.allSuperTypes();
	        var res = null;
	        x.forEach(function (y) {
	            if (y instanceof Array) {
	                res = y.component;
	            }
	        });
	        return res;
	    };
	    UserDefinedClass.prototype.union = function () {
	        var x = this.allSuperTypes();
	        var res = null;
	        x.forEach(function (y) {
	            if (y instanceof Union) {
	                res = y;
	            }
	        });
	        return res;
	    };
	    UserDefinedClass.prototype.toRuntime = function () {
	        var c = new UserDefinedClass(this.name(), this.universe(), null, this.getPath(), "");
	        c._isRuntime = true;
	        c._representationOf = this;
	        c._properties = this.allRuntimeProperties();
	        c.setDeclaringNode(this.getDeclaringNode());
	        if (this.isAssignableFrom("ObjectField")) {
	            c._value = false;
	            if (c._properties.length == 0) {
	                c.withAllowAny();
	            }
	        }
	        else {
	            c._value = true;
	        }
	        if (this.isUnion()) {
	            var ut = new Union(this.name(), this.universe(), this.getPath(), "");
	            ut._representationOf = this;
	            ut.setDeclaringNode(this.getDeclaringNode());
	            var cm = this.union();
	            if (cm) {
	                if (cm.left) {
	                    ut.left = cm.left.toRuntime();
	                }
	                if (cm.right) {
	                    ut.right = cm.right.toRuntime();
	                }
	                return ut;
	            }
	            ut._isRuntime = true;
	            //at.component=this.component.toRuntime();
	            return ut;
	        }
	        if (this.isArray()) {
	            var at = new defs.Array(this.name(), this.universe(), this.getPath(), "");
	            at._representationOf = this;
	            at.setDeclaringNode(this.getDeclaringNode());
	            var cm = this.componentType();
	            if (cm) {
	                at.component = cm.toRuntime();
	            }
	            //at.component=this.component.toRuntime();
	            return at;
	        }
	        return c;
	    };
	    UserDefinedClass.prototype.allRuntimeProperties = function (ps) {
	        if (ps === void 0) { ps = {}; }
	        if (!this._runtimeProperties) {
	            this.initRuntime();
	            this._rprops = null;
	        }
	        if (this._rprops) {
	            return this._rprops;
	        }
	        if (ps[this.name()]) {
	            return [];
	        }
	        ps[this.name()] = this;
	        var n = {};
	        if (this.superTypes().length > 0) {
	            this.superTypes().forEach(function (x) {
	                if (x instanceof NodeClass) {
	                    x.allRuntimeProperties(ps).forEach(function (y) { return n[y.name()] = y; });
	                }
	            });
	        }
	        this._runtimeProperties.forEach(function (x) { return n[x.name()] = x; });
	        this._rprops = Object.keys(n).map(function (x) { return n[x]; });
	        return this._rprops;
	    };
	    UserDefinedClass.prototype.getRuntimeProperties = function () {
	        if (!this._runtimeProperties) {
	            this.initRuntime();
	        }
	        return this._runtimeProperties;
	    };
	    return UserDefinedClass;
	})(NodeClass);
	exports.UserDefinedClass = UserDefinedClass;
	var AnnotationType = (function (_super) {
	    __extends(AnnotationType, _super);
	    function AnnotationType() {
	        _super.apply(this, arguments);
	    }
	    AnnotationType.prototype.allProperties = function (ps) {
	        if (ps === void 0) { ps = {}; }
	        var result = _super.prototype.allProperties.call(this, ps);
	        if (result.length <= 1) {
	            //we have only key property defined
	            var up = new UserDefinedProp("value");
	            up.withDomain(this);
	            up._node = this.getDeclaringNode();
	            up.withCanBeValue();
	            up.withRequired(false);
	            up.withRange(this.universe().getType("StringType"));
	            var rr = [].concat(result);
	            rr.push(up);
	            return rr;
	        }
	        return result;
	    };
	    return AnnotationType;
	})(UserDefinedClass);
	exports.AnnotationType = AnnotationType;
	var Universe = (function (_super) {
	    __extends(Universe, _super);
	    function Universe(name, _parent, v) {
	        if (name === void 0) { name = ""; }
	        if (_parent === void 0) { _parent = null; }
	        if (v === void 0) { v = "RAML08"; }
	        _super.call(this, name);
	        this._parent = _parent;
	        this._classes = [];
	        this._uversion = "RAML08";
	        this.aMap = {};
	        this._uversion = v;
	    }
	    Universe.prototype.setTopLevel = function (t) {
	        this._topLevel = t;
	    };
	    Universe.prototype.getTopLevel = function () {
	        return this._topLevel;
	    };
	    Universe.prototype.setTypedVersion = function (tv) {
	        this._typedVersion = tv;
	    };
	    Universe.prototype.getTypedVersion = function () {
	        return this._typedVersion;
	    };
	    Universe.prototype.version = function () {
	        return this._uversion;
	    };
	    Universe.prototype.setUniverseVersion = function (version) {
	        this._uversion = version;
	    };
	    Universe.prototype.types = function () {
	        var result = [].concat(this._classes);
	        if (this._parent != null) {
	            result = result.concat(this._parent.types());
	        }
	        return result;
	    };
	    Universe.prototype.type = function (name) {
	        if (this.aMap[name]) {
	            return this.aMap[name];
	        }
	        var tp = _.find(this._classes, function (x) { return x.name() == name; });
	        if (tp == null) {
	            if (this._parent) {
	                var tp = this._parent.type(name);
	                if (tp instanceof AbstractType) {
	                    var at = tp;
	                    at._universe = this; //FIXME
	                }
	            }
	        }
	        return tp;
	    };
	    Universe.prototype.getType = function (name) {
	        return this.type(name);
	    };
	    Universe.prototype.register = function (t) {
	        this._classes.push(t);
	        if (t instanceof NodeClass) {
	            this._classes.forEach(function (x) {
	                if (x instanceof NodeClass) {
	                    var nc = x;
	                    if (nc.getExtendedType() == t) {
	                        t.getRuntimeExtenders().push(x);
	                    }
	                }
	            });
	        }
	        return this;
	    };
	    Universe.prototype.registerAlias = function (a, t) {
	        this.aMap[a] = t;
	    };
	    Universe.prototype.unregister = function (t) {
	        this._classes = this._classes.filter(function (x) { return x != t; });
	        var st = t.superTypes();
	        st.forEach(function (x) {
	            var a = x;
	            a._superTypes = a._superTypes.filter(function (x) { return x != t; });
	        });
	        st = t.subTypes();
	        st.forEach(function (x) {
	            var a = x;
	            a._subTypes = a._subTypes.filter(function (x) { return x != t; });
	        });
	        return this;
	    };
	    Universe.prototype.registerSuperClass = function (t0, t1) {
	        var a0 = t0;
	        var a1 = t1;
	        a0._superTypes.push(t1);
	        a1._subTypes.push(t0);
	    };
	    return Universe;
	})(Described);
	exports.Universe = Universe;
	var ValueRestriction = (function () {
	    function ValueRestriction() {
	    }
	    ValueRestriction.prototype.test = function (n, p, value) {
	        throw new Error("Should be overriden in subclasses");
	    };
	    return ValueRestriction;
	})();
	exports.ValueRestriction = ValueRestriction;
	/**
	 * references element in upper hierarchy
	 */
	var ReferenceTo = (function (_super) {
	    __extends(ReferenceTo, _super);
	    function ReferenceTo(_requiredClass) {
	        _super.call(this);
	        this._requiredClass = _requiredClass;
	    }
	    ReferenceTo.prototype.requiredClass = function () {
	        return this._requiredClass;
	    };
	    return ReferenceTo;
	})(ValueRestriction);
	exports.ReferenceTo = ReferenceTo;
	/**
	 * should be fixed set
	 */
	var FixedSetRestriction = (function (_super) {
	    __extends(FixedSetRestriction, _super);
	    function FixedSetRestriction(_allowedValues) {
	        _super.call(this);
	        this._allowedValues = _allowedValues;
	    }
	    FixedSetRestriction.prototype.values = function () {
	        return this._allowedValues;
	    };
	    return FixedSetRestriction;
	})(ValueRestriction);
	exports.FixedSetRestriction = FixedSetRestriction;
	/**
	 * should be reg exp
	 */
	var RegExpRestriction = (function (_super) {
	    __extends(RegExpRestriction, _super);
	    function RegExpRestriction(_regExp) {
	        _super.call(this);
	        this._regExp = _regExp;
	    }
	    RegExpRestriction.prototype.regeExp = function () {
	        return this._regExp;
	    };
	    return RegExpRestriction;
	})(ValueRestriction);
	exports.RegExpRestriction = RegExpRestriction;
	var UnionType = (function () {
	    function UnionType(_base) {
	        this._base = _base;
	    }
	    UnionType.prototype.isUserDefined = function () {
	        return false;
	    };
	    UnionType.prototype.isRuntime = function () {
	        return false;
	    };
	    UnionType.prototype.isArray = function () {
	        return false;
	    };
	    UnionType.prototype.isUnion = function () {
	        return true;
	    };
	    UnionType.prototype.union = function () {
	        return null;
	    };
	    UnionType.prototype.getRuntimeExtenders = function () {
	        return [];
	    };
	    UnionType.prototype.methods = function () {
	        return [];
	    };
	    UnionType.prototype.superTypes = function () {
	        return [];
	    };
	    UnionType.prototype.allSuperTypes = function () {
	        return [];
	    };
	    UnionType.prototype.isAssignableFrom = function (typeName) {
	        return false;
	    };
	    UnionType.prototype.subTypes = function () {
	        return [];
	    };
	    UnionType.prototype.name = function () {
	        return this._base.map(function (x) { return x.name(); }).join(",");
	    };
	    UnionType.prototype.hasStructure = function () {
	        return false;
	    };
	    UnionType.prototype.description = function () {
	        return "";
	    };
	    UnionType.prototype.isValid = function () {
	        return true;
	    };
	    UnionType.prototype.universe = function () {
	        return this._base[0].universe();
	    };
	    UnionType.prototype.match = function (r) {
	        return false;
	    };
	    UnionType.prototype.allSubTypes = function () {
	        throw new Error("Union types should not be used in this context");
	    };
	    UnionType.prototype.annotations = function () {
	        throw new Error("Union types should not be used in this context");
	    };
	    UnionType.prototype.allProperties = function () {
	        throw new Error("Union types should be never used in this context");
	    };
	    UnionType.prototype.getAlternatives = function () {
	        return [].concat(this._base);
	    };
	    UnionType.prototype.valueRequirements = function () {
	        throw new Error("Union types should be never used in this context");
	    };
	    UnionType.prototype.toRuntime = function () {
	        throw new Error("Not implemented");
	    };
	    UnionType.prototype.properties = function () {
	        var res = [];
	        this._base.forEach(function (x) { return res.concat(x.properties()); });
	        return res;
	    };
	    UnionType.prototype.isValueType = function () {
	        if (this._base.filter(function (x) { return (x.isValueType() == true); }).length == this._base.length) {
	            return true;
	        }
	        if (this._base.filter(function (x) { return (x.isValueType() == false); }).length == this._base.length) {
	            return false;
	        }
	        return null;
	    };
	    UnionType.prototype.isUnionType = function () {
	        return true;
	    };
	    return UnionType;
	})();
	exports.UnionType = UnionType;
	var PropertyTrait = (function () {
	    function PropertyTrait() {
	    }
	    return PropertyTrait;
	})();
	exports.PropertyTrait = PropertyTrait;
	var DefinesImplicitKey = (function (_super) {
	    __extends(DefinesImplicitKey, _super);
	    function DefinesImplicitKey(_where, _childKeyDefined) {
	        _super.call(this);
	        this._where = _where;
	        this._childKeyDefined = _childKeyDefined;
	    }
	    DefinesImplicitKey.prototype.where = function () {
	        return this._where;
	    };
	    DefinesImplicitKey.prototype.definesKeyOf = function () {
	        return this._childKeyDefined;
	    };
	    return DefinesImplicitKey;
	})(PropertyTrait);
	exports.DefinesImplicitKey = DefinesImplicitKey;
	var ExpansionTrait = (function (_super) {
	    __extends(ExpansionTrait, _super);
	    function ExpansionTrait() {
	        _super.call(this);
	    }
	    return ExpansionTrait;
	})(PropertyTrait);
	exports.ExpansionTrait = ExpansionTrait;
	function prop(name, desc, domain, range) {
	    var prop = new Property(name, desc);
	    return prop.withDomain(domain).withRange(range);
	}
	exports.prop = prop;
	var ChildValueConstraint = (function () {
	    function ChildValueConstraint(name, value) {
	        this.name = name;
	        this.value = value;
	    }
	    return ChildValueConstraint;
	})();
	exports.ChildValueConstraint = ChildValueConstraint;
	var Property = (function (_super) {
	    __extends(Property, _super);
	    function Property() {
	        _super.apply(this, arguments);
	        this._keyShouldStartFrom = null;
	        this._isMultiValue = false;
	        this._isFromParentValue = false;
	        this._isFromParentKey = false;
	        this._isRequired = false;
	        this._key = false;
	        this._traits = [];
	        this._describes = null;
	        this._descriminates = false;
	        this._selfNode = false;
	        this._contextReq = [];
	        this._vrestr = [];
	        this.determinesChildValues = [];
	    }
	    Property.prototype.withNoDirectParse = function () {
	        this._noDirectParse = true;
	    };
	    Property.prototype.isNoDirectParse = function () {
	        return this._noDirectParse;
	    };
	    Property.prototype.setDocTableName = function (val) {
	        this._docTableName = val;
	    };
	    Property.prototype.docTableName = function () {
	        return this._docTableName;
	    };
	    Property.prototype.setHidden = function (val) {
	        this._isHidden = val;
	    };
	    Property.prototype.isHidden = function () {
	        return this._isHidden;
	    };
	    Property.prototype.setMarkdownDescription = function (val) {
	        this._markdownDescription = val;
	    };
	    Property.prototype.markdownDescription = function () {
	        return this._markdownDescription;
	    };
	    Property.prototype.setValueDescription = function (val) {
	        this._valueDescription = val;
	    };
	    Property.prototype.valueDescription = function () {
	        return this._valueDescription;
	    };
	    Property.prototype.isExampleProperty = function () {
	        return this.domain() && (!this.domain().isUserDefined()) && (this.name() == "example" || this.name() == "content");
	    };
	    Property.prototype.getFacetValidator = function () {
	        return this.facetValidator;
	    };
	    Property.prototype.setFacetValidator = function (f) {
	        this.facetValidator = f;
	    };
	    Property.prototype.withSelfNode = function () {
	        this._selfNode = true;
	    };
	    Property.prototype.isSelfNode = function () {
	        return this._selfNode;
	    };
	    Property.prototype.getSelector = function (h) {
	        var sl = this._selector;
	        if (sl instanceof selector.Selector) {
	            return sl;
	        }
	        if (!h) {
	            return null;
	        }
	        if (this._selector) {
	            return selector.parse(h, this._selector);
	        }
	        return null;
	    };
	    Property.prototype.setSelector = function (s) {
	        this._selector = s;
	        return this;
	    };
	    Property.prototype.valueDocProvider = function () {
	        return this._vprovider;
	    };
	    Property.prototype.setValueDocProvider = function (v) {
	        this._vprovider = v;
	        return this;
	    };
	    Property.prototype.suggester = function () {
	        return this._suggester;
	    };
	    Property.prototype.setValueSuggester = function (s) {
	        this._suggester = s;
	    };
	    Property.prototype.enumOptions = function () {
	        if (this._enumOptions && typeof this._enumOptions == 'string') {
	            return [this._enumOptions + ""];
	        }
	        return this._enumOptions;
	    };
	    Property.prototype.getOftenKeys = function () {
	        return this._oftenKeys;
	    };
	    Property.prototype.withOftenKeys = function (keys) {
	        this._oftenKeys = keys;
	        return this;
	    };
	    Property.prototype.withCanBeValue = function () {
	        this._canBeValue = true;
	        return this;
	    };
	    Property.prototype.withInherited = function (w) {
	        this._isInherited = w;
	    };
	    Property.prototype.isInherited = function () {
	        return this._isInherited;
	    };
	    Property.prototype.isAllowNull = function () {
	        return this._isAllowNull;
	    };
	    Property.prototype.withAllowNull = function () {
	        this._isAllowNull = true;
	    };
	    Property.prototype.isDescriminator = function () {
	        return this._descriminates;
	    };
	    Property.prototype.getCanBeDuplicator = function () {
	        return this._canBeDuplicator;
	    };
	    Property.prototype.isValue = function () {
	        return this._isFromParentValue;
	    };
	    Property.prototype.canBeValue = function () {
	        return this._canBeValue;
	    };
	    Property.prototype.setCanBeDuplicator = function () {
	        this._canBeDuplicator = true;
	        return true;
	    };
	    Property.prototype.inheritedContextValue = function () {
	        return this._inheritsValueFromContext;
	    };
	    Property.prototype.withInheritedContextValue = function (v) {
	        this._inheritsValueFromContext = v;
	        return this;
	    };
	    Property.prototype.withPropertyGrammarType = function (pt) {
	        this._propertyGrammarType = pt;
	    };
	    Property.prototype.getPropertyGrammarType = function () {
	        return this._propertyGrammarType;
	    };
	    Property.prototype.withContextRequirement = function (name, value) {
	        this._contextReq.push({ name: name, value: value });
	    };
	    Property.prototype.getContextRequirements = function () {
	        return this._contextReq;
	    };
	    Property.prototype.withDescriminating = function (b) {
	        this._descriminates = b;
	        return this;
	    };
	    Property.prototype.isDescriminating = function () {
	        return this._descriminates;
	    };
	    Property.prototype.withDescribes = function (a) {
	        this._describes = a;
	        return this;
	    };
	    Property.prototype.withValueRewstrinction = function (exp, message) {
	        this._vrestr.push({ exp: exp, message: message });
	        return this;
	    };
	    Property.prototype.getValueRestrictionExpressions = function () {
	        return this._vrestr;
	    };
	    Property.prototype.describesAnnotation = function () {
	        return this._describes != null;
	    };
	    Property.prototype.describedAnnotation = function () {
	        return this._describes;
	    };
	    Property.prototype.createAttr = function (val) {
	        var lowLevel = jsyaml.createMapping(this.name(), val);
	        var nm = new hlimpl.ASTPropImpl(lowLevel, null, this.range(), this);
	        return nm;
	    };
	    Property.prototype.isReference = function () {
	        return this.range() instanceof ReferenceType;
	    };
	    Property.prototype.referencesTo = function () {
	        return this.range().getReferencedType();
	    };
	    Property.prototype.newInstanceName = function () {
	        if (this._newInstanceName) {
	            return this._newInstanceName;
	        }
	        return this.range().name();
	    };
	    Property.prototype.withThisPropertyDeclaresFields = function (b) {
	        if (b === void 0) { b = true; }
	        this._declaresFields = b;
	        return this;
	    };
	    Property.prototype.isThisPropertyDeclaresTypeFields = function () {
	        return this._declaresFields;
	    };
	    Property.prototype.withNewInstanceName = function (name) {
	        this._newInstanceName = name;
	        return this;
	    };
	    Property.prototype.addChildValueConstraint = function (c) {
	        this.determinesChildValues.push(c);
	    };
	    Property.prototype.setDefaultVal = function (s) {
	        this._defaultVal = s;
	        return this;
	    };
	    Property.prototype.defaultValue = function () {
	        return this._defaultVal;
	    };
	    Property.prototype.getChildValueConstraints = function () {
	        return this.determinesChildValues;
	    };
	    Property.prototype.childRestrictions = function () {
	        return this.determinesChildValues;
	    };
	    Property.prototype.isSystem = function () {
	        return this._isSystem;
	    };
	    Property.prototype.withSystem = function (s) {
	        this._isSystem = s;
	        return this;
	    };
	    Property.prototype.isEmbedMap = function () {
	        return this._isEmbedMap;
	    };
	    Property.prototype.withEmbedMap = function () {
	        this._isEmbedMap = true;
	        return this;
	    };
	    Property.prototype.id = function () {
	        if (this._id) {
	            return this._id;
	        }
	        if (!this._groupName) {
	            return null;
	        }
	        if (this.domain().getDeclaringNode()) {
	            return null;
	        }
	        this._id = this._groupName + this.domain().name();
	        return this._id;
	    };
	    Property.prototype.isValidValue = function (vl, c) {
	        var node = search.declRoot(c);
	        if (!node._cach) {
	            node._cach = {};
	        }
	        var id = this.id();
	        if (id) {
	            var cached = node._cach[id];
	            if (cached) {
	                return cached[vl] != null;
	            }
	        }
	        var vls = this.enumValues(c);
	        var mm = {};
	        vls.forEach(function (x) { return mm[x] = 1; });
	        if (this._groupName) {
	            node._cach[id] = mm;
	        }
	        return mm[vl] != null;
	    };
	    Property.prototype.enumValues = function (c) {
	        if (c) {
	            var rs = [];
	            //TODO FIXME it is very very weird idea but I need to get it working right now
	            if (this.isTypeExpr()) {
	                var definitionNodes = search.globalDeclarations(c).filter(function (node) {
	                    if (node.definition().name() == "GlobalSchema") {
	                        return true;
	                    }
	                    var st = node.definition().allSuperTypes();
	                    if (_.find(st, function (x) { return x.name() == "DataElement"; })) {
	                        return true;
	                    }
	                    return node.definition().name() == "DataElement" && node.property().name() == 'models';
	                    //return true;
	                });
	                rs = definitionNodes.map(function (x) { return hlimpl.qName(x, c); });
	                var de = c.definition().universe().getType("DataElement");
	                if (de) {
	                    var subTypes = de.allSubTypes();
	                    rs = rs.concat(subTypes.map(function (x) { return x.descriminatorValue(); }));
	                }
	                return rs;
	            }
	            else {
	                if (this.range().name() == "SchemaString") {
	                    if (this.range().universe().version() == "RAML10") {
	                        if (this.range() instanceof defs.ValueType) {
	                            var definitionNodes = search.globalDeclarations(c).filter(function (node) {
	                                if (node.definition().name() == "GlobalSchema") {
	                                    return true;
	                                }
	                                var st = node.definition().allSuperTypes();
	                                if (_.find(st, function (x) { return x.name() == "DataElement"; })) {
	                                    return true;
	                                }
	                                return node.definition().name() == "DataElement" && node.property().name() == 'models';
	                                //return true;
	                            });
	                            rs = definitionNodes.map(function (x) { return hlimpl.qName(x, c); });
	                        }
	                    }
	                }
	            }
	            if (this.isDescriminating()) {
	                var subTypes = search.subTypesWithLocals(this.domain(), c);
	                rs = rs.concat(subTypes.map(function (x) { return x.descriminatorValue(); }));
	            }
	            else if (this.isReference()) {
	                rs = search.nodesDeclaringType(this.referencesTo(), c).map(function (x) { return hlimpl.qName(x, c); });
	            }
	            else if (this.range().isValueType() && this.range() instanceof ValueType) {
	                var vt = this.range();
	                if (vt.globallyDeclaredBy().length > 0) {
	                    var definitionNodes = search.globalDeclarations(c).filter(function (z) { return _.find(vt.globallyDeclaredBy(), function (x) { return x == z.definition(); }) != null; });
	                    rs = rs.concat(definitionNodes.map(function (x) { return hlimpl.qName(x, c); }));
	                }
	            }
	            if (this.isAllowNull()) {
	                rs.push("null");
	            }
	            if (this._enumOptions) {
	                rs = rs.concat(this._enumOptions);
	            }
	            return rs;
	        }
	        if (this._enumOptions && typeof this._enumOptions == 'string') {
	            return [this._enumOptions + ""];
	        }
	        return this._enumOptions;
	    };
	    Property.prototype.isTypeExpr = function () {
	        if (this.teDef && false) {
	            return this.texpr;
	        }
	        if (this.domain()) {
	            this.texpr = ((this.name() == "type" || this.name() == "schema") && this.domain().name() == "DataElement") || (this.name() == "schema" && this.domain().name() == "BodyLike") || (this.name() == "type" && this.domain().name() == "BodyLike") || (this.name() == "signature" && this.domain().name() == "Resource") || (this.name() == "signature" && this.domain().name() == "MethodBase");
	        }
	        if (!this.texpr) {
	            if (this.range().name() == "SchemaString") {
	                if (this.range().universe().version() == "RAML10") {
	                    if (this.range() instanceof defs.ValueType) {
	                        this.texpr = true;
	                    }
	                }
	            }
	        }
	        this.teDef = true;
	        return this.texpr;
	    };
	    Property.prototype.priority = function () {
	        if (this.isKey())
	            return 128;
	        else if (this.isReference())
	            return 64;
	        else if (this.isTypeExpr())
	            return 32;
	        else if (this.name() == 'example')
	            return 0;
	        else
	            return -1024;
	    };
	    Property.prototype.referenceTargets = function (c) {
	        if (this.isTypeExpr()) {
	            var definitionNodes = search.globalDeclarations(c).filter(function (node) {
	                if (node.definition().name() == "GlobalSchema") {
	                    return true;
	                }
	                var st = node.definition().allSuperTypes();
	                if (_.find(st, function (x) { return x.name() == "DataElement"; })) {
	                    return true;
	                }
	                return node.definition().name() == "DataElement" && node.property().name() == 'models';
	                //return true;
	            });
	            return definitionNodes;
	        }
	        if (this.isDescriminating()) {
	            var subTypes = search.nodesDeclaringType(this.range(), c);
	            return subTypes;
	        }
	        if (this.isReference()) {
	            var rt = this.referencesTo();
	            var subTypes = search.nodesDeclaringType(rt, c);
	            return subTypes;
	        }
	        if (this.range().isValueType()) {
	            var vt = this.range();
	            if (vt.globallyDeclaredBy().length > 0) {
	                var definitionNodes = search.globalDeclarations(c).filter(function (z) { return _.find(vt.globallyDeclaredBy(), function (x) { return x == z.definition(); }) != null; });
	                return definitionNodes;
	            }
	        }
	        return [];
	    };
	    Property.prototype.getEnumOptions = function () {
	        if (this._enumOptions && typeof this._enumOptions == 'string') {
	            return [this._enumOptions + ""];
	        }
	        return this._enumOptions;
	    };
	    Property.prototype.withEnumOptions = function (op) {
	        this._enumOptions = op;
	        return this;
	    };
	    Property.prototype.withDomain = function (d) {
	        this._ownerClass = d;
	        d.registerProperty(this);
	        return this;
	    };
	    Property.prototype.withRange = function (t) {
	        this._nodeRange = t;
	        return this;
	    };
	    Property.prototype.getTraits = function () {
	        return this._traits;
	    };
	    Property.prototype.keyPrefix = function () {
	        return this._keyShouldStartFrom;
	    };
	    Property.prototype.isAnnotation = function () {
	        return this._groupName == 'annotations' && this.domain() && !this.domain().isUserDefined();
	    };
	    Property.prototype.matchKey = function (k) {
	        if (k == null) {
	            return false;
	        }
	        if (this._groupName != null) {
	            if (this.isAnnotation()) {
	                if (k.charAt(0) == '(' && k.charAt(k.length - 1) == ')') {
	                    return true;
	                }
	                return false;
	            }
	            return this._groupName == k;
	        }
	        else {
	            if (this._keyShouldStartFrom != null) {
	                if (k.indexOf(this._keyShouldStartFrom) == 0) {
	                    return true;
	                }
	            }
	            if (this._enumOptions) {
	                if (this._enumOptions.indexOf(k) != -1) {
	                    return true;
	                }
	            }
	            if (this.getKeyRegexp()) {
	                try {
	                    if (new RegExp(this.getKeyRegexp()).test(k)) {
	                        return true;
	                    }
	                }
	                catch (Error) {
	                }
	            }
	            return false;
	        }
	    };
	    Property.prototype.withMultiValue = function (v) {
	        if (v === void 0) { v = true; }
	        this._isMultiValue = v;
	        return this;
	    };
	    Property.prototype.withFromParentValue = function (v) {
	        if (v === void 0) { v = true; }
	        this._isFromParentValue = v;
	        return this;
	    };
	    Property.prototype.withFromParentKey = function (v) {
	        if (v === void 0) { v = true; }
	        this._isFromParentKey = v;
	        return this;
	    };
	    Property.prototype.isFromParentKey = function () {
	        return this._isFromParentKey;
	    };
	    Property.prototype.isFromParentValue = function () {
	        return this._isFromParentValue;
	    };
	    Property.prototype.withGroupName = function (gname) {
	        this._groupName = gname;
	        return this;
	    };
	    Property.prototype.withRequired = function (req) {
	        this._isRequired = req;
	        return this;
	    };
	    Property.prototype.unmerge = function () {
	        this._groupName = this.name();
	        return this;
	    };
	    Property.prototype.merge = function () {
	        this._groupName = null;
	        return this;
	    };
	    Property.prototype.withKey = function (isKey) {
	        this._key = isKey;
	        return this;
	    };
	    /**
	     * TODO THIS STUFF SHOULD BE MORE ABSTRACT (LATER...)
	     * @param keyShouldStartFrom
	     * @returns {Property}
	     */
	    Property.prototype.withKeyRestriction = function (keyShouldStartFrom) {
	        this._keyShouldStartFrom = keyShouldStartFrom;
	        return this;
	    };
	    Property.prototype.withKeyRegexp = function (regexp) {
	        this._keyRegexp = regexp;
	    };
	    Property.prototype.getKeyRegexp = function () {
	        return this._keyRegexp;
	    };
	    Property.prototype.domain = function () {
	        return this._ownerClass;
	    };
	    Property.prototype.range = function () {
	        return this._nodeRange;
	    };
	    Property.prototype.isKey = function () {
	        return this._key;
	    };
	    Property.prototype.isValueProperty = function () {
	        return this._nodeRange.isValueType();
	    };
	    Property.prototype.isRequired = function () {
	        return this._isRequired;
	    };
	    Property.prototype.isMultiValue = function () {
	        if (this.range() && this.range() instanceof Array) {
	            return true;
	        }
	        return this._isMultiValue;
	    };
	    Property.prototype.isMerged = function () {
	        return this._groupName == null;
	    };
	    Property.prototype.isPrimitive = function () {
	        var name = this._nodeRange.name();
	        return name == 'StringType' || name == 'NumberType' || name == 'BooleanType';
	    };
	    Property.prototype.groupName = function () {
	        return this._groupName;
	    };
	    return Property;
	})(Described);
	exports.Property = Property;
	var Array = (function (_super) {
	    __extends(Array, _super);
	    function Array() {
	        _super.apply(this, arguments);
	    }
	    Array.prototype.isArray = function () {
	        return true;
	    };
	    Array.prototype.isUserDefined = function () {
	        return true;
	    };
	    Array.prototype.componentType = function () {
	        return this.component;
	    };
	    Array.prototype.findFacets = function (node, x) {
	        if (node) {
	            var chd = node.lowLevel().children();
	            var mi = _.find(chd, function (x) { return x.key() == "minItems"; });
	            if (mi) {
	                x[mi.key()] = mi;
	            }
	            var mi = _.find(chd, function (x) { return x.key() == "maxItems"; });
	            if (mi) {
	                x[mi.key()] = mi;
	            }
	            var mi = _.find(chd, function (x) { return x.key() == "uniqueItems"; });
	            if (mi) {
	                x[mi.key()] = mi;
	            }
	        }
	    };
	    Array.prototype.isValid = function (h, v, p) {
	        if (this.component) {
	            return this.component.isValid(h, v, p);
	        }
	        return true;
	    };
	    Array.prototype.toRuntime = function () {
	        var rs = new Array(this.name(), this.universe(), "");
	        rs._af = {};
	        var fs = this.getFixedFacets();
	        for (var i in fs) {
	            rs._af[i] = fs[i];
	        }
	        rs._representationOf = this;
	        rs.component = this.component ? this.component.toRuntime() : this.component;
	        rs.dimensions = this.dimensions;
	        return rs;
	    };
	    return Array;
	})(NodeClass);
	exports.Array = Array;
	var ExternalType = (function (_super) {
	    __extends(ExternalType, _super);
	    function ExternalType() {
	        _super.apply(this, arguments);
	    }
	    ExternalType.prototype.isUserDefined = function () {
	        return true;
	    };
	    return ExternalType;
	})(NodeClass);
	exports.ExternalType = ExternalType;
	var Union = (function (_super) {
	    __extends(Union, _super);
	    function Union() {
	        _super.apply(this, arguments);
	    }
	    Union.prototype.leftType = function () {
	        return this.left;
	    };
	    Union.prototype.rightType = function () {
	        return this.right;
	    };
	    Union.prototype.isUserDefined = function () {
	        return true;
	    };
	    Union.prototype.toRuntime = function () {
	        return this;
	    };
	    Union.prototype.union = function () {
	        return this;
	    };
	    Union.prototype.isUnion = function () {
	        return true;
	    };
	    Union.prototype.isArray = function () {
	        if (this.left && this.right) {
	            return this.left.isArray() || this.right.isArray();
	        }
	        if (this.left) {
	            return this.left.isArray();
	        }
	        if (this.right) {
	            return this.right.isArray();
	        }
	    };
	    return Union;
	})(NodeClass);
	exports.Union = Union;
	var UserDefinedProp = (function (_super) {
	    __extends(UserDefinedProp, _super);
	    function UserDefinedProp() {
	        _super.apply(this, arguments);
	    }
	    UserDefinedProp.prototype.node = function () {
	        return this._node;
	    };
	    return UserDefinedProp;
	})(Property);
	exports.UserDefinedProp = UserDefinedProp;
	//# sourceMappingURL=definitionSystem.js.map

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	var __extends = this.__extends || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var tsutil = __webpack_require__(23);
	var _ = __webpack_require__(47);
	var assert = __webpack_require__(74);
	var Opt = __webpack_require__(5);
	exports.MODEL_CLASS_MODEL_ELEMENT = '$resource-model-element';
	exports.MODEL_CLASS_TYPE_DECLARATION = '$type-declaration';
	exports.MODEL_CLASS_INTERFACE = '$interface-declaration';
	exports.MODEL_CLASS_CLASS_DECLARATION = '$class-declaration';
	exports.MODEL_CLASS_ANNOTATION_DECLARATION = '$annotation-declaration';
	exports.MODEL_CLASS_ENUM_DECLARATION = '$enum-declaration';
	exports.MODEL_CLASS_TYPE_ASSERTION = '$type-assertion';
	exports.MODEL_CLASS_API_MODULE = '$api-module';
	exports.MODEL_CLASS_UNIVERSE = '$universe';
	exports.MODEL_CLASS_MEMBER = '$member';
	exports.MODEL_CLASS_UNION_TYPE_REFERENCE = '$union-type-reference';
	exports.MODEL_CLASS_SIMPLE_TYPE_REFERENCE = '$simple-type-reference';
	exports.MODEL_CLASS_FUNCTION_REFERENCE = '$function-reference';
	exports.MODEL_CLASS_ARRAY_REFERENCE = '$array-reference';
	exports.MODEL_CLASS_DECLARED_INTERFACE_REFERENCE = '$declared-interface-reference';
	exports.MODEL_CLASS_ANY_TYPE_REFERENCE = '$any-type-reference';
	exports.MODEL_CLASS_STRUCTURAL_TYPE_REFERENCE = '$structural-type-reference';
	exports.MODEL_CLASS_PARAM = '$param';
	exports.MODEL_CLASS_STRING_VALUE = '$string-value';
	exports.MODEL_CLASS_ARRAY_VALUE = '$array-value';
	exports.MODEL_CLASS_API_ELEMENT_DECLARATION = '$api-element-declaration';
	exports.MODEL_CLASS_CONSTRUCTOR = '$constructor';
	//TODO HIDE Fields from unmanagable modification
	//TODO Refine type decl type ref hieararchy a bit more
	//TODO add classes, generics, metadata
	var TSModelElement = (function () {
	    function TSModelElement(parent, config) {
	        if (parent === void 0) { parent = exports.Universe; }
	        this.meta = {};
	        this._annotations = [];
	        this._parent = parent;
	        this._config = config ? config : parent._config;
	        this._children = [];
	        assert(parent, "Should never be null");
	        this._parent.addChild(this);
	    }
	    TSModelElement.prototype.annotations = function () {
	        return this._annotations;
	    };
	    TSModelElement.prototype.patchParent = function (parent) {
	        this._parent = parent; //FIXME
	    };
	    TSModelElement.prototype.isEmpty = function () {
	        return this._children.length == 0;
	    };
	    TSModelElement.prototype.parent = function () {
	        return this._parent;
	    };
	    TSModelElement.prototype.children = function () {
	        return this._children;
	    };
	    TSModelElement.prototype.root = function () {
	        if (this._parent == exports.Universe) {
	            return this;
	        }
	        return this._parent.root();
	    };
	    TSModelElement.prototype.removeChild = function (child) {
	        if (child._parent == this) {
	            this._children = this._children.filter(function (x) { return x != child; });
	        }
	        child._parent = exports.Universe;
	    };
	    TSModelElement.prototype.addChild = function (child) {
	        if (child._parent) {
	            child._parent.removeChild(child);
	        }
	        child._parent = this;
	        this._children.push(child);
	    };
	    TSModelElement.prototype.serializeToString = function () {
	        throw new Error("You should override serialize to string always");
	    };
	    TSModelElement.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_MODEL_ELEMENT;
	    };
	    return TSModelElement;
	})();
	exports.TSModelElement = TSModelElement;
	//TODO It should become an interface
	var TSTypeDeclaration = (function (_super) {
	    __extends(TSTypeDeclaration, _super);
	    function TSTypeDeclaration(parent) {
	        var _this = this;
	        if (parent === void 0) { parent = null; }
	        _super.call(this, parent);
	        this.canBeOmmited = function () { return _this.locked ? false : _this.children().every(function (x) { return x.optional; }); };
	        this.locked = false;
	        this.extras = [""];
	    }
	    TSTypeDeclaration.prototype.addCode = function (code) {
	        this.extras.push(code);
	    };
	    TSTypeDeclaration.prototype.toReference = function () {
	        throw new Error("Implement in subclasses");
	    };
	    TSTypeDeclaration.prototype.hash = function () {
	        return this.serializeToString();
	    };
	    TSTypeDeclaration.prototype.isFunctor = function () {
	        return this.children().some(function (x) { return x.isAnonymousFunction(); });
	    };
	    TSTypeDeclaration.prototype.getFunctor = function () {
	        return _.find(this.children(), function (x) { return x.isAnonymousFunction(); });
	    };
	    TSTypeDeclaration.prototype.visit = function (v) {
	        if (v.startTypeDeclaration(this)) {
	            this.children().forEach(function (x, i, arr) {
	                x.visit(v);
	                if (i != arr.length - 1)
	                    v.betweenElements();
	            });
	            v.endTypeDeclaration(this);
	        }
	    };
	    TSTypeDeclaration.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_TYPE_DECLARATION;
	    };
	    return TSTypeDeclaration;
	})(TSModelElement);
	exports.TSTypeDeclaration = TSTypeDeclaration;
	var TSInterface = (function (_super) {
	    __extends(TSInterface, _super);
	    function TSInterface(p, name) {
	        _super.call(this, p);
	        this.extends = [];
	        this.implements = [];
	        this.name = name;
	    }
	    TSInterface.prototype.hash = function () {
	        return this.children().filter(function (x) { return !x.isPrivate; }).map(function (x) { return "\n" + x.serializeToString() + "\n"; }).join('');
	    };
	    TSInterface.prototype.toReference = function () {
	        return new TSDeclaredInterfaceReference(exports.Universe, this.name, this);
	    };
	    TSInterface.prototype.decl = function () {
	        return "interface";
	    };
	    TSInterface.prototype.serializeToString = function () {
	        var body = this.hash();
	        return "export " + this.decl() + " " + this.name.concat(this.extendsString() + this.implementsString()) + "{" + this.extras.join("\n") + body + "}\n";
	    };
	    TSInterface.prototype.extendsString = function () {
	        if (this.extends.length > 0) {
	            return " extends " + this.extends.map(function (x) { return x.serializeToString(); }).join(",");
	        }
	        return "";
	    };
	    TSInterface.prototype.implementsString = function () {
	        if (this.implements.length > 0) {
	            return " implements " + this.implements.map(function (x) { return x.serializeToString(); }).join(",");
	        }
	        return "";
	    };
	    TSInterface.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_INTERFACE;
	    };
	    return TSInterface;
	})(TSTypeDeclaration);
	exports.TSInterface = TSInterface;
	//TODO INCORRECT INHERITANCE CHAIN
	var TSClassDecl = (function (_super) {
	    __extends(TSClassDecl, _super);
	    function TSClassDecl() {
	        _super.apply(this, arguments);
	    }
	    TSClassDecl.prototype.decl = function () {
	        return "class";
	    };
	    TSClassDecl.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_CLASS_DECLARATION;
	    };
	    return TSClassDecl;
	})(TSInterface);
	exports.TSClassDecl = TSClassDecl;
	var TSAnnotationDecl = (function (_super) {
	    __extends(TSAnnotationDecl, _super);
	    function TSAnnotationDecl() {
	        _super.apply(this, arguments);
	    }
	    TSAnnotationDecl.prototype.decl = function () {
	        return "annotation";
	    };
	    TSAnnotationDecl.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_ANNOTATION_DECLARATION;
	    };
	    TSAnnotationDecl.prototype.toReference = function () {
	        return new TSDeclaredAnnotationReference(exports.Universe, this.name, this);
	    };
	    return TSAnnotationDecl;
	})(TSInterface);
	exports.TSAnnotationDecl = TSAnnotationDecl;
	var TSEnumDecl = (function (_super) {
	    __extends(TSEnumDecl, _super);
	    function TSEnumDecl() {
	        _super.apply(this, arguments);
	    }
	    TSEnumDecl.prototype.decl = function () {
	        return "enum";
	    };
	    TSEnumDecl.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_ENUM_DECLARATION;
	    };
	    return TSEnumDecl;
	})(TSInterface);
	exports.TSEnumDecl = TSEnumDecl;
	var TSTypeAssertion = (function (_super) {
	    __extends(TSTypeAssertion, _super);
	    function TSTypeAssertion(p, _name, _ref) {
	        _super.call(this, p);
	        this._name = _name;
	        this._ref = _ref;
	    }
	    TSTypeAssertion.prototype.toReference = function () {
	        return new TSSimpleTypeReference(exports.Universe, this._name);
	    };
	    TSTypeAssertion.prototype.serializeToString = function () {
	        return "export type " + this._name + "=" + this._ref.serializeToString() + "\n";
	    };
	    TSTypeAssertion.prototype.ref = function () {
	        return this._ref;
	    };
	    TSTypeAssertion.prototype.name = function () {
	        return this._name;
	    };
	    TSTypeAssertion.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_TYPE_ASSERTION;
	    };
	    return TSTypeAssertion;
	})(TSTypeDeclaration);
	exports.TSTypeAssertion = TSTypeAssertion;
	var TSUniverse = (function (_super) {
	    __extends(TSUniverse, _super);
	    function TSUniverse() {
	        _super.call(this, this);
	    }
	    TSUniverse.prototype.addChild = function (child) {
	    };
	    TSUniverse.prototype.setConfig = function (cfg) {
	        this._config = cfg;
	    };
	    TSUniverse.prototype.getConfig = function () {
	        return this._config;
	    };
	    TSUniverse.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_UNIVERSE;
	    };
	    return TSUniverse;
	})(TSModelElement);
	exports.TSUniverse = TSUniverse;
	exports.Universe = new TSUniverse();
	var TSAPIModule = (function (_super) {
	    __extends(TSAPIModule, _super);
	    function TSAPIModule() {
	        _super.apply(this, arguments);
	    }
	    TSAPIModule.prototype.getInterface = function (nm) {
	        return new Opt(_.find(this.children(), function (x) { return x.name == nm; }));
	    };
	    TSAPIModule.prototype.serializeToString = function () {
	        var typeMap = {};
	        this.children().forEach(function (x) { return typeMap[x.name] = x; });
	        var covered = {};
	        var sorted = [];
	        var append = function (t) {
	            if (covered[t.name]) {
	                return;
	            }
	            covered[t.name] = true;
	            var refs = t.extends;
	            refs.forEach(function (ref) {
	                if (ref instanceof TSSimpleTypeReference) {
	                    var name = ref.name;
	                    var st = typeMap[name];
	                    if (st) {
	                        append(st);
	                    }
	                }
	            });
	            sorted.push(t);
	        };
	        this.children().forEach(function (x) { return append(x); });
	        return sorted.map(function (x) { return x.serializeToString(); }).join("\n");
	    };
	    TSAPIModule.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_API_MODULE;
	    };
	    return TSAPIModule;
	})(TSModelElement);
	exports.TSAPIModule = TSAPIModule;
	var TSMember = (function (_super) {
	    __extends(TSMember, _super);
	    function TSMember() {
	        _super.apply(this, arguments);
	    }
	    TSMember.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_MEMBER;
	    };
	    return TSMember;
	})(TSModelElement);
	exports.TSMember = TSMember;
	var TSUnionTypeReference = (function (_super) {
	    __extends(TSUnionTypeReference, _super);
	    function TSUnionTypeReference() {
	        _super.apply(this, arguments);
	        this.array = function () { return false; };
	    }
	    TSUnionTypeReference.prototype.getFunctor = function () {
	        return null;
	    };
	    //TODO FIXIT FIX IT WITH MIX IN
	    TSUnionTypeReference.prototype.union = function (q) {
	        var map = {};
	        this.children().filter(function (x) { return x instanceof TSSimpleTypeReference; }).forEach(function (x) { return map[x.name] = true; });
	        var gotNew = false;
	        var flat = flattenUnionType(q);
	        flat.forEach(function (x) {
	            if (x instanceof TSSimpleTypeReference) {
	                gotNew = gotNew || !map[q.name];
	            }
	            else {
	                gotNew = true;
	            }
	        });
	        if (!gotNew) {
	            return this;
	        }
	        var r = new TSUnionTypeReference();
	        this.children().forEach(function (x) { return r.addChild(x); });
	        flat.forEach(function (x) { return r.addChild(x); });
	        return r;
	    };
	    TSUnionTypeReference.prototype.isFunctor = function () {
	        return false;
	    };
	    TSUnionTypeReference.prototype.canBeOmmited = function () {
	        return false;
	    };
	    TSUnionTypeReference.prototype.serializeToString = function () {
	        return this.children().map(function (x) { return x.serializeToString(); }).join(" | ");
	    };
	    TSUnionTypeReference.prototype.removeChild = function (child) {
	    };
	    TSUnionTypeReference.prototype.addChild = function (child) {
	        this.children().push(child);
	    };
	    TSUnionTypeReference.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_UNION_TYPE_REFERENCE;
	    };
	    return TSUnionTypeReference;
	})(TSModelElement);
	exports.TSUnionTypeReference = TSUnionTypeReference;
	var TSSimpleTypeReference = (function (_super) {
	    __extends(TSSimpleTypeReference, _super);
	    function TSSimpleTypeReference(p, tn) {
	        var _this = this;
	        _super.call(this, p);
	        this.array = function () { return false; };
	        this.genericStr = function () { return _this.typeParameters && _this.typeParameters.length > 0 ? '<' + _this.typeParameters.map(function (p) { return p.serializeToString(); }).join(',') + '>' : ''; };
	        this.name = tn;
	    }
	    TSSimpleTypeReference.prototype.isEmpty = function () {
	        return false;
	    };
	    TSSimpleTypeReference.prototype.getFunctor = function () {
	        return null;
	    };
	    TSSimpleTypeReference.prototype.canBeOmmited = function () {
	        return false;
	    };
	    TSSimpleTypeReference.prototype.isFunctor = function () {
	        return false;
	    };
	    TSSimpleTypeReference.prototype.union = function (q) {
	        var _this = this;
	        var flat = flattenUnionType(q);
	        var gotThis = false;
	        flat.filter(function (x) { return x instanceof TSSimpleTypeReference; }).map(function (x) { return x; }).forEach(function (x) { return gotThis = gotThis || (x.name == _this.name); });
	        if (gotThis) {
	            return q;
	        }
	        var r = new TSUnionTypeReference();
	        r.addChild(this);
	        flat.forEach(function (x) { return r.addChild(x); });
	        return r;
	    };
	    TSSimpleTypeReference.prototype.serializeToString = function () {
	        return this.name + this.genericStr();
	    };
	    TSSimpleTypeReference.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_SIMPLE_TYPE_REFERENCE;
	    };
	    return TSSimpleTypeReference;
	})(TSModelElement);
	exports.TSSimpleTypeReference = TSSimpleTypeReference;
	var TSFunctionReference = (function (_super) {
	    __extends(TSFunctionReference, _super);
	    function TSFunctionReference(p) {
	        var _this = this;
	        _super.call(this, p);
	        this.rangeType = new AnyType();
	        this.parameters = [];
	        this.array = function () { return false; };
	        this.paramStr = function (appendDefault) {
	            if (appendDefault === void 0) { appendDefault = false; }
	            return '(' + _this.parameters.filter(function (x) { return !x.isEmpty(); }).map(function (p) { return p.serializeToString(appendDefault); }).join(', ') + ')';
	        };
	    }
	    TSFunctionReference.prototype.isEmpty = function () {
	        return false;
	    };
	    TSFunctionReference.prototype.getFunctor = function () {
	        return null;
	    };
	    TSFunctionReference.prototype.canBeOmmited = function () {
	        return false;
	    };
	    TSFunctionReference.prototype.isFunctor = function () {
	        return true;
	    };
	    TSFunctionReference.prototype.union = function (q) {
	        var r = new TSUnionTypeReference();
	        r.addChild(this);
	        r.addChild(q);
	        return r;
	    };
	    TSFunctionReference.prototype.serializeToString = function () {
	        return this.paramStr() + '=>' + this.rangeType.serializeToString();
	    };
	    TSFunctionReference.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_FUNCTION_REFERENCE;
	    };
	    return TSFunctionReference;
	})(TSModelElement);
	exports.TSFunctionReference = TSFunctionReference;
	var TSArrayReference = (function (_super) {
	    __extends(TSArrayReference, _super);
	    function TSArrayReference(componentType) {
	        if (componentType === void 0) { componentType = new AnyType(); }
	        _super.call(this, exports.Universe);
	        this.array = function () { return true; };
	        this.componentType = componentType;
	    }
	    TSArrayReference.prototype.isEmpty = function () {
	        return this.componentType ? true : false;
	    };
	    TSArrayReference.prototype.getFunctor = function () {
	        return this.componentType.getFunctor();
	    };
	    TSArrayReference.prototype.canBeOmmited = function () {
	        return false;
	    };
	    TSArrayReference.prototype.isFunctor = function () {
	        return this.componentType.isFunctor();
	    };
	    TSArrayReference.prototype.union = function (q) {
	        var r = new TSUnionTypeReference();
	        r.addChild(this);
	        r.addChild(q);
	        return r;
	    };
	    TSArrayReference.prototype.serializeToString = function () {
	        return this.componentType.serializeToString() + '[]';
	    };
	    TSArrayReference.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_ARRAY_REFERENCE;
	    };
	    return TSArrayReference;
	})(TSModelElement);
	exports.TSArrayReference = TSArrayReference;
	var TSDeclaredInterfaceReference = (function (_super) {
	    __extends(TSDeclaredInterfaceReference, _super);
	    function TSDeclaredInterfaceReference(p, tn, _data) {
	        _super.call(this, p, tn);
	        this._data = _data;
	    }
	    TSDeclaredInterfaceReference.prototype.isEmpty = function () {
	        return false;
	    };
	    TSDeclaredInterfaceReference.prototype.getFunctor = function () {
	        return null;
	    };
	    TSDeclaredInterfaceReference.prototype.canBeOmmited = function () {
	        return false;
	    };
	    TSDeclaredInterfaceReference.prototype.getOriginal = function () {
	        return this._data;
	    };
	    TSDeclaredInterfaceReference.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_DECLARED_INTERFACE_REFERENCE;
	    };
	    return TSDeclaredInterfaceReference;
	})(TSSimpleTypeReference);
	exports.TSDeclaredInterfaceReference = TSDeclaredInterfaceReference;
	var TSAnnotationReference = (function (_super) {
	    __extends(TSAnnotationReference, _super);
	    function TSAnnotationReference(p, tn, values) {
	        if (values === void 0) { values = {}; }
	        _super.call(this, p, tn);
	        this.values = values;
	    }
	    TSAnnotationReference.prototype.value = function (key) {
	        if (key === void 0) { key = 'value'; }
	        return this.values[key];
	    };
	    return TSAnnotationReference;
	})(TSSimpleTypeReference);
	exports.TSAnnotationReference = TSAnnotationReference;
	var TSDeclaredAnnotationReference = (function (_super) {
	    __extends(TSDeclaredAnnotationReference, _super);
	    function TSDeclaredAnnotationReference() {
	        _super.apply(this, arguments);
	        this.values = {};
	    }
	    TSDeclaredAnnotationReference.prototype.value = function (key) {
	        if (key === void 0) { key = 'value'; }
	        return this.values[key];
	    };
	    return TSDeclaredAnnotationReference;
	})(TSDeclaredInterfaceReference);
	exports.TSDeclaredAnnotationReference = TSDeclaredAnnotationReference;
	var AnyType = (function (_super) {
	    __extends(AnyType, _super);
	    function AnyType(nm) {
	        if (nm === void 0) { nm = "any"; }
	        _super.call(this, exports.Universe, nm);
	    }
	    AnyType.prototype.union = function (q) {
	        return q;
	    };
	    AnyType.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_ANY_TYPE_REFERENCE;
	    };
	    return AnyType;
	})(TSSimpleTypeReference);
	exports.AnyType = AnyType;
	var TSStructuralTypeReference = (function (_super) {
	    __extends(TSStructuralTypeReference, _super);
	    function TSStructuralTypeReference(parent) {
	        var _this = this;
	        if (parent === void 0) { parent = exports.Universe; }
	        _super.call(this, parent);
	        this.array = function () { return false; };
	        this.canBeOmmited = function () { return _this.locked ? false : _this.children().every(function (x) { return x.optional; }); };
	    }
	    TSStructuralTypeReference.prototype.visitReturnType = function (v) {
	        //v.visitStructuralReturn(this);
	        this.visit(v);
	    };
	    TSStructuralTypeReference.prototype.toReference = function () {
	        return this;
	    };
	    TSStructuralTypeReference.prototype.union = function (q) {
	        var r = new TSUnionTypeReference();
	        r.addChild(this);
	        r.addChild(q);
	        return r;
	    };
	    TSStructuralTypeReference.prototype.serializeToString = function () {
	        var body = this.children().map(function (x) { return ("\n" + x.serializeToString() + "\n"); }).join('');
	        return "{" + body + "}";
	    };
	    TSStructuralTypeReference.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_STRUCTURAL_TYPE_REFERENCE;
	    };
	    return TSStructuralTypeReference;
	})(TSTypeDeclaration);
	exports.TSStructuralTypeReference = TSStructuralTypeReference;
	(function (ParamLocation) {
	    ParamLocation[ParamLocation["URI"] = 0] = "URI";
	    ParamLocation[ParamLocation["BODY"] = 1] = "BODY";
	    ParamLocation[ParamLocation["OPTIONS"] = 2] = "OPTIONS";
	    ParamLocation[ParamLocation["OTHER"] = 3] = "OTHER";
	})(exports.ParamLocation || (exports.ParamLocation = {}));
	var ParamLocation = exports.ParamLocation;
	var Param = (function (_super) {
	    __extends(Param, _super);
	    function Param(p, nm, location, tp, defaultValue) {
	        if (tp === void 0) { tp = new TSSimpleTypeReference(exports.Universe, "string"); }
	        _super.call(this, p);
	        this.name = nm;
	        this.ptype = tp;
	        this.location = location;
	        this.defaultValue = defaultValue;
	    }
	    Param.prototype.isEmpty = function () {
	        return this.ptype.isEmpty();
	    };
	    Param.prototype.serializeToString = function (appendDefault) {
	        if (appendDefault === void 0) { appendDefault = false; }
	        //return this.name + (this.optional ? "?" : "") + ":" + this.ptype.serializeToString() + (this.ptype.canBeOmmited() ? "?" : "");
	        return this.name + (this.optional || (this.defaultValue && !appendDefault) ? "?" : "") + (":" + this.ptype.serializeToString() + (this.ptype.canBeOmmited() ? "?" : "")) + (appendDefault && this.defaultValue ? '=' + JSON.stringify(this.defaultValue) : '');
	    };
	    Param.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_PARAM;
	    };
	    return Param;
	})(TSModelElement);
	exports.Param = Param;
	var StringValue = (function (_super) {
	    __extends(StringValue, _super);
	    function StringValue(_value) {
	        _super.call(this);
	        this._value = _value;
	    }
	    StringValue.prototype.value = function () {
	        return this._value;
	    };
	    StringValue.prototype.serializeToString = function () {
	        return "\"" + this._value + "\"";
	    };
	    StringValue.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_STRING_VALUE;
	    };
	    return StringValue;
	})(TSMember);
	exports.StringValue = StringValue;
	var ArrayValue = (function (_super) {
	    __extends(ArrayValue, _super);
	    function ArrayValue(_values) {
	        _super.call(this);
	        this._values = _values;
	    }
	    ArrayValue.prototype.value = function () {
	        return this.serializeToString();
	    };
	    ArrayValue.prototype.serializeToString = function () {
	        return "[ " + this._values.map(function (x) { return x.value(); }).join(', ') + " ]";
	    };
	    ArrayValue.prototype.values = function () {
	        return this._values;
	    };
	    ArrayValue.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_ARRAY_VALUE;
	    };
	    return ArrayValue;
	})(TSMember);
	exports.ArrayValue = ArrayValue;
	var TSAPIElementDeclaration = (function (_super) {
	    __extends(TSAPIElementDeclaration, _super);
	    function TSAPIElementDeclaration(p, name) {
	        var _this = this;
	        _super.call(this, p);
	        this.rangeType = new AnyType();
	        this.value = null;
	        this.paramStr = function (appendDefault) {
	            if (appendDefault === void 0) { appendDefault = false; }
	            return '( ' + _this.parameters.filter(function (x) { return !x.isEmpty(); }).map(function (p) { return _this.serializeParam(p, appendDefault); }).join(',') + ' )';
	        };
	        this.serializeParam = function (p, appendDefault) { return p.serializeToString(appendDefault); };
	        this.isFunction = function () { return _this.parameters.length != 0 || _this.isFunc; };
	        this.isAnonymousFunction = function () { return _this.isFunction() && _this.name === ''; };
	        this.returnStr = function () { return _this.rangeType ? ':' + _this.rangeType.serializeToString() : ''; };
	        this.name = name;
	        this.parameters = [];
	        this.rangeType = null;
	        this.optional = false;
	    }
	    TSAPIElementDeclaration.prototype.visit = function (v) {
	        if (v.startVisitElement(this)) {
	            if (this.rangeType) {
	                if (this.rangeType instanceof TSStructuralTypeReference && !this.isInterfaceMethodWithBody()) {
	                    this.rangeType.visitReturnType(v);
	                }
	            }
	            v.endVisitElement(this);
	        }
	    };
	    TSAPIElementDeclaration.prototype.commentCode = function () {
	        return "\n        /**\n         *\n         **/\n         //" + this.name + "\n         ";
	    };
	    TSAPIElementDeclaration.prototype.serializeToString = function () {
	        var x = (this.isPrivate ? 'private ' : '') + this.escapeDot(this.name) + (this.optional ? "?" : "") + (this.isFunction() ? this.paramStr() : "") + this.returnStr();
	        if (this.value) {
	            x += '=' + this.value.value();
	        }
	        return this.commentCode() + x + (this.isFunction() && this.isInterfaceMethodWithBody() ? '' : this.body());
	    };
	    TSAPIElementDeclaration.prototype.body = function () {
	        if (this._body == null)
	            return "";
	        return "{" + this._body + "}";
	    };
	    TSAPIElementDeclaration.prototype.escapeDot = function (name) {
	        return tsutil.escapeTypescriptPropertyName(name);
	    };
	    TSAPIElementDeclaration.prototype.isInterfaceMethodWithBody = function () {
	        return false;
	    };
	    TSAPIElementDeclaration.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_API_ELEMENT_DECLARATION;
	    };
	    return TSAPIElementDeclaration;
	})(TSMember);
	exports.TSAPIElementDeclaration = TSAPIElementDeclaration;
	var TSConstructor = (function (_super) {
	    __extends(TSConstructor, _super);
	    function TSConstructor(p) {
	        _super.call(this, p, 'constructor');
	        this.serializeParam = function (p, appendDefault) { return 'protected ' + p.serializeToString(appendDefault); };
	    }
	    TSConstructor.prototype.modelClass = function () {
	        return exports.MODEL_CLASS_CONSTRUCTOR;
	    };
	    return TSConstructor;
	})(TSAPIElementDeclaration);
	exports.TSConstructor = TSConstructor;
	function flattenUnionType(ref) {
	    var _this = this;
	    if (!(ref instanceof TSUnionTypeReference)) {
	        return [ref];
	    }
	    var map = {};
	    var arr = [];
	    ref.children().forEach(function (x) { return _this.flattenUnionType(x).forEach(function (y) {
	        if (y instanceof TSSimpleTypeReference) {
	            var st = y;
	            var name = st.name;
	            map[name] = st;
	        }
	        else {
	            arr.push(y);
	        }
	    }); });
	    return arr.concat(_.sortBy(Object.keys(map).map(function (x) { return map[x]; }), 'name'));
	}
	//# sourceMappingURL=TSDeclModel.js.map

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	var ts = __webpack_require__(42);
	// https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API
	function escapeTypescriptPropertyName(str) {
	    return isValidTypescriptIdentifier(str) ? str : JSON.stringify(str);
	}
	exports.escapeTypescriptPropertyName = escapeTypescriptPropertyName;
	// TODO: these are made up lists. check the grammar
	var tsKeywords = 'type class interface break case catch continue debugger default delete do else finally for function if in instanceof new return switch this throw try typeof var void while with'.split(' ');
	var digitCodesL = "0".charCodeAt(0);
	var digitCodesR = "9".charCodeAt(0);
	var lowerCaseCodesL = "a".charCodeAt(0);
	var lowerCaseCodesR = "z".charCodeAt(0);
	var upperCaseCodesL = "A".charCodeAt(0);
	var upperCaseCodesR = "Z".charCodeAt(0);
	var digitChars = {}; //:boolean[] = []
	var validChars = {}; //:boolean[] = []
	for (var i = digitCodesL, end = digitCodesR; i <= end; i++) {
	    digitChars[String.fromCharCode(i)] = true;
	    validChars[String.fromCharCode(i)] = true;
	}
	for (var i = lowerCaseCodesL, end = lowerCaseCodesR; i <= end; i++) {
	    validChars[String.fromCharCode(i)] = true;
	}
	for (var i = upperCaseCodesL, end = upperCaseCodesR; i <= end; i++) {
	    validChars[String.fromCharCode(i)] = true;
	}
	"_ $".split(" ").forEach(function (x) { return validChars[x] = true; });
	function isValidTypescriptIdentifier(str) {
	    str = str.trim();
	    if (str.length == 0) {
	        return false;
	    }
	    if (tsKeywords.indexOf(str) >= 0) {
	        return false;
	    }
	    if (digitChars[str.charAt(0)]) {
	        return false;
	    }
	    for (var i = 0; i < str.length; i++) {
	        if (!validChars[str.charAt(i)]) {
	            return false;
	        }
	    }
	    return true;
	}
	exports.isValidTypescriptIdentifier = isValidTypescriptIdentifier;
	function escapeToIdentifier(str) {
	    str = str.trim();
	    var result = '';
	    if (str.length > 0 && digitChars[str.charAt(0)]) {
	        result += '_';
	    }
	    for (var i = 0; i < str.length; i++) {
	        var ch = str.charAt(i);
	        if (validChars[ch]) {
	            result += ch;
	        }
	        else {
	            result += '_';
	        }
	    }
	    return result;
	}
	exports.escapeToIdentifier = escapeToIdentifier;
	// Note: this uses ts.formatting which is part of the typescript 1.4 package but is not currently
	//       exposed in the public typescript.d.ts. The typings should be exposed in the next release.
	function format(text) {
	    var options = getDefaultOptions();
	    // Parse the source text
	    var sourceFile = ts.createSourceFile("file.ts", text, 2 /* Latest */, "0");
	    fixupParentReferences(sourceFile);
	    // Get the formatting edits on the input sources
	    var edits = ts.formatting.formatDocument(sourceFile, getRuleProvider(options), options);
	    // Apply the edits on the input code
	    return applyEdits(text, edits);
	    function getRuleProvider(options) {
	        // Share this between multiple formatters using the same options.
	        // This represents the bulk of the space the formatter uses.
	        var ruleProvider = new ts.formatting.RulesProvider();
	        ruleProvider.ensureUpToDate(options);
	        return ruleProvider;
	    }
	    function applyEdits(text, edits) {
	        // Apply edits in reverse on the existing text
	        var result = text;
	        for (var i = edits.length - 1; i >= 0; i--) {
	            var change = edits[i];
	            var head = result.slice(0, change.span.start());
	            var tail = result.slice(change.span.start() + change.span.length());
	            result = head + change.newText + tail;
	        }
	        return result;
	    }
	    function getDefaultOptions() {
	        return {
	            IndentSize: 4,
	            TabSize: 4,
	            NewLineCharacter: '\n',
	            ConvertTabsToSpaces: true,
	            InsertSpaceAfterCommaDelimiter: true,
	            InsertSpaceAfterSemicolonInForStatements: true,
	            InsertSpaceBeforeAndAfterBinaryOperators: true,
	            InsertSpaceAfterKeywordsInControlFlowStatements: true,
	            InsertSpaceAfterFunctionKeywordForAnonymousFunctions: false,
	            InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: false,
	            PlaceOpenBraceOnNewLineForFunctions: false,
	            PlaceOpenBraceOnNewLineForControlBlocks: false
	        };
	    }
	    function fixupParentReferences(sourceFile) {
	        var parent = sourceFile;
	        function walk(n) {
	            n.parent = parent;
	            var saveParent = parent;
	            parent = n;
	            ts.forEachChild(n, walk);
	            parent = saveParent;
	        }
	        ts.forEachChild(sourceFile, walk);
	    }
	}
	exports.format = format;
	var typeMap = {
	    'string': 'string',
	    'integer': 'number',
	    'number': 'number',
	    'boolean': 'boolean',
	    'file': 'string',
	    'date': 'string',
	    'NumberType': 'number'
	};
	function ramlType2TSType(ramlType) {
	    var tsType = typeMap[ramlType];
	    if (!tsType) {
	        tsType = 'any';
	    }
	    return tsType;
	}
	exports.ramlType2TSType = ramlType2TSType;
	function escapeToJavaIdentifier(str) {
	    str = escapeToIdentifier(str);
	    return exports.javaReservedWords[str] ? str + '_' : str;
	}
	exports.escapeToJavaIdentifier = escapeToJavaIdentifier;
	exports.tsToJavaTypeMap = {
	    'number': 'Double',
	    'string': 'String',
	    'boolean': 'Boolean',
	    'any': 'Object'
	};
	exports.javaReservedWords = {
	    "abstract": true,
	    "continue": true,
	    "for": true,
	    "new": true,
	    "switch": true,
	    "assert": true,
	    "default": true,
	    "goto": true,
	    "package": true,
	    "synchronized": true,
	    "boolean": true,
	    "do": true,
	    "if": true,
	    "private": true,
	    "this": true,
	    "break": true,
	    "double": true,
	    "implements": true,
	    "protected": true,
	    "throw": true,
	    "byte": true,
	    "else": true,
	    "import": true,
	    "public": true,
	    "throws": true,
	    "case": true,
	    "enum": true,
	    "instanceof": true,
	    "return": true,
	    "transient": true,
	    "catch": true,
	    "extends": true,
	    "int": true,
	    "short": true,
	    "try": true,
	    "char": true,
	    "final": true,
	    "interface": true,
	    "static": true,
	    "void": true,
	    "class": true,
	    "finally": true,
	    "long": true,
	    "strictfp": true,
	    "volatile": true,
	    "const": true,
	    "float": true,
	    "native": true,
	    "super": true,
	    "while": true
	};
	//# sourceMappingURL=tsutil.js.map

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(21);
	var td = __webpack_require__(22);
	var util = __webpack_require__(20);
	var parserCoreModuleVar = 'core';
	var ParserGenerator = (function () {
	    function ParserGenerator() {
	        this.mod = new td.TSAPIModule();
	        this.processed = {};
	        this.typeMap = {
	            'StringType': 'string',
	            'NumberType': 'number',
	            'BooleanType': 'boolean'
	        };
	    }
	    ParserGenerator.prototype.processType = function (u, generateConstructor) {
	        var _this = this;
	        var typeName = u.name();
	        if (this.processed[typeName]) {
	            return;
	        }
	        this.processed[typeName] = u;
	        u.superTypes().forEach(function (x) { return _this.processType(x, generateConstructor); });
	        var idcl = new td.TSInterface(this.mod, typeName);
	        var dcl = new td.TSClassDecl(this.mod, typeName + "Impl");
	        if (generateConstructor) {
	            var _constructor = new td.TSConstructor(dcl);
	            _constructor.parameters = [
	                new td.Param(_constructor, 'attr', 3 /* OTHER */, new td.TSSimpleTypeReference(td.Universe, 'hl.IAttribute'))
	            ];
	            if (u.isValueType()) {
	                if (typeName == 'ValueType' || u.superTypes().length == 0) {
	                    _constructor._body = '';
	                }
	                else {
	                    _constructor._body = 'super(attr);';
	                }
	            }
	            else {
	                _constructor._body = 'super()';
	            }
	        }
	        else {
	            if (u instanceof def.NodeClass) {
	                var _constructor = new td.TSConstructor(dcl);
	                _constructor.parameters = [
	                    new td.Param(_constructor, 'nodeOrKey', 3 /* OTHER */, new td.TSSimpleTypeReference(td.Universe, 'hl.IHighLevelNode|string'))
	                ];
	                _constructor._body = "super((typeof  nodeOrKey==\"string\")?create" + u.name() + "(<string>nodeOrKey):<hl.IHighLevelNode>nodeOrKey)";
	            }
	        }
	        this.addImplementationMethod(dcl, 'wrapperClassName', 'string', "return \"" + typeName + "Impl\";");
	        if (typeName == 'ValueType') {
	            this.addInterfaceMethod(idcl, 'value', 'string');
	            this.addImplementationMethod(dcl, 'value', 'string', 'return this.attr.value();');
	            this.addInterfaceMethod(idcl, 'highLevel', 'hl.IAttribute');
	            this.addImplementationMethod(dcl, 'highLevel', 'hl.IAttribute', 'return this.attr;');
	        }
	        else if (typeName == 'Reference') {
	            this.addImplementationMethod(dcl, 'value', 'string', 'return <any>core.toStructuredValue(this.attr);');
	        }
	        dcl.implements.push(new td.TSSimpleTypeReference(td.Universe, idcl.name));
	        u.superTypes().forEach(function (x) {
	            idcl.extends.push(new td.TSSimpleTypeReference(td.Universe, x.name()));
	            dcl.extends.push(new td.TSSimpleTypeReference(td.Universe, x.name() + "Impl"));
	        });
	        u.properties().forEach(function (x) {
	            _this.createMethodDecl(idcl, x);
	            var z = _this.createMethodDecl(dcl, x);
	            z._body = _this.generateBody(x);
	            if (x.isPrimitive()) {
	                _this.createSetterMethodDecl(dcl, x);
	            }
	        });
	        if (dcl.extends.length == 0) {
	            if (u.isValueType()) {
	                idcl.extends.push(new td.TSSimpleTypeReference(td.Universe, "core.AbstractWrapperNode"));
	            }
	            else {
	                idcl.extends.push(new td.TSSimpleTypeReference(td.Universe, "BasicNode"));
	                dcl.extends.push(new td.TSSimpleTypeReference(td.Universe, "BasicNodeImpl"));
	            }
	        }
	        u.subTypes().forEach(function (x) { return _this.processType(x); });
	    };
	    ParserGenerator.prototype.addInterfaceMethod = function (idcl, methodName, returnTypeName) {
	        var method = new td.TSAPIElementDeclaration(idcl, methodName);
	        method.isFunc = true;
	        method.rangeType = new td.TSSimpleTypeReference(method, returnTypeName);
	        return method;
	    };
	    ParserGenerator.prototype.addImplementationMethod = function (dcl, methodName, returnTypeName, body) {
	        var method = this.addInterfaceMethod(dcl, methodName, returnTypeName);
	        method._body = body;
	        return method;
	    };
	    ParserGenerator.prototype.generateBody = function (x) {
	        var rangeType = x.range().name();
	        if (x.isValueProperty()) {
	            var args = [("'" + x.name() + "'")];
	            if (x.isPrimitive()) {
	                rangeType = this.typeMap[rangeType];
	                args.push("this.to" + util.firstToUpper(rangeType));
	            }
	            else {
	                args.push("(attr:hl.IAttribute)=>new " + rangeType + "Impl(attr)");
	            }
	            if (x.isMultiValue()) {
	                return "\n             return <" + rangeType + "[]>super.attributes(" + args.join(', ') + ");\n         ";
	            }
	            else {
	                return "\n             return <" + rangeType + ">super.attribute(" + args.join(', ') + ");\n         ";
	            }
	        }
	        else {
	            if (x.isMultiValue()) {
	                return "\n             return <" + rangeType + "[]>super.elements('" + x.name() + "');\n         ";
	            }
	            else {
	                return "\n             return <" + rangeType + ">super.element('" + x.name() + "');\n         ";
	            }
	        }
	        //if (x.isValueProperty()){
	        //
	        //    var varInit:any;
	        //    if(x.isPrimitive()){
	        //        varInit = function(varStr:string,typeName:string){
	        //            return varStr + '.value()';
	        //        }
	        //    }
	        //    else{
	        //        varInit = function(varStr:string,typeName:string){
	        //            return 'new ' + typeName + 'Impl(' + varStr + ')';
	        //        }
	        //    }
	        //    if(x.isMultiValue()) {
	        //        return `var attrs = this._node.attributes('${x.name()}');
	        //        if (attrs) {
	        //            return attrs.map(x=>${varInit('x', x.range().name())});
	        //        }
	        //        return [];`;
	        //    }
	        //    else{
	        //        return `var attr = this._node.attr('${x.name()}');
	        //        if (attr) {
	        //            var v = ${varInit('attr', x.range().name())};
	        //            return v;
	        //        }
	        //        else {
	        //            return null;
	        //        }`;
	        //    }
	        //}
	        //else{
	        //    if (x.isMultiValue()){
	        //        return `
	        //        var elements = this._node.elementsOfKind('${x.name()}');
	        //        if(elements) {
	        //            return elements.map(x=><${x.range().name()}>x.wrapperNode());
	        //        }
	        //        else {
	        //            return null;
	        //        }
	        //    `;
	        //    }
	        //    else{
	        //        return `
	        //        var v = this._node.element('${x.name()}');
	        //        if(!v){
	        //            return null;
	        //        }
	        //        return <${x.range().name()}>v.wrapperNode();
	        //    `;
	        //    }
	        //}
	    };
	    ParserGenerator.prototype.createSetterMethodDecl = function (dcl, x) {
	        var method = new td.TSAPIElementDeclaration(dcl, "set" + x.name()[0].toUpperCase() + x.name().substr(1));
	        method.isFunc = true;
	        var tname = "string";
	        if (x.isPrimitive()) {
	            tname = this.typeMap[x.range().name()];
	        }
	        else {
	            tname = x.range().name();
	            this.processType(x.range(), x.isValueProperty());
	        }
	        var ref = new td.TSSimpleTypeReference(td.Universe, tname);
	        method.parameters = [
	            new td.Param(method, 'param', 3 /* OTHER */, ref)
	        ];
	        method._body = "\n        {\n        this.highLevel().attrOrCreate(\"" + x.name() + "\").setValue(\"\"+param);\n        return this;\n        }\n        ";
	        return method;
	    };
	    ParserGenerator.prototype.createMethodDecl = function (dcl, x) {
	        var method = new td.TSAPIElementDeclaration(dcl, x.name());
	        method.isFunc = true;
	        var tname = "string";
	        if (x.isPrimitive()) {
	            tname = this.typeMap[x.range().name()];
	        }
	        else {
	            tname = x.range().name();
	            this.processType(x.range(), x.isValueProperty());
	        }
	        var ref = new td.TSSimpleTypeReference(td.Universe, tname);
	        if (x.isMultiValue()) {
	            var aRef = new td.TSArrayReference();
	            aRef.componentType = ref;
	            method.rangeType = aRef;
	        }
	        else {
	            method.rangeType = ref;
	        }
	        return method;
	    };
	    ParserGenerator.prototype.serializeToString = function () {
	        return "import hl=require(\"../highLevelAST\");\nimport hlImpl=require(\"../highLevelImpl\");\nimport jsyaml=require(\"../jsyaml/jsyaml2lowLevel\");\nimport def=require(\"../definitionSystem\");\nimport core=require(\"../parserCore\");\n\n\nexport interface BasicNode extends core.BasicSuperNode{\n\n    parent():BasicNode\n\n    highLevel():hl.IHighLevelNode\n}\n\nexport class BasicNodeImpl extends core.BasicSuperNodeImpl implements BasicNode{\n\n    constructor(node:hl.IHighLevelNode){\n        super(node);\n    }\n\n    wrapperClassName():string{\n        return 'BasicNodeImpl';\n    }\n\n    parent():BasicNode{\n        return <BasicNode>super.parent();\n    }\n}\n\n        " + this.mod.serializeToString() + this.createFunctions();
	    };
	    ParserGenerator.prototype.createFunctions = function () {
	        var res = "";
	        for (var p in this.processed) {
	            var q = this.processed[p];
	            if (q instanceof def.NodeClass) {
	                res += "\nfunction create" + p + "(key:string){\n    var universe=hl.universeProvider(\"RAML10\");\n    var nc=<def.NodeClass>universe.getType(\"" + p + "\");\n    var node=nc.createStubNode(null,key);\n    return node;\n}\n";
	            }
	            ;
	        }
	        return res;
	    };
	    ParserGenerator.prototype.nodeFactory = function (highLevelASTLocation, parserLocation) {
	        return "import RamlWrapper = require(\"" + parserLocation + "\");\nimport hl = require(\"" + highLevelASTLocation + "\")\n\nexport function buildWrapperNode(node:hl.IHighLevelNode){\n\n    var nodeClassName = node.definition().name();\n\n    var wrapperConstructor = classMap[nodeClassName];\n\n    if(!wrapperConstructor){\n        var m=node.definition().allSuperTypes();\n        var wr=null;\n        for (var i=0;i<m.length;i++){\n            var nm=m[i].name();\n            wrapperConstructor = classMap[nm];\n            if (nm==\"DataElement\"){\n                wr=nm;\n                //This is only case of nested hierarchy\n                continue;\n            }\n            if (nm==\"RAMLLanguageElement\"){\n                //depth first\n                continue;\n            }\n            if (wrapperConstructor){\n                break;\n            }\n        }\n        if (!wrapperConstructor){\n            wr=nm;\n        }\n    }\n    if (!wrapperConstructor){\n        wrapperConstructor = classMap[\"RAMLLanguageElement\"]\n\n    }\n    return wrapperConstructor(node);\n}\n\nvar classMap = {\n\n" + Object.keys(this.processed).sort().map(function (x) { return ("    \"" + x + "\": (x)=>{return new RamlWrapper." + x + "Impl(x)}"); }).join(',\n\n') + "\n\n};\n";
	    };
	    return ParserGenerator;
	})();
	function def2Parser(u) {
	    var mod = new ParserGenerator();
	    mod.processType(u);
	    return mod;
	}
	exports.def2Parser = def2Parser;
	var ImplementationGenerator = (function () {
	    function ImplementationGenerator() {
	    }
	    ImplementationGenerator.prototype.generateASTAccessor = function (p) {
	        this.generatedCode.push("var val=this.ast.getValue(" + p.name() + "}");
	        this.generatedCode.push("return new " + p.range().name() + "Impl(val)");
	    };
	    return ImplementationGenerator;
	})();
	function checkIfReference(u) {
	    if (u.name() == 'Reference') {
	        return true;
	    }
	    var superTypes = u.superTypes();
	    for (var i = 0; i < superTypes.length; i++) {
	        var st = superTypes[i];
	        if (checkIfReference(st)) {
	            return true;
	        }
	    }
	    return false;
	}
	exports.checkIfReference = checkIfReference;
	/**
	 * Created by kor on 11/05/15.
	 */
	//# sourceMappingURL=wrappedParserGen.js.map

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	var ASTDelta = (function () {
	    function ASTDelta() {
	    }
	    return ASTDelta;
	})();
	exports.ASTDelta = ASTDelta;
	(function (CommandKind) {
	    CommandKind[CommandKind["ADD_CHILD"] = 0] = "ADD_CHILD";
	    CommandKind[CommandKind["REMOVE_CHILD"] = 1] = "REMOVE_CHILD";
	    CommandKind[CommandKind["MOVE_CHILD"] = 2] = "MOVE_CHILD";
	    CommandKind[CommandKind["CHANGE_KEY"] = 3] = "CHANGE_KEY";
	    CommandKind[CommandKind["CHANGE_VALUE"] = 4] = "CHANGE_VALUE";
	    CommandKind[CommandKind["INIT_RAML_FILE"] = 5] = "INIT_RAML_FILE";
	})(exports.CommandKind || (exports.CommandKind = {}));
	var CommandKind = exports.CommandKind;
	var TextChangeCommand = (function () {
	    function TextChangeCommand(offset, replacementLength, text, unit, target) {
	        if (target === void 0) { target = null; }
	        this.offset = offset;
	        this.replacementLength = replacementLength;
	        this.text = text;
	        this.unit = unit;
	        this.target = target;
	    }
	    return TextChangeCommand;
	})();
	exports.TextChangeCommand = TextChangeCommand;
	var CompositeCommand = (function () {
	    function CompositeCommand() {
	        this.commands = [];
	    }
	    return CompositeCommand;
	})();
	exports.CompositeCommand = CompositeCommand;
	var ASTChangeCommand = (function () {
	    function ASTChangeCommand(kind, target, value, position) {
	        this.toSeq = false;
	        this.kind = kind;
	        this.target = target;
	        this.value = value;
	        this.position = position;
	    }
	    return ASTChangeCommand;
	})();
	exports.ASTChangeCommand = ASTChangeCommand;
	function setAttr(t, value) {
	    return new ASTChangeCommand(4 /* CHANGE_VALUE */, t, value, -1);
	}
	exports.setAttr = setAttr;
	function setAttrStructured(t, value) {
	    return new ASTChangeCommand(4 /* CHANGE_VALUE */, t, value.lowLevel(), -1);
	}
	exports.setAttrStructured = setAttrStructured;
	function setKey(t, value) {
	    return new ASTChangeCommand(3 /* CHANGE_KEY */, t, value, -1);
	}
	exports.setKey = setKey;
	function removeNode(t, child) {
	    return new ASTChangeCommand(1 /* REMOVE_CHILD */, t, child, -1);
	}
	exports.removeNode = removeNode;
	function insertNode(t, child, insertAfter, toSeq) {
	    if (insertAfter === void 0) { insertAfter = null; }
	    if (toSeq === void 0) { toSeq = false; }
	    var s = new ASTChangeCommand(0 /* ADD_CHILD */, t, child, -1);
	    s.insertionPoint = insertAfter;
	    s.toSeq = toSeq;
	    return s;
	}
	exports.insertNode = insertNode;
	function initRamlFile(root, newroot) {
	    return new ASTChangeCommand(5 /* INIT_RAML_FILE */, root, newroot, -1);
	}
	exports.initRamlFile = initRamlFile;
	//# sourceMappingURL=lowLevelAST.js.map

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/tsd.d.ts" />
	'use strict';
	var loader = __webpack_require__(60);
	var dumper = __webpack_require__(27);
	function deprecated(name) {
	    return function () {
	        throw new Error('Function ' + name + ' is deprecated and cannot be used.');
	    };
	}
	exports.Type = __webpack_require__(61);
	exports.Schema = __webpack_require__(62);
	exports.FAILSAFE_SCHEMA = __webpack_require__(63);
	exports.JSON_SCHEMA = __webpack_require__(64);
	exports.CORE_SCHEMA = __webpack_require__(65);
	exports.DEFAULT_SAFE_SCHEMA = __webpack_require__(59);
	exports.DEFAULT_FULL_SCHEMA = __webpack_require__(58);
	exports.load = loader.load;
	exports.loadAll = loader.loadAll;
	exports.safeLoad = loader.safeLoad;
	exports.safeLoadAll = loader.safeLoadAll;
	exports.dump = dumper.dump;
	exports.safeDump = dumper.safeDump;
	exports.YAMLException = __webpack_require__(28);
	// Deprecared schema names from JS-YAML 2.0.x
	exports.MINIMAL_SCHEMA = __webpack_require__(63);
	exports.SAFE_SCHEMA = __webpack_require__(59);
	exports.DEFAULT_SCHEMA = __webpack_require__(58);
	// Deprecated functions from JS-YAML 1.x.x
	exports.scan = deprecated('scan');
	exports.parse = deprecated('parse');
	exports.compose = deprecated('compose');
	exports.addConstructor = deprecated('addConstructor');
	//# sourceMappingURL=js-yaml.js.map

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../typings/tsd.d.ts" />
	'use strict';
	/*eslint-disable no-use-before-define*/
	var common = __webpack_require__(57);
	var YAMLException = __webpack_require__(28);
	var DEFAULT_FULL_SCHEMA = __webpack_require__(58);
	var DEFAULT_SAFE_SCHEMA = __webpack_require__(59);
	var _toString = Object.prototype.toString;
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	var CHAR_TAB = 0x09; /* Tab */
	var CHAR_LINE_FEED = 0x0A; /* LF */
	var CHAR_CARRIAGE_RETURN = 0x0D; /* CR */
	var CHAR_SPACE = 0x20; /* Space */
	var CHAR_EXCLAMATION = 0x21; /* ! */
	var CHAR_DOUBLE_QUOTE = 0x22; /* " */
	var CHAR_SHARP = 0x23; /* # */
	var CHAR_PERCENT = 0x25; /* % */
	var CHAR_AMPERSAND = 0x26; /* & */
	var CHAR_SINGLE_QUOTE = 0x27; /* ' */
	var CHAR_ASTERISK = 0x2A; /* * */
	var CHAR_COMMA = 0x2C; /* , */
	var CHAR_MINUS = 0x2D; /* - */
	var CHAR_COLON = 0x3A; /* : */
	var CHAR_GREATER_THAN = 0x3E; /* > */
	var CHAR_QUESTION = 0x3F; /* ? */
	var CHAR_COMMERCIAL_AT = 0x40; /* @ */
	var CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */
	var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
	var CHAR_GRAVE_ACCENT = 0x60; /* ` */
	var CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */
	var CHAR_VERTICAL_LINE = 0x7C; /* | */
	var CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */
	var ESCAPE_SEQUENCES = {};
	ESCAPE_SEQUENCES[0x00] = '\\0';
	ESCAPE_SEQUENCES[0x07] = '\\a';
	ESCAPE_SEQUENCES[0x08] = '\\b';
	ESCAPE_SEQUENCES[0x09] = '\\t';
	ESCAPE_SEQUENCES[0x0A] = '\\n';
	ESCAPE_SEQUENCES[0x0B] = '\\v';
	ESCAPE_SEQUENCES[0x0C] = '\\f';
	ESCAPE_SEQUENCES[0x0D] = '\\r';
	ESCAPE_SEQUENCES[0x1B] = '\\e';
	ESCAPE_SEQUENCES[0x22] = '\\"';
	ESCAPE_SEQUENCES[0x5C] = '\\\\';
	ESCAPE_SEQUENCES[0x85] = '\\N';
	ESCAPE_SEQUENCES[0xA0] = '\\_';
	ESCAPE_SEQUENCES[0x2028] = '\\L';
	ESCAPE_SEQUENCES[0x2029] = '\\P';
	var DEPRECATED_BOOLEANS_SYNTAX = [
	    'y',
	    'Y',
	    'yes',
	    'Yes',
	    'YES',
	    'on',
	    'On',
	    'ON',
	    'n',
	    'N',
	    'no',
	    'No',
	    'NO',
	    'off',
	    'Off',
	    'OFF'
	];
	function compileStyleMap(schema, map) {
	    var result, keys, index, length, tag, style, type;
	    if (null === map) {
	        return {};
	    }
	    result = {};
	    keys = Object.keys(map);
	    for (index = 0, length = keys.length; index < length; index += 1) {
	        tag = keys[index];
	        style = String(map[tag]);
	        if ('!!' === tag.slice(0, 2)) {
	            tag = 'tag:yaml.org,2002:' + tag.slice(2);
	        }
	        type = schema.compiledTypeMap[tag];
	        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
	            style = type.styleAliases[style];
	        }
	        result[tag] = style;
	    }
	    return result;
	}
	function encodeHex(character) {
	    var string, handle, length;
	    string = character.toString(16).toUpperCase();
	    if (character <= 0xFF) {
	        handle = 'x';
	        length = 2;
	    }
	    else if (character <= 0xFFFF) {
	        handle = 'u';
	        length = 4;
	    }
	    else if (character <= 0xFFFFFFFF) {
	        handle = 'U';
	        length = 8;
	    }
	    else {
	        throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
	    }
	    return '\\' + handle + common.repeat('0', length - string.length) + string;
	}
	function State(options) {
	    this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
	    this.indent = Math.max(1, (options['indent'] || 2));
	    this.skipInvalid = options['skipInvalid'] || false;
	    this.flowLevel = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
	    this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
	    this.implicitTypes = this.schema.compiledImplicit;
	    this.explicitTypes = this.schema.compiledExplicit;
	    this.tag = null;
	    this.result = '';
	    this.duplicates = [];
	    this.usedDuplicates = null;
	}
	function indentString(string, spaces) {
	    var ind = common.repeat(' ', spaces), position = 0, next = -1, result = '', line, length = string.length;
	    while (position < length) {
	        next = string.indexOf('\n', position);
	        if (next === -1) {
	            line = string.slice(position);
	            position = length;
	        }
	        else {
	            line = string.slice(position, next + 1);
	            position = next + 1;
	        }
	        if (line.length && line !== '\n') {
	            result += ind;
	        }
	        result += line;
	    }
	    return result;
	}
	function generateNextLine(state, level) {
	    return '\n' + common.repeat(' ', state.indent * level);
	}
	function testImplicitResolving(state, str) {
	    var index, length, type;
	    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
	        type = state.implicitTypes[index];
	        if (type.resolve(str)) {
	            return true;
	        }
	    }
	    return false;
	}
	function StringBuilder(source) {
	    this.source = source;
	    this.result = '';
	    this.checkpoint = 0;
	}
	StringBuilder.prototype.takeUpTo = function (position) {
	    var er;
	    if (position < this.checkpoint) {
	        er = new Error('position should be > checkpoint');
	        er.position = position;
	        er.checkpoint = this.checkpoint;
	        throw er;
	    }
	    this.result += this.source.slice(this.checkpoint, position);
	    this.checkpoint = position;
	    return this;
	};
	StringBuilder.prototype.escapeChar = function () {
	    var character, esc;
	    character = this.source.charCodeAt(this.checkpoint);
	    esc = ESCAPE_SEQUENCES[character] || encodeHex(character);
	    this.result += esc;
	    this.checkpoint += 1;
	    return this;
	};
	StringBuilder.prototype.finish = function () {
	    if (this.source.length > this.checkpoint) {
	        this.takeUpTo(this.source.length);
	    }
	};
	function writeScalar(state, object, level) {
	    var simple, first, spaceWrap, folded, literal, single, double, sawLineFeed, linePosition, longestLine, indent, max, character, position, escapeSeq, hexEsc, previous, lineLength, modifier, trailingLineBreaks, result;
	    if (0 === object.length) {
	        state.dump = "''";
	        return;
	    }
	    if (object.indexOf("!include") == 0) {
	        state.dump = "" + object; //FIXME
	        return;
	    }
	    if (object.indexOf("!$$$novalue") == 0) {
	        state.dump = ""; //FIXME
	        return;
	    }
	    if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {
	        state.dump = "'" + object + "'";
	        return;
	    }
	    simple = true;
	    first = object.length ? object.charCodeAt(0) : 0;
	    spaceWrap = (CHAR_SPACE === first || CHAR_SPACE === object.charCodeAt(object.length - 1));
	    // Simplified check for restricted first characters
	    // http://www.yaml.org/spec/1.2/spec.html#ns-plain-first%28c%29
	    if (CHAR_MINUS === first || CHAR_QUESTION === first || CHAR_COMMERCIAL_AT === first || CHAR_GRAVE_ACCENT === first) {
	        simple = false;
	    }
	    // can only use > and | if not wrapped in spaces.
	    if (spaceWrap) {
	        simple = false;
	        folded = false;
	        literal = false;
	    }
	    else {
	        folded = true;
	        literal = true;
	    }
	    single = true;
	    double = new StringBuilder(object);
	    sawLineFeed = false;
	    linePosition = 0;
	    longestLine = 0;
	    indent = state.indent * level;
	    max = 80;
	    if (indent < 40) {
	        max -= indent;
	    }
	    else {
	        max = 40;
	    }
	    for (position = 0; position < object.length; position++) {
	        character = object.charCodeAt(position);
	        if (simple) {
	            // Characters that can never appear in the simple scalar
	            if (!simpleChar(character)) {
	                simple = false;
	            }
	            else {
	                continue;
	            }
	        }
	        if (single && character === CHAR_SINGLE_QUOTE) {
	            single = false;
	        }
	        escapeSeq = ESCAPE_SEQUENCES[character];
	        hexEsc = needsHexEscape(character);
	        if (!escapeSeq && !hexEsc) {
	            continue;
	        }
	        if (character !== CHAR_LINE_FEED && character !== CHAR_DOUBLE_QUOTE && character !== CHAR_SINGLE_QUOTE) {
	            folded = false;
	            literal = false;
	        }
	        else if (character === CHAR_LINE_FEED) {
	            sawLineFeed = true;
	            single = false;
	            if (position > 0) {
	                previous = object.charCodeAt(position - 1);
	                if (previous === CHAR_SPACE) {
	                    literal = false;
	                    folded = false;
	                }
	            }
	            if (folded) {
	                lineLength = position - linePosition;
	                linePosition = position;
	                if (lineLength > longestLine) {
	                    longestLine = lineLength;
	                }
	            }
	        }
	        if (character !== CHAR_DOUBLE_QUOTE) {
	            single = false;
	        }
	        double.takeUpTo(position);
	        double.escapeChar();
	    }
	    if (simple && testImplicitResolving(state, object)) {
	        simple = false;
	    }
	    modifier = '';
	    if (folded || literal) {
	        trailingLineBreaks = 0;
	        if (object.charCodeAt(object.length - 1) === CHAR_LINE_FEED) {
	            trailingLineBreaks += 1;
	            if (object.charCodeAt(object.length - 2) === CHAR_LINE_FEED) {
	                trailingLineBreaks += 1;
	            }
	        }
	        if (trailingLineBreaks === 0) {
	            modifier = '-';
	        }
	        else if (trailingLineBreaks === 2) {
	            modifier = '+';
	        }
	    }
	    if (literal && longestLine < max) {
	        folded = false;
	    }
	    // If it's literally one line, then don't bother with the literal.
	    // We may still want to do a fold, though, if it's a super long line.
	    if (!sawLineFeed) {
	        literal = false;
	    }
	    if (simple) {
	        state.dump = object;
	    }
	    else if (single) {
	        state.dump = '\'' + object + '\'';
	    }
	    else if (folded) {
	        result = fold(object, max);
	        state.dump = '>' + modifier + '\n' + indentString(result, indent);
	    }
	    else if (literal) {
	        if (!modifier) {
	            object = object.replace(/\n$/, '');
	        }
	        state.dump = '|' + modifier + '\n' + indentString(object, indent);
	    }
	    else if (double) {
	        double.finish();
	        state.dump = '"' + double.result + '"';
	    }
	    else {
	        throw new Error('Failed to dump scalar value');
	    }
	    return;
	}
	// The `trailing` var is a regexp match of any trailing `\n` characters.
	//
	// There are three cases we care about:
	//
	// 1. One trailing `\n` on the string.  Just use `|` or `>`.
	//    This is the assumed default. (trailing = null)
	// 2. No trailing `\n` on the string.  Use `|-` or `>-` to "chomp" the end.
	// 3. More than one trailing `\n` on the string.  Use `|+` or `>+`.
	//
	// In the case of `>+`, these line breaks are *not* doubled (like the line
	// breaks within the string), so it's important to only end with the exact
	// same number as we started.
	function fold(object, max) {
	    var result = '', position = 0, length = object.length, trailing = /\n+$/.exec(object), newLine;
	    if (trailing) {
	        length = trailing.index + 1;
	    }
	    while (position < length) {
	        newLine = object.indexOf('\n', position);
	        if (newLine > length || newLine === -1) {
	            if (result) {
	                result += '\n\n';
	            }
	            result += foldLine(object.slice(position, length), max);
	            position = length;
	        }
	        else {
	            if (result) {
	                result += '\n\n';
	            }
	            result += foldLine(object.slice(position, newLine), max);
	            position = newLine + 1;
	        }
	    }
	    if (trailing && trailing[0] !== '\n') {
	        result += trailing[0];
	    }
	    return result;
	}
	function foldLine(line, max) {
	    if (line === '') {
	        return line;
	    }
	    var foldRe = /[^\s] [^\s]/g, result = '', prevMatch = 0, foldStart = 0, match = foldRe.exec(line), index, foldEnd, folded;
	    while (match) {
	        index = match.index;
	        // when we cross the max len, if the previous match would've
	        // been ok, use that one, and carry on.  If there was no previous
	        // match on this fold section, then just have a long line.
	        if (index - foldStart > max) {
	            if (prevMatch !== foldStart) {
	                foldEnd = prevMatch;
	            }
	            else {
	                foldEnd = index;
	            }
	            if (result) {
	                result += '\n';
	            }
	            folded = line.slice(foldStart, foldEnd);
	            result += folded;
	            foldStart = foldEnd + 1;
	        }
	        prevMatch = index + 1;
	        match = foldRe.exec(line);
	    }
	    if (result) {
	        result += '\n';
	    }
	    // if we end up with one last word at the end, then the last bit might
	    // be slightly bigger than we wanted, because we exited out of the loop.
	    if (foldStart !== prevMatch && line.length - foldStart > max) {
	        result += line.slice(foldStart, prevMatch) + '\n' + line.slice(prevMatch + 1);
	    }
	    else {
	        result += line.slice(foldStart);
	    }
	    return result;
	}
	// Returns true if character can be found in a simple scalar
	function simpleChar(character) {
	    return CHAR_TAB !== character && CHAR_LINE_FEED !== character && CHAR_CARRIAGE_RETURN !== character && CHAR_COMMA !== character && CHAR_LEFT_SQUARE_BRACKET !== character && CHAR_RIGHT_SQUARE_BRACKET !== character && CHAR_LEFT_CURLY_BRACKET !== character && CHAR_RIGHT_CURLY_BRACKET !== character && CHAR_SHARP !== character && CHAR_AMPERSAND !== character && CHAR_ASTERISK !== character && CHAR_EXCLAMATION !== character && CHAR_VERTICAL_LINE !== character && CHAR_GREATER_THAN !== character && CHAR_SINGLE_QUOTE !== character && CHAR_DOUBLE_QUOTE !== character && CHAR_PERCENT !== character && CHAR_COLON !== character && !ESCAPE_SEQUENCES[character] && !needsHexEscape(character);
	}
	// Returns true if the character code needs to be escaped.
	function needsHexEscape(character) {
	    return !((0x00020 <= character && character <= 0x00007E) || (0x00085 === character) || (0x000A0 <= character && character <= 0x00D7FF) || (0x0E000 <= character && character <= 0x00FFFD) || (0x10000 <= character && character <= 0x10FFFF));
	}
	function writeFlowSequence(state, level, object) {
	    var _result = '', _tag = state.tag, index, length;
	    for (index = 0, length = object.length; index < length; index += 1) {
	        // Write only valid elements.
	        if (writeNode(state, level, object[index], false, false)) {
	            if (0 !== index) {
	                _result += ', ';
	            }
	            _result += state.dump;
	        }
	    }
	    state.tag = _tag;
	    state.dump = '[' + _result + ']';
	}
	function writeBlockSequence(state, level, object, compact) {
	    var _result = '', _tag = state.tag, index, length;
	    for (index = 0, length = object.length; index < length; index += 1) {
	        // Write only valid elements.
	        if (writeNode(state, level + 1, object[index], true, true)) {
	            if (!compact || 0 !== index) {
	                _result += generateNextLine(state, level);
	            }
	            _result += '- ' + state.dump;
	        }
	    }
	    state.tag = _tag;
	    state.dump = _result || '[]'; // Empty sequence if no valid values.
	}
	function writeFlowMapping(state, level, object) {
	    var _result = '', _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
	    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	        pairBuffer = '';
	        if (0 !== index) {
	            pairBuffer += ', ';
	        }
	        objectKey = objectKeyList[index];
	        objectValue = object[objectKey];
	        if (!writeNode(state, level, objectKey, false, false)) {
	            continue;
	        }
	        if (state.dump.length > 1024) {
	            pairBuffer += '? ';
	        }
	        pairBuffer += state.dump + ': ';
	        if (!writeNode(state, level, objectValue, false, false)) {
	            continue;
	        }
	        pairBuffer += state.dump;
	        // Both key and value are valid.
	        _result += pairBuffer;
	    }
	    state.tag = _tag;
	    state.dump = '{' + _result + '}';
	}
	function writeBlockMapping(state, level, object, compact) {
	    var _result = '', _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
	    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	        pairBuffer = '';
	        if (!compact || 0 !== index) {
	            pairBuffer += generateNextLine(state, level);
	        }
	        objectKey = objectKeyList[index];
	        objectValue = object[objectKey];
	        if (!writeNode(state, level + 1, objectKey, true, true)) {
	            continue;
	        }
	        explicitPair = (null !== state.tag && '?' !== state.tag) || (state.dump && state.dump.length > 1024);
	        if (explicitPair) {
	            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
	                pairBuffer += '?';
	            }
	            else {
	                pairBuffer += '? ';
	            }
	        }
	        pairBuffer += state.dump;
	        if (explicitPair) {
	            pairBuffer += generateNextLine(state, level);
	        }
	        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
	            continue;
	        }
	        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
	            pairBuffer += ':';
	        }
	        else {
	            pairBuffer += ': ';
	        }
	        pairBuffer += state.dump;
	        // Both key and value are valid.
	        _result += pairBuffer;
	    }
	    state.tag = _tag;
	    state.dump = _result || '{}'; // Empty mapping if no valid pairs.
	}
	function detectType(state, object, explicit) {
	    var _result, typeList, index, length, type, style;
	    typeList = explicit ? state.explicitTypes : state.implicitTypes;
	    for (index = 0, length = typeList.length; index < length; index += 1) {
	        type = typeList[index];
	        if ((type.instanceOf || type.predicate) && (!type.instanceOf || (('object' === typeof object) && (object instanceof type.instanceOf))) && (!type.predicate || type.predicate(object))) {
	            state.tag = explicit ? type.tag : '?';
	            if (type.represent) {
	                style = state.styleMap[type.tag] || type.defaultStyle;
	                if ('[object Function]' === _toString.call(type.represent)) {
	                    _result = type.represent(object, style);
	                }
	                else if (_hasOwnProperty.call(type.represent, style)) {
	                    _result = type.represent[style](object, style);
	                }
	                else {
	                    throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
	                }
	                state.dump = _result;
	            }
	            return true;
	        }
	    }
	    return false;
	}
	// Serializes `object` and writes it to global `result`.
	// Returns true on success, or false on invalid object.
	//
	function writeNode(state, level, object, block, compact) {
	    state.tag = null;
	    state.dump = object;
	    if (!detectType(state, object, false)) {
	        detectType(state, object, true);
	    }
	    var type = _toString.call(state.dump);
	    if (block) {
	        block = (0 > state.flowLevel || state.flowLevel > level);
	    }
	    if ((null !== state.tag && '?' !== state.tag) || (2 !== state.indent && level > 0)) {
	        compact = false;
	    }
	    var objectOrArray = '[object Object]' === type || '[object Array]' === type, duplicateIndex, duplicate;
	    if (objectOrArray) {
	        duplicateIndex = state.duplicates.indexOf(object);
	        duplicate = duplicateIndex !== -1;
	    }
	    if (duplicate && state.usedDuplicates[duplicateIndex]) {
	        state.dump = '*ref_' + duplicateIndex;
	    }
	    else {
	        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
	            state.usedDuplicates[duplicateIndex] = true;
	        }
	        if ('[object Object]' === type) {
	            if (block && (0 !== Object.keys(state.dump).length)) {
	                writeBlockMapping(state, level, state.dump, compact);
	                if (duplicate) {
	                    state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
	                }
	            }
	            else {
	                writeFlowMapping(state, level, state.dump);
	                if (duplicate) {
	                    state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
	                }
	            }
	        }
	        else if ('[object Array]' === type) {
	            if (block && (0 !== state.dump.length)) {
	                writeBlockSequence(state, level, state.dump, compact);
	                if (duplicate) {
	                    state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
	                }
	            }
	            else {
	                writeFlowSequence(state, level, state.dump);
	                if (duplicate) {
	                    state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
	                }
	            }
	        }
	        else if ('[object String]' === type) {
	            if ('?' !== state.tag) {
	                writeScalar(state, state.dump, level);
	            }
	        }
	        else {
	            if (state.skipInvalid) {
	                return false;
	            }
	            throw new YAMLException('unacceptable kind of an object to dump ' + type);
	        }
	        if (null !== state.tag && '?' !== state.tag) {
	            state.dump = '!<' + state.tag + '> ' + state.dump;
	        }
	    }
	    return true;
	}
	function getDuplicateReferences(object, state) {
	    var objects = [], duplicatesIndexes = [], index, length;
	    inspectNode(object, objects, duplicatesIndexes);
	    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
	        state.duplicates.push(objects[duplicatesIndexes[index]]);
	    }
	    state.usedDuplicates = new Array(length);
	}
	function inspectNode(object, objects, duplicatesIndexes) {
	    var type = _toString.call(object), objectKeyList, index, length;
	    if (null !== object && 'object' === typeof object) {
	        index = objects.indexOf(object);
	        if (-1 !== index) {
	            if (-1 === duplicatesIndexes.indexOf(index)) {
	                duplicatesIndexes.push(index);
	            }
	        }
	        else {
	            objects.push(object);
	            if (Array.isArray(object)) {
	                for (index = 0, length = object.length; index < length; index += 1) {
	                    inspectNode(object[index], objects, duplicatesIndexes);
	                }
	            }
	            else {
	                objectKeyList = Object.keys(object);
	                for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	                    inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
	                }
	            }
	        }
	    }
	}
	function dump(input, options) {
	    options = options || {};
	    var state = new State(options);
	    getDuplicateReferences(input, state);
	    if (writeNode(state, 0, input, true, true)) {
	        return state.dump + '\n';
	    }
	    return '';
	}
	exports.dump = dump;
	function safeDump(input, options) {
	    return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}
	exports.safeDump = safeDump;
	//# sourceMappingURL=dumper.js.map

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var YAMLException = (function () {
	    function YAMLException(reason, mark) {
	        if (mark === void 0) { mark = null; }
	        this.name = 'YAMLException';
	        this.reason = reason;
	        this.mark = mark;
	        this.message = this.toString(false);
	    }
	    YAMLException.prototype.toString = function (compact) {
	        if (compact === void 0) { compact = false; }
	        var result;
	        result = 'JS-YAML: ' + (this.reason || '(unknown reason)');
	        if (!compact && this.mark) {
	            result += ' ' + this.mark.toString();
	        }
	        return result;
	    };
	    return YAMLException;
	})();
	module.exports = YAMLException;
	//# sourceMappingURL=exception.js.map

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	function isMultiLine(s) {
	    return s && s.indexOf('\n') >= 0;
	}
	exports.isMultiLine = isMultiLine;
	function isMultiLineValue(s) {
	    return isMultiLine(s) && s.length > 2 && s[0] == '|' && (s[1] == '\n' || s[1] == '\r' || s[2] == '\n');
	}
	exports.isMultiLineValue = isMultiLineValue;
	function makeMutiLine(s, lev) {
	    var xbuf = '';
	    if (isMultiLine(s)) {
	        xbuf += '|\n';
	        var lines = splitOnLines(s);
	        for (var i = 0; i < lines.length; i++) {
	            xbuf += indent(lev, lines[i]);
	        }
	    }
	    else {
	        xbuf += s;
	    }
	    return xbuf;
	}
	exports.makeMutiLine = makeMutiLine;
	function fromMutiLine(s) {
	    if (!isMultiLineValue(s))
	        return s;
	    var res = null;
	    var lines = splitOnLines(s);
	    for (var i = 1; i < lines.length; i++) {
	        var line = lines[i];
	        var str = line.substring(2);
	        if (!res)
	            res = str;
	        else
	            res += str;
	    }
	    return res;
	}
	exports.fromMutiLine = fromMutiLine;
	function trimStart(s) {
	    if (!s)
	        return s;
	    var pos = 0;
	    while (pos < s.length) {
	        var ch = s[pos];
	        if (ch != '\r' && ch != '\n' && ch != ' ' && ch != '\t')
	            break;
	        pos++;
	    }
	    return s.substring(pos, s.length);
	}
	exports.trimStart = trimStart;
	function indent(lev, str) {
	    if (str === void 0) { str = ''; }
	    var leading = '';
	    for (var i = 0; i < lev; i++)
	        leading += '  ';
	    return leading + str;
	}
	exports.indent = indent;
	function print(lev, str) {
	    if (str === void 0) { str = ''; }
	    console.log(indent(lev, str));
	}
	exports.print = print;
	function replaceNewlines(s, rep) {
	    if (rep === void 0) { rep = null; }
	    var res = '';
	    for (var i = 0; i < s.length; i++) {
	        var ch = s[i];
	        if (ch == '\r')
	            ch = rep == null ? '\\r' : rep;
	        if (ch == '\n')
	            ch = rep == null ? '\\n' : rep;
	        res += ch;
	    }
	    return res;
	}
	exports.replaceNewlines = replaceNewlines;
	function trimEnd(s) {
	    var pos = s.length;
	    while (pos > 0) {
	        var ch = s[pos - 1];
	        if (ch != ' ' && ch != '\t' && ch != '\r' && ch != '\n')
	            break;
	        pos--;
	    }
	    return s.substring(0, pos);
	}
	exports.trimEnd = trimEnd;
	function splitOnLines(text) {
	    var lines = text.match(/^.*((\r\n|\n|\r)|$)/gm);
	    return lines;
	}
	exports.splitOnLines = splitOnLines;
	function startsWith(s, suffix) {
	    if (!s || !suffix || s.length < suffix.length)
	        return false;
	    for (var i = 0; i < suffix.length; i++) {
	        if (s[i] != suffix[i])
	            return false;
	    }
	    return true;
	}
	exports.startsWith = startsWith;
	function endsWith(s, suffix) {
	    if (!s || !suffix || s.length < suffix.length)
	        return false;
	    for (var i = 0; i < suffix.length; i++) {
	        if (s[s.length - 1 - i] != suffix[suffix.length - 1 - i])
	            return false;
	    }
	    return true;
	}
	exports.endsWith = endsWith;
	var TextRange = (function () {
	    function TextRange(contents, start, end) {
	        this.contents = contents;
	        this.start = start;
	        this.end = end;
	    }
	    TextRange.prototype.text = function () {
	        return this.contents.substring(this.start, this.end);
	    };
	    TextRange.prototype.startpos = function () {
	        return this.start;
	    };
	    TextRange.prototype.endpos = function () {
	        return this.end;
	    };
	    TextRange.prototype.len = function () {
	        return this.end - this.start;
	    };
	    TextRange.prototype.unitText = function () {
	        return this.contents;
	    };
	    TextRange.prototype.withStart = function (start) {
	        return new TextRange(this.contents, start, this.end);
	    };
	    TextRange.prototype.withEnd = function (end) {
	        return new TextRange(this.contents, this.start, end);
	    };
	    TextRange.prototype.sub = function (start, end) {
	        return this.contents.substring(start, end);
	    };
	    TextRange.prototype.trimStart = function () {
	        var pos = this.start;
	        while (pos < this.contents.length - 1) {
	            var ch = this.contents[pos];
	            if (ch != ' ' && ch != '\t')
	                break;
	            pos++;
	        }
	        return new TextRange(this.contents, pos, this.end);
	    };
	    TextRange.prototype.trimEnd = function () {
	        var pos = this.end;
	        while (pos > 0) {
	            var ch = this.contents[pos - 1];
	            if (ch != ' ' && ch != '\t')
	                break;
	            pos--;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.extendToStartOfLine = function () {
	        var pos = this.start;
	        while (pos > 0) {
	            var prevchar = this.contents[pos - 1];
	            if (prevchar == '\r' || prevchar == '\n')
	                break;
	            pos--;
	        }
	        return new TextRange(this.contents, pos, this.end);
	    };
	    TextRange.prototype.extendAnyUntilNewLines = function () {
	        var pos = this.end;
	        if (pos > 0) {
	            var last = this.contents[pos - 1];
	            if (last == '\n')
	                return this;
	        }
	        while (pos < this.contents.length - 1) {
	            var nextchar = this.contents[pos];
	            if (nextchar == '\r' || nextchar == '\n')
	                break;
	            pos++;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.extendSpacesUntilNewLines = function () {
	        var pos = this.end;
	        if (pos > 0) {
	            var last = this.contents[pos - 1];
	            if (last == '\n')
	                return this;
	        }
	        while (pos < this.contents.length - 1) {
	            var nextchar = this.contents[pos];
	            if (nextchar != ' ' || nextchar == '\r' || nextchar == '\n')
	                break;
	            pos++;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.extendSpaces = function () {
	        var pos = this.end;
	        while (pos < this.contents.length - 1) {
	            var nextchar = this.contents[pos];
	            if (nextchar != ' ')
	                break;
	            pos++;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.extendSpacesBack = function () {
	        var pos = this.start;
	        while (pos > 0) {
	            var nextchar = this.contents[pos - 1];
	            if (nextchar != ' ')
	                break;
	            pos--;
	        }
	        return new TextRange(this.contents, pos, this.end);
	    };
	    TextRange.prototype.extendCharIfAny = function (ch) {
	        var pos = this.end;
	        if (pos < this.contents.length - 1 && this.contents[pos] == ch) {
	            pos++;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.extendCharIfAnyBack = function (ch) {
	        var pos = this.start;
	        if (pos > 0 && this.contents[pos - 1] == ch) {
	            pos--;
	        }
	        return new TextRange(this.contents, pos, this.end);
	    };
	    TextRange.prototype.extendToNewlines = function () {
	        var pos = this.end;
	        if (pos > 0) {
	            var last = this.contents[pos - 1];
	            if (last == '\n')
	                return this;
	        }
	        while (pos < this.contents.length - 1) {
	            var nextchar = this.contents[pos];
	            if (nextchar != '\r' && nextchar != '\n')
	                break;
	            pos++;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.extendUntilNewlinesBack = function () {
	        var pos = this.start;
	        while (pos > 0) {
	            var nextchar = this.contents[pos - 1];
	            if (nextchar == '\r' || nextchar == '\n')
	                break;
	            pos--;
	        }
	        return new TextRange(this.contents, pos, this.end);
	    };
	    TextRange.prototype.reduceNewlinesEnd = function () {
	        var pos = this.end;
	        while (pos > this.start) {
	            var last = this.contents[pos - 1];
	            if (last != '\r' && last != '\n')
	                break;
	            pos--;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.reduceSpaces = function () {
	        var pos = this.end;
	        while (pos > this.start) {
	            var last = this.contents[pos - 1];
	            if (last != ' ')
	                break;
	            pos--;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.replace = function (text) {
	        return this.sub(0, this.start) + text + this.sub(this.end, this.unitText().length);
	    };
	    TextRange.prototype.remove = function () {
	        return this.sub(0, this.start) + this.sub(this.end, this.unitText().length);
	    };
	    return TextRange;
	})();
	exports.TextRange = TextRange;
	//# sourceMappingURL=textutil.js.map

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/// <reference path="../../../typings/tsd.d.ts" />
	var spawnSync = __webpack_require__(43).spawnSync || __webpack_require__(44);
	var HttpResponse = __webpack_require__(75);
	__webpack_require__(76);
	__webpack_require__(80);
	var lru = __webpack_require__(79);
	var globalCache = lru(50);
	//Function('', fs.readFileSync(require.resolve('./lib/worker.js'), 'utf8'));
	function doRequest(method, url, options) {
	    var req = JSON.stringify({
	        method: method,
	        url: url,
	        options: options
	    });
	    var res = spawnSync('/usr/local/bin/node', [/*require.resolve*/(66)], { input: req });
	    if (!res) {
	        return null;
	    }
	    if (res.status !== 0) {
	        throw new Error(res.stderr.toString());
	    }
	    if (res.error) {
	        if (typeof res.error === 'string')
	            res.error = new Error(res.error);
	        throw res.error;
	    }
	    var response = JSON.parse(res.stdout);
	    if (response.success) {
	        return new HttpResponse(response.response.statusCode, response.response.headers, response.response.body);
	    }
	    else {
	        throw new Error(response.error.message || response.error || response);
	    }
	}
	function readFromCacheOrGet(url) {
	    var res = globalCache.get(url);
	    if (res) {
	        if (res == readFromCacheOrGet) {
	            return null;
	        }
	        return res;
	    }
	    try {
	        var res = doRequest("GET", url, { timeout: 3000, socketTimeout: 5000, retry: true });
	        res = new Buffer(res.body.data).toString();
	        globalCache.set(url, res);
	        return res;
	    }
	    catch (e) {
	        globalCache.set(url, readFromCacheOrGet);
	        return null;
	    }
	}
	exports.readFromCacheOrGet = readFromCacheOrGet;
	//# sourceMappingURL=resourceRegistry.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(77).Buffer))

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	var defs = __webpack_require__(21);
	var hl = __webpack_require__(17);
	var _ = __webpack_require__(47);
	var typeExpression = __webpack_require__(67);
	var search = __webpack_require__(35);
	var linter = __webpack_require__(33);
	var schema = __webpack_require__(54);
	function validate(str, node, cb) {
	    var x = str.trim();
	    if (x.length > 0) {
	        try {
	            if (x.charAt(0) == "{") {
	                schema.getJSONSchema(str);
	                //this is json schema
	                return;
	            }
	            if (x.charAt(0) == "<") {
	                schema.getXMLSchema(str);
	                //this is xsd schema
	                return;
	            }
	        }
	        catch (e) {
	            cb.accept(linter.createIssue(7 /* INVALID_VALUE_SCHEMA */, e.message, node));
	        }
	    }
	    var result = typeExpression.parse(str);
	    validateNode(result, node, cb);
	}
	exports.validate = validate;
	function getType(node, expression, defined, toRuntime) {
	    if (toRuntime === void 0) { toRuntime = false; }
	    if (!expression) {
	        return node.definition().universe().getType("StrElement");
	    }
	    if (toRuntime) {
	        if (buildInsRuntime[expression]) {
	            var sm = node.definition().universe().getType(buildInsRuntime[expression]);
	            return sm;
	        }
	    }
	    if (buildIns[expression]) {
	        var qm = node.definition().universe().getType(buildIns[expression]);
	        return qm;
	    }
	    try {
	        var vl = expression;
	        vl = vl.trim();
	        if (vl.charAt(0) == '{') {
	            return null;
	        }
	        if (vl.charAt(0) == '<') {
	            return null;
	        }
	        var result = typeExpression.parse(expression);
	    }
	    catch (e) {
	        return null;
	    }
	    return deriveType(node, result, toRuntime, defined);
	}
	exports.getType = getType;
	/**
	 * Only use it for example validaation at this point, lets think about it after release.
	 * @param node
	 * @param expression
	 * @param defined
	 * @param toRuntime
	 * @returns {any}
	 */
	function getType2(node, expression, defined, toRuntime) {
	    if (toRuntime === void 0) { toRuntime = false; }
	    if (!expression) {
	        return node.definition().universe().getType("StrElement");
	    }
	    if (toRuntime) {
	        if (buildInsRuntime[expression]) {
	            var sm = node.definition().universe().getType(buildInsRuntime[expression]);
	            if (sm) {
	                var ret = new defs.UserDefinedClass(node.name(), node.definition().universe(), node, "", "");
	                ret._superTypes.push(sm);
	                return ret;
	            }
	        }
	    }
	    if (buildIns[expression]) {
	        var qm = node.definition().universe().getType(buildIns[expression]);
	        if (qm) {
	            var ret = new defs.UserDefinedClass(node.name(), node.definition().universe(), node, "", "");
	            ret._superTypes.push(qm);
	            return ret;
	        }
	    }
	    try {
	        var vl = expression;
	        vl = vl.trim();
	        if (vl.charAt(0) == '{') {
	            return null;
	        }
	        if (vl.charAt(0) == '<') {
	            return null;
	        }
	        var result = typeExpression.parse(expression);
	    }
	    catch (e) {
	        return null;
	    }
	    return deriveType(node, result, toRuntime, defined);
	}
	exports.getType2 = getType2;
	var buildIns = {
	    string: "StrElement",
	    number: "NumberElement",
	    integer: "IntegerElement",
	    date: "DateElement",
	    object: "ObjectField",
	    boolean: "BooleanElement",
	    value: "ValueElement",
	    file: "FileParameter"
	};
	var buildInsRuntime = {
	    string: "string",
	    number: "number",
	    integer: "integer",
	    date: "date",
	    object: "ObjectField",
	    boolean: "boolean",
	    value: "string",
	    file: "file"
	};
	var counter = 0;
	function deriveType(node, r, toRuntime, defining) {
	    if (toRuntime === void 0) { toRuntime = false; }
	    if (defining === void 0) { defining = {}; }
	    if (r.type == "union") {
	        var u = r;
	        var left = deriveType(node, u.first, toRuntime, defining);
	        var right = deriveType(node, u.rest, toRuntime, defining);
	        var ut = node.definition().universe().getType("UnionField");
	        var union = new defs.Union("Union" + (counter++), node.definition().universe(), "");
	        union._superTypes.push(ut);
	        union.left = left;
	        union.right = right;
	        return union;
	    }
	    if (r.type == 'responses') {
	        var res = r;
	        var result = null;
	        res.codes.forEach(function (t) {
	            var tp = deriveType(node, t.expr, toRuntime, defining);
	            if (tp) {
	                if (!result) {
	                    result = tp;
	                }
	                else {
	                    var union = new defs.Union("Union" + (counter++), node.definition().universe(), "");
	                    union.left = result;
	                    union.right = tp;
	                    result = tp;
	                }
	            }
	        });
	        return result;
	    }
	    if (r.type == 'parens') {
	        var ex = r;
	        return deriveType(node, ex.expr, toRuntime, defining);
	    }
	    if (r.type == 'name') {
	        var l = r;
	        var val = l.value;
	        var ind = val.lastIndexOf("[]");
	        if (ind != -1 && ind == val.length - 2) {
	            val = val.substr(0, val.length - 2); //FIXME Should be in PEG
	        }
	        if (l.arr > 0) {
	            var types = search.subTypesWithLocals(node.definition().universe().getType("DataElement"), node);
	            var tp = _.find(types, function (x) {
	                var c = x.name() == val;
	                if (!c) {
	                    if (x instanceof defs.AbstractType) {
	                        var at = x;
	                        at.getAliases().forEach(function (y) {
	                            if (y == val) {
	                                c = true;
	                            }
	                        });
	                    }
	                }
	                return c;
	            });
	            if (!tp) {
	                //TOD make it simpler
	                if (toRuntime || true) {
	                    //it is always runtime model when we are here
	                    if (buildInsRuntime[val]) {
	                        tp = node.definition().universe().getType(buildInsRuntime[val]);
	                    }
	                }
	                else if (buildIns[val]) {
	                    tp = node.definition().universe().getType(buildIns[val]);
	                }
	            }
	            if (!tp) {
	                tp = new defs.ValueType("String", node.definition().universe(), "");
	            }
	            var at = node.definition().universe().getType("ArrayField");
	            var arr = new defs.Array(tp.name() + "[]", node.definition().universe(), "");
	            arr._superTypes.push(at);
	            arr.component = tp;
	            arr.dimensions = l.arr;
	            return arr;
	        }
	        if (toRuntime) {
	            if (buildInsRuntime[val]) {
	                return node.definition().universe().getType(buildInsRuntime[val]);
	            }
	        }
	        if (buildIns[val]) {
	            return node.definition().universe().getType(buildIns[val]);
	        }
	        var de = node.definition().universe().getType("DataElement");
	        if (!de) {
	            de = node.definition().universe().getType("GlobalSchema");
	        }
	        //if (defining[val]){
	        //    return defining[val];
	        //}
	        var qm = search.subTypesWithName(val, node, defining);
	        if (qm) {
	            return qm;
	        }
	        //return null;
	        de = node.definition().universe().getType("GlobalSchema");
	        return search.schemasWithName(val, node, defining);
	    }
	    return null;
	}
	exports.deriveType = deriveType;
	function nodeToString(r) {
	    if (r.type == "union") {
	        var u = r;
	        return nodeToString(u.first) + "|" + nodeToString(u.rest);
	    }
	    if (r.type == "responses") {
	        var res = r;
	        var rs = "{";
	        for (var i = 0; i < res.codes.length; i++) {
	            rs += res.codes[i].code;
	            rs += ":";
	            rs += nodeToString(res.codes[i].expr);
	            if (i != res.codes.length - 1) {
	                rs += ",";
	            }
	        }
	        rs += '}';
	        return rs;
	    }
	    if (r.type == 'parens') {
	        var ex = r;
	        var pr = "(" + nodeToString(ex.expr) + ")";
	        if (ex.arr) {
	            pr += "[]";
	        }
	        return pr;
	    }
	    if (r.type == 'name') {
	        var l = r;
	        var val = l.value;
	        var pr = val;
	        if (l.arr) {
	            pr += "[]";
	        }
	        return pr;
	    }
	}
	exports.nodeToString = nodeToString;
	function validateNode(r, node, cb) {
	    if (r.type == "union") {
	        var u = r;
	        validateNode(u.first, node, cb);
	        validateNode(u.rest, node, cb);
	    }
	    if (r.type == "responses") {
	        var res = r;
	        res.codes.forEach(function (x) {
	            var v = x.code;
	            for (var i = 0; i < v.length; i++) {
	                var c = v[i];
	                if (!_.find(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'x', 'X'], function (x) { return x == c; })) {
	                    cb.accept(linter.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Status code should be 3 digits number with optional 'x' as wildcards", node));
	                    return;
	                }
	            }
	            validateNode(x.expr, node, cb);
	        });
	    }
	    if (r.type == 'parens') {
	        var ex = r;
	        validateNode(ex.expr, node, cb);
	    }
	    if (r.type == 'name') {
	        var l = r;
	        var val = l.value;
	        if (val.lastIndexOf("[]") != -1) {
	            val = val.substr(0, val.length - 2); //FIXME Should be in PEG
	        }
	        var pr = node.property();
	        if (pr.isValidValue(val, node.parent())) {
	            return;
	        }
	        var values = pr.enumValues(node.parent());
	        values = values.map(function (x) {
	            var tp = x.indexOf("<");
	            if (tp != -1) {
	                return x.substring(0, tp);
	            }
	            return x;
	        });
	        if (l.params) {
	            l.params.forEach(function (x) {
	                validateNode(x, node, cb);
	            });
	        }
	        values.push("number");
	        values.push("integer");
	        values.push("file");
	        values.push("boolean");
	        values.push("any");
	        values.push("date");
	        values.push("void");
	        values.push("string");
	        values.push("value");
	        if (!_.find(values, function (x) { return x == val; })) {
	            cb.accept(linter.createIssue(0 /* UNRESOLVED_REFERENCE */, "Unresolved reference:" + val, node));
	            return true;
	        }
	    }
	}
	exports.validateNode = validateNode;
	//# sourceMappingURL=typeExpressions.js.map

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/tsd.d.ts" />
	var defs = __webpack_require__(21);
	var _ = __webpack_require__(47);
	var yaml = __webpack_require__(19);
	var typeExpression = __webpack_require__(31);
	var def = __webpack_require__(21);
	var hlimpl = __webpack_require__(7);
	var search = __webpack_require__(35);
	var KeyMatcher = (function () {
	    function KeyMatcher(_props) {
	        this._props = _props;
	        this.parentValue = _.find(_props, function (x) { return x.isFromParentValue(); });
	        this.parentKey = _.find(_props, function (x) { return x.isFromParentKey(); });
	        this.canBeValue = _.find(_props, function (x) { return x.canBeValue(); });
	    }
	    KeyMatcher.prototype.match = function (key) {
	        var _this = this;
	        var _res = null;
	        var lastPref = "";
	        this._props.forEach(function (p) {
	            if (p.isSystem()) {
	                return;
	            }
	            if (p != _this.parentValue && p != _this.parentKey && p.matchKey(key)) {
	                if (p.keyPrefix() != null) {
	                    if (p.keyPrefix().length >= lastPref.length) {
	                        lastPref = p.keyPrefix();
	                        _res = p;
	                    }
	                }
	                else {
	                    _res = p;
	                    lastPref = p.name();
	                }
	            }
	        });
	        return _res;
	    };
	    return KeyMatcher;
	})();
	var deep = 0;
	function getAllOptions(c) {
	    if (deep > 20) {
	        return [];
	    }
	    deep++;
	    try {
	        var result = [];
	        var tp = c.leftType();
	        if (tp) {
	            result.push(tp);
	        }
	        var r = c.rightType();
	        if (r) {
	            if (r.isUnion()) {
	                var options = getAllOptions(r.union());
	                result = result.concat(options);
	            }
	            else {
	                result.push(r);
	            }
	        }
	        return result;
	    }
	    finally {
	        deep--;
	    }
	}
	var ad = 0;
	var BasicNodeBuilder = (function () {
	    function BasicNodeBuilder() {
	    }
	    BasicNodeBuilder.prototype.process = function (node, childrenToAdopt) {
	        var _this = this;
	        var nn = node.lowLevel();
	        var cha = nn._node ? nn._node : nn;
	        try {
	            if (cha['currentChildren']) {
	                return cha['currentChildren'];
	            }
	            if (!node.definition()) {
	                return;
	            }
	            if (node.definition().isUnion()) {
	                if (node.definition().isRuntime()) {
	                    var optins = getAllOptions(node.definition().union());
	                    var actualResult = null;
	                    var bestResult = null;
	                    var bestType = null;
	                    var bestCount = 1000;
	                    var llnode = node;
	                    optins.forEach(function (x) {
	                        if (!actualResult) {
	                            //TODO ADD UNION + Descriminator
	                            if (x instanceof def.NodeClass && !x.isUnionType()) {
	                                var tp = llnode.patchType(x);
	                                if (ad == 0) {
	                                    ad++;
	                                    try {
	                                        var result = _this.process(node, childrenToAdopt);
	                                        var uc = 0;
	                                        for (var i = 0; i < result.length; i++) {
	                                            if (result[i].isUnknown()) {
	                                                uc++;
	                                            }
	                                        }
	                                        if (uc == 0) {
	                                            actualResult = result;
	                                        }
	                                        if (bestCount > uc) {
	                                            bestCount = uc;
	                                            bestResult = result;
	                                            bestType = x;
	                                        }
	                                    }
	                                    finally {
	                                        ad--;
	                                    }
	                                }
	                            }
	                        }
	                    });
	                    if (actualResult) {
	                        return actualResult;
	                    }
	                    if (bestResult) {
	                        llnode.patchType(bestType);
	                    }
	                }
	            }
	            var km = new KeyMatcher(node.definition().allProperties());
	            var aNode = node;
	            var allowsQuestion = aNode._allowQuestion || node.definition().getAllowQuestion();
	            var res = [];
	            //cha['currentChildren']=res;
	            if (km.parentKey) {
	                if (node.lowLevel().key()) {
	                    res.push(new hlimpl.ASTPropImpl(node.lowLevel(), node, km.parentKey.range(), km.parentKey, true));
	                }
	            }
	            if (node.lowLevel().value()) {
	                if (km.parentValue) {
	                    res.push(new hlimpl.ASTPropImpl(node.lowLevel(), node, km.parentValue.range(), km.parentValue));
	                }
	                else if (km.canBeValue) {
	                    var s = node.lowLevel().value();
	                    if (typeof s == 'string' && s.trim().length > 0) {
	                        if (km.canBeValue.name() == "signature") {
	                            if (s.trim().charAt(0) == '(') {
	                                //TODO BETTER DECITION current one prevents completion from working correctly
	                                //in few other cases
	                                res.push(new hlimpl.ASTPropImpl(node.lowLevel(), node, km.canBeValue.range(), km.canBeValue));
	                            }
	                        }
	                        else {
	                            res.push(new hlimpl.ASTPropImpl(node.lowLevel(), node, km.canBeValue.range(), km.canBeValue));
	                        }
	                    }
	                }
	            }
	            else {
	                if (km.canBeValue && km.canBeValue.range() instanceof def.NodeClass) {
	                    var ch = new hlimpl.ASTNodeImpl(node.lowLevel(), aNode, km.canBeValue.range(), km.canBeValue);
	                    return [ch];
	                }
	            }
	            aNode._children = res;
	            if (!aNode.definition().isUserDefined()) {
	                if (aNode.definition().name() == "Api" || aNode.definition().name() == "uses") {
	                    var uses = childrenToAdopt.filter(function (x) { return x.key() == "uses"; });
	                    res = this.processChildren(uses, aNode, res, allowsQuestion, km);
	                    var types = childrenToAdopt.filter(function (x) { return x.key() == "types"; });
	                    res = this.processChildren(types, aNode, res, allowsQuestion, km);
	                    var other = childrenToAdopt.filter(function (x) { return (x.key() != "types" && x.key() != "uses"); });
	                    res = this.processChildren(other, aNode, res, allowsQuestion, km);
	                }
	                else {
	                    res = this.processChildren(childrenToAdopt, aNode, res, allowsQuestion, km);
	                }
	            }
	            else {
	                res = this.processChildren(childrenToAdopt, aNode, res, allowsQuestion, km);
	            }
	            aNode._children = res;
	            return res;
	        }
	        finally {
	            if (ch) {
	                delete cha['currentChildren'];
	            }
	        }
	    };
	    BasicNodeBuilder.prototype.processChildren = function (childrenToAdopt, aNode, res, allowsQuestion, km) {
	        var _this = this;
	        childrenToAdopt.forEach(function (x) {
	            var key = x.key();
	            if (key == '$ref' && aNode.universe().version() == "Swagger") {
	                var resolved = search.resolveReference(x, x.value());
	                if (!resolved) {
	                    var bnode = new hlimpl.BasicASTNode(x, aNode);
	                    bnode.unresolvedRef = "ref";
	                    res.push(bnode);
	                }
	                else {
	                    var mm = _this.process(aNode, resolved.children());
	                    mm.forEach(function (x) {
	                        if (x.property() && x.property().isKey()) {
	                            return;
	                        }
	                        res.push(x);
	                    });
	                }
	            }
	            if (allowsQuestion) {
	                if (key != null && key.charAt(key.length - 1) == '?') {
	                    key = key.substr(0, key.length - 1);
	                }
	            }
	            var p = km.match(key);
	            if (p != null) {
	                var range = p.range();
	                if (p.isAnnotation() && key != "annotations") {
	                    var pi = new hlimpl.ASTPropImpl(x, aNode, range, p);
	                    res.push(pi);
	                    return;
	                }
	                var um = false;
	                var multyValue = p.isMultiValue();
	                if (range instanceof def.Array) {
	                    var at = range;
	                    multyValue = true;
	                    range = at.component;
	                    um = true;
	                }
	                else if (range.isArray()) {
	                    multyValue = true;
	                    um = true;
	                }
	                //TODO DESCRIMINATORS
	                if (range.isValueType()) {
	                    var ch = x.children();
	                    var seq = (x.valueKind() == 3 /* SEQ */);
	                    if ((seq && ch.length > 0 || ch.length > 1) && multyValue) {
	                        ch.forEach(function (y) {
	                            var pi = new hlimpl.ASTPropImpl(y, aNode, range, p);
	                            res.push(pi);
	                        });
	                    }
	                    else {
	                        if (p.isInherited()) {
	                            aNode.setComputed(p.name(), x.value());
	                        }
	                        res.push(new hlimpl.ASTPropImpl(x, aNode, range, p));
	                    }
	                    //}
	                    return;
	                }
	                else {
	                    var rs = [];
	                    //now we need determine actual type
	                    aNode._children = res;
	                    if (!p.isMerged()) {
	                        if (multyValue) {
	                            if (p.isEmbedMap()) {
	                                var chld = x.children();
	                                if (chld.length == 0) {
	                                    if (x.value()) {
	                                        var bnode = new hlimpl.BasicASTNode(x, aNode);
	                                        bnode.knownProperty = p;
	                                        res.push(bnode);
	                                    }
	                                }
	                                chld.forEach(function (y) {
	                                    //TODO TRACK GROUP KEY
	                                    var cld = y.children();
	                                    if (!y.key() && cld.length == 1) {
	                                        var node = new hlimpl.ASTNodeImpl(cld[0], aNode, range, p);
	                                        node._allowQuestion = allowsQuestion;
	                                        rs.push(node);
	                                    }
	                                    else {
	                                        if (aNode.universe().version() == "RAML10") {
	                                            var node = new hlimpl.ASTNodeImpl(y, aNode, range, p);
	                                            node._allowQuestion = allowsQuestion;
	                                            rs.push(node);
	                                        }
	                                        else {
	                                            var bnode = new hlimpl.BasicASTNode(y, aNode);
	                                            res.push(bnode);
	                                            if (y.key()) {
	                                                bnode.needSequence = true;
	                                            }
	                                        }
	                                    }
	                                });
	                            }
	                            else {
	                                var filter = {};
	                                var inherited = [];
	                                if (range instanceof defs.NodeClass) {
	                                    var nc = range;
	                                    if (nc.getCanInherit().length > 0) {
	                                        nc.getCanInherit().forEach(function (v) {
	                                            var vl = aNode.computedValue(v);
	                                            if (vl && p.name() == "body") {
	                                                if (!_.find(x.children(), function (x) { return x.key() == vl; })) {
	                                                    //we can create inherited node;
	                                                    var node = new hlimpl.ASTNodeImpl(x, aNode, range, p);
	                                                    if (aNode.parent().definition().name() == "MethodBase") {
	                                                        node.setComputed("form", "true"); //FIXME
	                                                    }
	                                                    var t = descriminate(p, aNode, node);
	                                                    if (t) {
	                                                        node.patchType(t);
	                                                    }
	                                                    var ch = node.children();
	                                                    //this are false unknowns actual unknowns will be reported by parent node
	                                                    node._children = ch.filter(function (x) { return !x.isUnknown(); });
	                                                    node._allowQuestion = allowsQuestion;
	                                                    inherited.push(node);
	                                                    node.children().forEach(function (x) {
	                                                        if (x.property().isKey()) {
	                                                            var atr = x;
	                                                            atr._computed = true;
	                                                            return;
	                                                        }
	                                                        if (x.isElement()) {
	                                                            if (!x.property().isMerged()) {
	                                                                filter[x.property().name()] = true;
	                                                            }
	                                                        }
	                                                        if (x.property().isAnnotation()) {
	                                                            var atr = x;
	                                                            var vl = atr.value();
	                                                            var strVal = "";
	                                                            if (vl instanceof hlimpl.StructuredValue) {
	                                                                strVal = vl.valueName();
	                                                            }
	                                                            else {
	                                                                strVal = "" + vl;
	                                                            }
	                                                            filter["(" + strVal + ")"] = true;
	                                                        }
	                                                        else {
	                                                            filter[x.name()] = true;
	                                                        }
	                                                    });
	                                                    node._computed = true;
	                                                }
	                                            }
	                                        });
	                                    }
	                                }
	                                var parsed = [];
	                                x.children().forEach(function (y) {
	                                    if (filter[y.key()]) {
	                                        return;
	                                    }
	                                    var node = new hlimpl.ASTNodeImpl(y, aNode, range, p);
	                                    if (p.name() == "body" && p.domain().name() == "MethodBase") {
	                                        node.setComputed("form", "true"); //FIXME
	                                    }
	                                    node._allowQuestion = allowsQuestion;
	                                    parsed.push(node);
	                                });
	                                if (parsed.length > 0) {
	                                    parsed.forEach(function (x) { return rs.push(x); });
	                                }
	                                else {
	                                    inherited.forEach(function (x) { return rs.push(x); });
	                                }
	                            }
	                        }
	                        else {
	                            //var y=x.children()[0];
	                            rs.push(new hlimpl.ASTNodeImpl(x, aNode, range, p));
	                        }
	                    }
	                    else {
	                        var node = new hlimpl.ASTNodeImpl(x, aNode, range, p);
	                        node._allowQuestion = allowsQuestion;
	                        rs.push(node);
	                    }
	                    aNode._children = aNode._children.concat(rs);
	                    res = res.concat(rs);
	                    rs.forEach(function (x) {
	                        var rt = descriminate(p, aNode, x);
	                        if (rt && rt != x.definition()) {
	                            x.patchType(rt);
	                        }
	                        x._associatedDef = null;
	                        p.childRestrictions().forEach(function (y) {
	                            x.setComputed(y.name, y.value);
	                        });
	                        var def = x.definition();
	                    });
	                }
	            }
	            else {
	                res.push(new hlimpl.BasicASTNode(x, aNode));
	            }
	        });
	        return res;
	    };
	    return BasicNodeBuilder;
	})();
	exports.BasicNodeBuilder = BasicNodeBuilder;
	function desc1(p, parent, x) {
	    var tp = x.attr("type");
	    var value = "";
	    if (tp) {
	        var mn = {};
	        var c = new def.NodeClass(x.name(), parent.definition().universe(), "");
	        c.setDeclaringNode(x);
	        c._superTypes.push(parent.definition().universe().getType("DataElement"));
	        mn[tp.value()] = c;
	        var newType = typeExpression.getType(parent, tp.value(), mn);
	        if (newType instanceof def.Array) {
	            newType.setDeclaringNode(x);
	        }
	        return newType;
	    }
	    else {
	        if (p.name() == "body" || _.find(x.lowLevel().children(), function (x) { return x.key() == "properties"; })) {
	            return parent.definition().universe().getType("ObjectField");
	        }
	        return parent.definition().universe().getType("StrElement");
	    }
	    return null;
	}
	function doDescrimination(node) {
	    return descriminate(node.property(), node.parent(), node);
	}
	exports.doDescrimination = doDescrimination;
	function descriminate(p, parent, x) {
	    var n = x.lowLevel();
	    if (!p) {
	        return null;
	    }
	    if (p.name() == "uses" && p.range().name() == "Library") {
	    }
	    if (n._node && n._node['descriminate']) {
	        return null;
	    }
	    if (n._node) {
	        n._node['descriminate'] = 1;
	    }
	    try {
	        if (p.range().name() == "DataElement") {
	            var res = desc1(p, parent, x);
	            //FIXME (think about it later)
	            if (res != null && ((p.name() == "body" || p.name() == "headers") || p.name() == "queryParameters")) {
	                var ares = new defs.UserDefinedClass(x.lowLevel().key(), res.universe(), x, x.lowLevel().unit() ? x.lowLevel().unit().path() : "", "");
	                ares._superTypes.push(res);
	                return ares;
	            }
	            if (res) {
	                return res;
	            }
	        }
	        //generic case;
	        var rt = null;
	        var types = search.findAllSubTypes(p, parent);
	        if (types.length > 0) {
	            types.forEach(function (y) {
	                if (!rt) {
	                    if (y.match(x, rt)) {
	                        rt = y;
	                    }
	                }
	            });
	        }
	        return rt;
	    }
	    finally {
	        if (n._node) {
	            delete n._node['descriminate'];
	        }
	    }
	}
	;
	//# sourceMappingURL=builder.js.map

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/tsd.d.ts" />
	var jsyaml = __webpack_require__(6);
	var defs = __webpack_require__(21);
	var hl = __webpack_require__(17);
	var _ = __webpack_require__(47);
	var typeExpression = __webpack_require__(31);
	var def = __webpack_require__(21);
	var ramlSignature = __webpack_require__(16);
	var hlimpl = __webpack_require__(7);
	var su = __webpack_require__(54);
	var path = __webpack_require__(11);
	var fs = __webpack_require__(12);
	var mediaTypeParser = __webpack_require__(41);
	var xmlutil = __webpack_require__(70);
	var LinterSettings = (function () {
	    function LinterSettings() {
	        this.validateNotStrictExamples = true;
	    }
	    return LinterSettings;
	})();
	var settings = new LinterSettings();
	var loophole = __webpack_require__(48);
	function evalInSandbox(code, thisArg, args) {
	    return new loophole.Function(code).call(thisArg, args);
	}
	exports.evalInSandbox = evalInSandbox;
	var lintWithFile = function (customLinter, acceptor, astNode) {
	    if (fs.existsSync(customLinter)) {
	        try {
	            var content = fs.readFileSync(customLinter).toString();
	            var factr = new LinterExtensionsImpl(acceptor);
	            evalInSandbox(content, factr, null);
	            factr.visit(astNode);
	        }
	        catch (e) {
	            console.log("Error in custom linter");
	            console.log(e);
	        }
	    }
	};
	function lintNode(astNode, acceptor) {
	    var ps = astNode.lowLevel().unit().absolutePath();
	    var dr = path.dirname(ps);
	    var customLinter = path.resolve(dr, "raml-lint.js");
	    lintWithFile(customLinter, acceptor, astNode);
	    var dir = path.resolve(dr, ".raml");
	    if (fs.existsSync(dir)) {
	        var st = fs.statSync(dir);
	        if (st.isDirectory()) {
	            var files = fs.readdirSync(dir);
	            files.forEach(function (x) {
	                if (x.indexOf("-lint.js") != -1) {
	                    lintWithFile(path.resolve(dir, x), acceptor, astNode);
	                }
	                //console.log(x);
	            });
	        }
	    }
	}
	exports.lintNode = lintNode;
	;
	var LinterExtensionsImpl = (function () {
	    function LinterExtensionsImpl(acceptor) {
	        this.acceptor = acceptor;
	        this.nodes = {};
	    }
	    LinterExtensionsImpl.prototype.error = function (w, message) {
	        this.acceptor.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, message, w.highLevel()));
	    };
	    LinterExtensionsImpl.prototype.errorOnProperty = function (w, property, message) {
	        var pr = w.highLevel().attr(property);
	        this.acceptor.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, message, pr));
	    };
	    LinterExtensionsImpl.prototype.warningOnProperty = function (w, property, message) {
	        var pr = w.highLevel().attr(property);
	        this.acceptor.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, message, pr, true));
	    };
	    LinterExtensionsImpl.prototype.warning = function (w, message) {
	        this.acceptor.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, message, w.highLevel(), true));
	    };
	    LinterExtensionsImpl.prototype.registerRule = function (nodeType, rule) {
	        var q = this.nodes[nodeType];
	        if (!q) {
	            q = [];
	            this.nodes[nodeType] = q;
	        }
	        q.push(rule);
	    };
	    LinterExtensionsImpl.prototype.visit = function (h) {
	        var _this = this;
	        var nd = h.definition();
	        this.process(nd, h);
	        nd.allSuperTypes().forEach(function (x) { return _this.process(x, h); });
	        h.elements().forEach(function (y) { return _this.visit(y); });
	    };
	    LinterExtensionsImpl.prototype.process = function (d, h) {
	        var _this = this;
	        if (d instanceof def.NodeClass) {
	            if (!d.getDeclaringNode()) {
	                var rules = this.nodes[d.name()];
	                if (rules) {
	                    rules.forEach(function (x) { return x(h.wrapperNode(), _this); });
	                }
	            }
	        }
	    };
	    return LinterExtensionsImpl;
	})();
	exports.LinterExtensionsImpl = LinterExtensionsImpl;
	var StackNode = (function () {
	    function StackNode() {
	    }
	    StackNode.prototype.toString = function () {
	        if (this.prev) {
	            return this.value + "." + this.prev.toString();
	        }
	        return this.value;
	    };
	    StackNode.prototype.last = function () {
	        if (this.prev) {
	            return this.prev.last();
	        }
	        return this;
	    };
	    return StackNode;
	})();
	var TypeValidator = (function () {
	    function TypeValidator(node) {
	        this.node = node;
	    }
	    TypeValidator.prototype.validate = function (obj, t, cb, strict) {
	        if (t instanceof def.Array) {
	            this.validateArray(obj, t, cb, strict);
	        }
	        else if (t instanceof def.Union) {
	            this.validateUnion(obj, t, cb, strict);
	        }
	        else if (t instanceof def.NodeClass) {
	            this.validateClass(obj, t, cb, strict);
	        }
	        else if (t instanceof def.ValueType) {
	            this.validateValue(obj, t, cb, strict);
	        }
	        else {
	            throw new Error("Not supported case");
	        }
	    };
	    TypeValidator.prototype.createIssue = function (c, message, node, w) {
	        if (w === void 0) { w = false; }
	        var result = hlimpl.createIssue(c, message, node, w);
	        if (this.stack) {
	            var ll = this.findNode(this.stack.last(), this.node.lowLevel());
	            if (ll && ll != node.lowLevel()) {
	                if (ll.unit() == node.root().lowLevel().unit()) {
	                    if (ll.keyStart() > 0 && ll.keyEnd() > 0) {
	                        result.start = ll.keyStart();
	                        result.end = ll.keyEnd();
	                    }
	                }
	            }
	        }
	        return result;
	    };
	    TypeValidator.prototype.findNode = function (c, q) {
	        var key = "" + c.value;
	        if (typeof c.value == 'number') {
	            var m = q.children();
	            if (m[c.value]) {
	                var node = m[c.value];
	                if (c.next) {
	                    return this.findNode(c.next, node);
	                }
	            }
	            return q;
	        }
	        var node = _.find(q.children(), function (x) { return x.key() == key; });
	        if (node) {
	            if (c.next) {
	                return this.findNode(c.next, node);
	            }
	            return node;
	        }
	        else {
	            return q;
	        }
	    };
	    TypeValidator.prototype.validateClass = function (obj, t, cb, strict) {
	        var _this = this;
	        var supers = t.allSuperTypes();
	        supers.push(t);
	        this.validateFacets(t.isRuntime() ? t : t.toRuntime(), obj, cb, strict);
	        supers.forEach(function (s) {
	            if (s.name() == "StrElement") {
	                if (typeof obj != 'string' && typeof obj != 'number' && typeof obj != 'boolean') {
	                    cb.accept(_this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "String is expected", _this.node, !strict));
	                }
	            }
	            if (s.name() == "NumberElement") {
	                if (typeof obj != 'number') {
	                    cb.accept(_this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Number is expected", _this.node, !strict));
	                }
	            }
	            if (s.name() == "BooleanElement") {
	                var isOk = obj == true || obj == false;
	                if (!isOk) {
	                    cb.accept(_this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "boolean is expected", _this.node, !strict));
	                }
	            }
	            if (s instanceof def.Array) {
	                _this.validate(obj, s, cb, strict);
	            }
	            if (s instanceof def.Union) {
	                _this.validate(obj, s, cb, strict);
	            }
	        });
	        var props = t.isRuntime() ? t.allProperties() : t.toRuntime().allProperties();
	        if (!obj) {
	            obj = {};
	        }
	        var handled = {};
	        props.forEach(function (p) {
	            if (!p.isMerged()) {
	                var value = obj[p.name()];
	                handled[p.name()] = 1;
	                if (!value) {
	                    if (p.isRequired()) {
	                        cb.accept(_this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Required property:" + p.name() + " is missed", _this.node, !strict));
	                    }
	                }
	                else {
	                    _this.validatePropValue(value, p, cb, strict, p.name());
	                }
	            }
	        });
	        props.forEach(function (p) {
	            if (p.isMerged()) {
	                if (p.getKeyRegexp() != null) {
	                    Object.keys(obj).forEach(function (x) {
	                        if (!handled[x]) {
	                            try {
	                                var re = new RegExp(p.getKeyRegexp());
	                                if (re.test(x)) {
	                                    var n = _this.node;
	                                    _this.validatePropValue(obj[x], p, cb, strict, x);
	                                    handled[x] = 1;
	                                }
	                            }
	                            catch (e) {
	                            }
	                        }
	                    });
	                }
	            }
	        });
	        props.forEach(function (p) {
	            if (p.isMerged()) {
	                if (p.keyPrefix() != null) {
	                    Object.keys(obj).forEach(function (x) {
	                        if (!handled[x]) {
	                            _this.validatePropValue(obj[x], p, cb, strict, x);
	                            handled[x] = 1;
	                        }
	                    });
	                }
	            }
	        });
	        if (typeof obj == 'object' && props.length > 0) {
	            Object.keys(obj).forEach(function (x) {
	                if (!handled[x]) {
	                    try {
	                        _this.pushStack(x);
	                        cb.accept(_this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Unknown property:" + x, _this.node, !strict));
	                    }
	                    finally {
	                        if (_this.stack) {
	                            _this.stack = _this.stack.prev;
	                        }
	                    }
	                }
	            });
	        }
	    };
	    TypeValidator.prototype.validateFacets = function (t, obj, cb, strict) {
	        var rof = t.getRepresentationOf();
	        var fixedFacets = t.getFixedFacets();
	        if (rof) {
	            t = rof;
	            if (t instanceof def.UserDefinedClass) {
	                fixedFacets = t.getFixedFacets();
	            }
	        }
	        for (var facetKey in fixedFacets) {
	            var facet = t.facet(facetKey);
	            if (facet) {
	                var facetValue = fixedFacets[facetKey];
	                var facetValidator = facet.getFacetValidator();
	                if (facetValidator) {
	                    try {
	                        var result = facetValidator(obj, facetValue);
	                        if (typeof result == "string") {
	                            cb.accept(this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "" + result, this.node, !strict));
	                        }
	                    }
	                    catch (e) {
	                        cb.accept(this.createIssue(7 /* INVALID_VALUE_SCHEMA */, e.message, this.node, !strict));
	                    }
	                }
	            }
	        }
	    };
	    TypeValidator.prototype.validatePropValue = function (value, p, cb, strict, key) {
	        this.pushStack(key);
	        try {
	            this.validate(value, p.range(), cb, strict);
	            var enumValues = p.enumValues(null);
	            if (enumValues) {
	                if (typeof enumValues == 'string') {
	                    if (enumValues != value) {
	                        cb.accept(this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "" + p.name() + " should be one of " + enumValues, this.node, !strict));
	                    }
	                }
	                else if (enumValues.length > 0) {
	                    if (!_.find(enumValues, function (x) { return x == value; })) {
	                        cb.accept(this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "" + p.name() + " should be one of " + enumValues, this.node, !strict));
	                    }
	                }
	            }
	        }
	        finally {
	            if (this.stack) {
	                this.stack = this.stack.prev;
	            }
	        }
	    };
	    TypeValidator.prototype.pushStack = function (key) {
	        if (!this.stack) {
	            this.stack = new StackNode();
	            this.stack.value = key;
	        }
	        else {
	            var pn = new StackNode();
	            pn.prev = this.stack;
	            this.stack.next = pn;
	            this.stack = pn;
	            this.stack.value = key;
	        }
	    };
	    TypeValidator.prototype.validateArray = function (obj, t, cb, strict) {
	        var _this = this;
	        if (!(obj instanceof Array)) {
	            obj = [obj];
	        }
	        if (obj instanceof Array) {
	            var arr = obj;
	            this.validateFacets(t, obj, cb, strict);
	            var num = 0;
	            arr.forEach(function (x) {
	                try {
	                    _this.pushStack(num++);
	                    _this.validate(x, t.component, cb, strict);
	                }
	                finally {
	                    if (_this.stack) {
	                        _this.stack = _this.stack.prev;
	                    }
	                }
	            });
	        }
	    };
	    TypeValidator.prototype.validateUnion = function (obj, t, cb, strict) {
	        //FIXME
	    };
	    TypeValidator.prototype.validateValue = function (obj, t, cb, strict) {
	        //FIXME
	        if (t.name() == "NumberType") {
	            if (typeof obj != 'number') {
	                var qqq = parseFloat(obj);
	                if (!qqq) {
	                    if (isNaN(qqq)) {
	                        cb.accept(this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Number is expected", this.node, !strict));
	                    }
	                }
	            }
	        }
	        if (t.name() == "BooleanType") {
	            if (typeof obj != 'boolean') {
	                if (obj != 'true' && obj != 'false') {
	                    cb.accept(this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "boolean is expected", this.node, !strict));
	                }
	            }
	        }
	    };
	    return TypeValidator;
	})();
	exports.TypeValidator = TypeValidator;
	var NormalValidator = (function () {
	    function NormalValidator() {
	    }
	    NormalValidator.prototype.validate = function (node, cb) {
	        var vl = node.value();
	        if (node.parent().allowsQuestion() && node.property().isKey()) {
	            if (vl != null && vl.length > 0 && vl.charAt(vl.length - 1) == '?') {
	                vl = vl.substr(0, vl.length - 1);
	            }
	        }
	        var pr = node.property();
	        var range = pr.range();
	        if (range instanceof def.NodeClass) {
	            var nc = range;
	            var rof = nc.getRepresentationOf();
	            if (rof) {
	                nc = rof;
	            }
	            var ff = nc.getFixedFacets();
	            for (var fc in ff) {
	                var facet = nc.facet(fc);
	                if (facet) {
	                    var val = facet.getFacetValidator();
	                    if (val) {
	                        try {
	                            var qq = vl;
	                            if (pr.range().isArray()) {
	                                try {
	                                    qq = node.parent().lowLevel().dumpToObject()[node.parent().name()][pr.name()];
	                                }
	                                catch (e) {
	                                }
	                            }
	                            var res = val(qq, ff[fc]);
	                            if (typeof res == 'string') {
	                                cb.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "" + res, node));
	                            }
	                        }
	                        catch (e) {
	                            cb.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, e.message, node));
	                        }
	                    }
	                }
	            }
	        }
	        var v = cb;
	        var validation = pr.range().isValid(node.parent(), vl, pr);
	        if (validation instanceof Error) {
	            if (!validation.canBeRef) {
	                v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, validation.message, node));
	                validation = null;
	                return;
	            }
	        }
	        if (!validation || validation instanceof Error) {
	            if (pr.name() != 'value') {
	                if (!checkReference(pr, node, vl, v)) {
	                    if (pr.name() == 'schema' || pr.name() == 'type') {
	                        if (vl && vl.trim() && (pr.domain().name() == 'BodyLike' || pr.domain().name() == "DataElement")) {
	                            var testSchema = vl.trim().charAt(0); //FIXME
	                            if (testSchema != '{' && testSchema != '<') {
	                                return;
	                            }
	                        }
	                    }
	                    var decl = node.findReferencedValue();
	                    if (decl instanceof Error) {
	                        v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, decl.message, node));
	                    }
	                    if (!decl) {
	                        if (vl) {
	                            if (pr.name() == 'schema') {
	                                var z = vl.trim();
	                                if (z.charAt(0) != '{' && z.charAt(0) != '<') {
	                                    if (vl.indexOf('|') != -1 || vl.indexOf('[]') != -1 || vl.indexOf("(") != -1) {
	                                        return;
	                                    }
	                                }
	                            }
	                        }
	                        if (validation instanceof Error && vl) {
	                            v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, validation.message, node));
	                            validation = null;
	                            return;
	                        }
	                        v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Empty value is not allowed here", node));
	                    }
	                }
	            }
	            else {
	                var vl = node.value();
	                var message = "Invalid value schema:" + vl;
	                if (validation instanceof Error) {
	                    message = validation.message;
	                }
	                v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, message, node));
	            }
	        }
	        var values = pr.enumOptions();
	        if (values) {
	            if (typeof values == 'string') {
	                if (values != vl) {
	                    if (vl && (vl.indexOf("x-") == 0) && pr.name() == "type") {
	                    }
	                    else {
	                        v.accept(createIssue(0 /* UNRESOLVED_REFERENCE */, "Invalid value:" + vl + " allowed values are:" + values, node));
	                    }
	                }
	            }
	            else if (values.length > 0) {
	                if (!_.find(values, function (x) { return x == vl; })) {
	                    if (vl && (vl.indexOf("x-") == 0) && pr.name() == "type") {
	                    }
	                    else {
	                        v.accept(createIssue(0 /* UNRESOLVED_REFERENCE */, "Invalid value:" + vl + " allowed values are:" + values.join(","), node));
	                    }
	                }
	            }
	        }
	    };
	    return NormalValidator;
	})();
	exports.NormalValidator = NormalValidator;
	var UriValidator = (function () {
	    function UriValidator() {
	    }
	    UriValidator.prototype.validate = function (node, cb) {
	        try {
	            new UrlParameterNameValidator().parseUrl(node.value());
	        }
	        catch (e) {
	            cb.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, e.message, node, false));
	        }
	    };
	    return UriValidator;
	})();
	exports.UriValidator = UriValidator;
	var MediaTypeValidator = (function () {
	    function MediaTypeValidator() {
	    }
	    MediaTypeValidator.prototype.validate = function (node, cb) {
	        try {
	            var v = node.value();
	            if (!v) {
	                return;
	            }
	            if (v == "*/*") {
	                return;
	            }
	            if (v.indexOf("/*") == v.length - 2) {
	                v = v.substring(0, v.length - 2) + "/xxx";
	            }
	            if (v == "body") {
	                if (node.parent().parent()) {
	                    if (node.parent().parent().definition().name() == "Response" || node.parent().parent().definition().isAssignableFrom("MethodBase")) {
	                        v = node.parent().computedValue("mediaType");
	                    }
	                }
	            }
	            var res = mediaTypeParser.parse(v);
	            var types = {
	                application: 1,
	                audio: 1,
	                example: 1,
	                image: 1,
	                message: 1,
	                model: 1,
	                multipart: 1,
	                text: 1,
	                video: 1
	            };
	            if (!types[res.type]) {
	                cb.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Unknown media type 'type'", node));
	            }
	        }
	        catch (e) {
	            cb.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "" + e.message, node));
	        }
	        if (node.value() && node.value() == ("multipart/form-data") || node.value() == ("application/x-www-form-urlencoded")) {
	            if (node.parent() && node.parent().parent() && node.parent().parent().property()) {
	                if (node.parent().parent().property().name() == 'responses') {
	                    cb.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Form related media types can not be used in responses", node));
	                }
	            }
	        }
	        return;
	    };
	    return MediaTypeValidator;
	})();
	exports.MediaTypeValidator = MediaTypeValidator;
	var SignatureValidator = (function () {
	    function SignatureValidator() {
	    }
	    SignatureValidator.prototype.validate = function (node, cb) {
	        var vl = node.value();
	        var q = vl ? vl.trim() : "";
	        if (q.length > 0) {
	            try {
	                ramlSignature.validate(vl, node, cb);
	            }
	            catch (e) {
	                cb.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Error during signature parse:" + e.message, node));
	            }
	            return;
	        }
	        return;
	    };
	    return SignatureValidator;
	})();
	exports.SignatureValidator = SignatureValidator;
	var UrlParameterNameValidator = (function () {
	    function UrlParameterNameValidator() {
	    }
	    UrlParameterNameValidator.prototype.checkBaseUri = function (node, c, vl, v) {
	        var bu = c.root().attr("baseUri");
	        if (bu) {
	            var tnv = bu.value();
	            try {
	                var pNames = this.parseUrl(tnv);
	                if (!_.find(pNames, function (x) { return x == vl; })) {
	                    v.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Unused url parameter", node));
	                }
	            }
	            catch (e) {
	            }
	        }
	        else {
	            v.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Unused url parameter", node));
	        }
	    };
	    UrlParameterNameValidator.prototype.parseUrl = function (value) {
	        var result = [];
	        var temp = "";
	        var inPar = false;
	        var count = 0;
	        for (var a = 0; a < value.length; a++) {
	            var c = value[a];
	            if (c == '{') {
	                count++;
	                inPar = true;
	                continue;
	            }
	            if (c == '}') {
	                count--;
	                inPar = false;
	                result.push(temp);
	                temp = "";
	                continue;
	            }
	            if (inPar) {
	                temp += c;
	            }
	        }
	        if (count > 0) {
	            throw new Error("Unmatched '{'");
	        }
	        if (count < 0) {
	            throw new Error("Unmatched '}'");
	        }
	        return result;
	    };
	    UrlParameterNameValidator.prototype.validate = function (node, cb) {
	        var vl = node.value();
	        if (node.parent().property().name() == 'baseUriParameters') {
	            var c = node.parent().parent();
	            this.checkBaseUri(node, c, vl, cb);
	            return;
	        }
	        var c = node.parent().parent();
	        var tn = c.name();
	        if (c.definition().name() == 'Api') {
	            this.checkBaseUri(node, c, vl, cb);
	        }
	        try {
	            var pNames = this.parseUrl(tn);
	            if (!_.find(pNames, function (x) { return x == vl; })) {
	                cb.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Unused url parameter '" + vl + "'", node));
	            }
	        }
	        catch (e) {
	        }
	    };
	    return UrlParameterNameValidator;
	})();
	exports.UrlParameterNameValidator = UrlParameterNameValidator;
	function checkReference(pr, astNode, vl, cb) {
	    if (!vl) {
	        return;
	    }
	    if (vl == 'null') {
	        if (pr.isAllowNull()) {
	            return;
	        }
	    }
	    try {
	        if (typeof vl == 'string') {
	            if (pr.domain().name() == 'DataElement') {
	                if (pr.name() == "type" || pr.name() == 'items') {
	                    typeExpression.validate(vl, astNode, cb);
	                    return false;
	                }
	            }
	            if (pr.range().name() == "SchemaString") {
	                if (pr.range().universe().version() == "RAML10") {
	                    if (pr.range() instanceof defs.ValueType) {
	                        typeExpression.validate(vl, astNode, cb);
	                        return false;
	                    }
	                }
	            }
	            if (pr.name() == "schema" || pr.name() == 'type') {
	                if (pr.domain().name() == 'BodyLike' || pr.domain().name() == "DataElement") {
	                    var q = vl.trim();
	                    if (q.length > 0 && q.charAt(0) != '{' && q.charAt(0) != '<') {
	                        typeExpression.validate(vl, astNode, cb);
	                        return false;
	                    }
	                    return;
	                }
	            }
	        }
	    }
	    catch (e) {
	        cb.accept(createIssue(0 /* UNRESOLVED_REFERENCE */, "Syntax error:" + e.message, astNode));
	    }
	    var valid = pr.isValidValue(vl, astNode.parent());
	    if (!valid) {
	        if (typeof vl == 'string') {
	            if ((vl.indexOf("x-") == 0) && pr.name() == "type") {
	                return true;
	            }
	        }
	        cb.accept(createIssue(0 /* UNRESOLVED_REFERENCE */, "Unresolved reference:" + vl, astNode));
	        return true;
	    }
	    return false;
	}
	exports.checkReference = checkReference;
	;
	var SchemaOrTypeValidator = (function () {
	    function SchemaOrTypeValidator() {
	    }
	    SchemaOrTypeValidator.prototype.validate = function (node, cb) {
	        var vl = node.value();
	        if (vl instanceof hlimpl.StructuredValue) {
	            //already validated in scalar
	            //cb.accept(createIssue(hl.IssueCode.UNRESOLVED_REFERENCE,"Type expression is expected here",node));
	            return;
	        }
	        if (!vl) {
	            vl = "";
	        }
	        try {
	            typeExpression.validate(vl, node, cb);
	        }
	        catch (e) {
	            cb.accept(createIssue(0 /* UNRESOLVED_REFERENCE */, "Syntax error:" + e.message, node));
	        }
	    };
	    return SchemaOrTypeValidator;
	})();
	exports.SchemaOrTypeValidator = SchemaOrTypeValidator;
	var DescriminatorOrReferenceValidator = (function () {
	    function DescriminatorOrReferenceValidator() {
	    }
	    DescriminatorOrReferenceValidator.prototype.validate = function (node, cb) {
	        var vl = node.value();
	        var valueKey = vl;
	        var pr = node.property();
	        if (typeof vl == 'string') {
	            checkReference(pr, node, vl, cb);
	            if (pr.range() instanceof defs.ReferenceType) {
	                var t = pr.range();
	                if (true) {
	                    var mockNode = jsyaml.createNode("" + vl);
	                    mockNode._actualNode().startPosition = node.lowLevel().valueStart();
	                    mockNode._actualNode().endPosition = node.lowLevel().valueEnd();
	                    var stv = new hlimpl.StructuredValue(mockNode, node.parent(), node.property());
	                    var hn = stv.toHighlevel();
	                    if (hn) {
	                        hn.validate(cb);
	                    }
	                }
	            }
	        }
	        else {
	            var st = vl;
	            if (st) {
	                valueKey = st.valueName();
	                var vn = st.valueName();
	                if (!checkReference(pr, node, vn, cb)) {
	                    var hnode = st.toHighlevel();
	                    if (hnode)
	                        hnode.validate(cb);
	                }
	            }
	            else {
	                valueKey = null;
	            }
	        }
	        if (valueKey) {
	            var validation = pr.range().isValid(node.parent(), valueKey, pr);
	            if (validation instanceof Error) {
	                cb.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, validation.message, node));
	                validation = null;
	            }
	        }
	    };
	    return DescriminatorOrReferenceValidator;
	})();
	exports.DescriminatorOrReferenceValidator = DescriminatorOrReferenceValidator;
	/**
	 * validates examples
	 */
	var ExampleValidator = (function () {
	    function ExampleValidator() {
	    }
	    ExampleValidator.prototype.validate = function (node, cb) {
	        //check if we expect to do strict validation
	        var strictValidation = this.isStrict(node);
	        if (!strictValidation) {
	            if (!settings.validateNotStrictExamples) {
	                return;
	            }
	        }
	        var pObj = this.parseObject(node, cb, strictValidation);
	        if (!pObj) {
	            return;
	        }
	        var schema = this.aquireSchema(node);
	        if (schema) {
	            schema.validate(pObj, cb, strictValidation);
	        }
	    };
	    ExampleValidator.prototype.aquireSchema = function (node) {
	        var sp = node.parent().definition().isAssignableFrom("DataElement");
	        if (node.name() == "example") {
	            if (node.parent().property().name() == "types") {
	                sp = false;
	            }
	            if (node.parent().parent()) {
	                if (node.parent().parent().definition().name() == "Method") {
	                    if (node.parent().property().name() == "queryParameters") {
	                    }
	                    else {
	                        sp = true;
	                    }
	                }
	                if (node.parent().parent().definition().name() == "Response") {
	                    sp = true;
	                }
	            }
	        }
	        if (node.parent().definition().name() == "BodyLike" || sp) {
	            //FIXME MULTIPLE INHERITANCE
	            var sa = node.parent().attr("schema");
	            if (!sa) {
	                sa = node.parent().attr("type");
	            }
	            if (sa) {
	                var val = sa.value();
	                if (val instanceof hlimpl.StructuredValue) {
	                    return null;
	                }
	                var strVal = ("" + val).trim();
	                var so = null;
	                if (strVal.charAt(0) == "{") {
	                    try {
	                        so = su.getJSONSchema(strVal);
	                    }
	                    catch (e) {
	                        return null;
	                    }
	                }
	                if (strVal.charAt(0) == "<") {
	                    try {
	                        so = su.getXMLSchema(strVal);
	                    }
	                    catch (e) {
	                        return null;
	                    }
	                }
	                if (so) {
	                    return {
	                        validate: function (pObje, cb, strict) {
	                            try {
	                                so.validateObject(pObje);
	                            }
	                            catch (e) {
	                                cb.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Example does not conforms to schema:" + e.message, node, !strict));
	                                return;
	                            }
	                            //validate using classical schema;
	                        }
	                    };
	                }
	                else {
	                    //lets try to get schema from type
	                    if (strVal.length > 0) {
	                        var tp = typeExpression.getType2(node.parent(), strVal, {});
	                        if (tp) {
	                            return {
	                                validate: function (pObje, cb, strict) {
	                                    new TypeValidator(node).validate(pObje, tp, cb, strict);
	                                    //validate using typeExpression;
	                                }
	                            };
	                        }
	                    }
	                }
	            }
	        }
	        return this.getSchemaFromModel(node);
	    };
	    ExampleValidator.prototype.getSchemaFromModel = function (node) {
	        var p = node.parent();
	        if (node.property().name() == "content") {
	            p = p.parent();
	        }
	        var tp = hlimpl.typeFromNode(p);
	        if (tp) {
	            return {
	                validate: function (pObje, cb, strict) {
	                    new TypeValidator(node).validate(pObje, tp, cb, strict);
	                    //validate using typeExpression;
	                }
	            };
	        }
	        return null;
	    };
	    ExampleValidator.prototype.toObject = function (h, v, cb) {
	        var res = v.lowLevel().dumpToObject(true);
	        this.testDublication(h, v.lowLevel(), cb);
	        if (res["example"]) {
	            return res["example"];
	        }
	        if (res["content"]) {
	            return res["content"];
	        }
	    };
	    ExampleValidator.prototype.testDublication = function (h, v, cb) {
	        var _this = this;
	        var map = {};
	        v.children().forEach(function (x) {
	            if (x.key()) {
	                if (map[x.key()]) {
	                    cb.accept(createIssue(5 /* KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT */, "Keys should be unique", new hlimpl.BasicASTNode(x, h.parent())));
	                }
	                map[x.key()] = x;
	            }
	            _this.testDublication(h, x, cb);
	        });
	    };
	    ExampleValidator.prototype.parseObject = function (node, cb, strictValidation) {
	        var pObj = null;
	        var vl = node.value();
	        var mediaType = getMediaType(node);
	        if (vl instanceof hlimpl.StructuredValue) {
	            //validate in context of type/schema
	            pObj = this.toObject(node, vl, cb);
	        }
	        else {
	            if (mediaType) {
	                if (isJson(mediaType)) {
	                    try {
	                        pObj = JSON.parse(vl);
	                    }
	                    catch (e) {
	                        cb.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Can not parse JSON:" + e.message, node, !strictValidation));
	                        return;
	                    }
	                }
	                if (isXML(mediaType)) {
	                    try {
	                        pObj = xmlutil(vl);
	                    }
	                    catch (e) {
	                        cb.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Can not parse XML:" + e.message, node, !strictValidation));
	                        return;
	                    }
	                }
	            }
	            else {
	                try {
	                    pObj = JSON.parse(vl);
	                }
	                catch (e) {
	                    if (vl.trim().indexOf("<") == 0) {
	                        try {
	                            pObj = xmlutil(vl);
	                        }
	                        catch (e) {
	                            cb.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Can not parse XML:" + e.message, node, !strictValidation));
	                            return;
	                        }
	                    }
	                    else {
	                        //cb.accept(hlimpl.createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "Can not parse JSON:" + e.message, node, !strictValidation));
	                        return vl;
	                    }
	                }
	            }
	        }
	        return pObj;
	    };
	    ExampleValidator.prototype.isStrict = function (node) {
	        var strictValidation = false;
	        var strict = node.parent().attr("strict");
	        if (strict) {
	            if (strict.value() == 'true') {
	                strictValidation = true;
	            }
	        }
	        return strictValidation;
	    };
	    return ExampleValidator;
	})();
	exports.ExampleValidator = ExampleValidator;
	function isJson(s) {
	    return s.indexOf("json") != -1;
	}
	function isXML(s) {
	    return s.indexOf("xml") != -1;
	}
	function getMediaType(node) {
	    var vl = getMediaType2(node);
	    if (vl == 'body') {
	        var rootMedia = node.root().attr("mediaType");
	        if (rootMedia) {
	            return rootMedia.value();
	        }
	        return null;
	    }
	    return vl;
	}
	function getMediaType2(node) {
	    if (node.parent()) {
	        if (node.parent().definition().isAssignableFrom("BodyLike") && !node.parent().definition().isUserDefined()) {
	            return node.parent().name();
	        }
	        if (node.parent().parent()) {
	            if (node.parent().parent().definition().isAssignableFrom("Response") && !node.parent().parent().definition().isUserDefined()) {
	                if (node.parent().property().name() == "headers") {
	                    return null;
	                }
	                return node.parent().name();
	            }
	            if (node.parent().parent().definition().isAssignableFrom("Method") && !node.parent().parent().definition().isUserDefined()) {
	                if (node.parent().property().name() == "queryParameters" || node.parent().property().name() == "headers") {
	                    return null;
	                }
	                return node.parent().name();
	            }
	        }
	    }
	    return null;
	}
	var localError = function (node, c, w, message, p, prop) {
	    var st = node.lowLevel().start();
	    var et = node.lowLevel().end();
	    if (node.lowLevel().key() && node.lowLevel().keyStart()) {
	        var ks = node.lowLevel().keyStart();
	        if (ks > 0) {
	            st = ks;
	        }
	        var ke = node.lowLevel().keyEnd();
	        if (ke > 0) {
	            et = ke;
	        }
	    }
	    if (et < st) {
	        et = st + 1; //FIXME
	    }
	    if (prop && !prop.isMerged() && node.parent() == null) {
	        var nm = _.find(node.lowLevel().children(), function (x) { return x.key() == prop.name(); });
	        if (nm) {
	            var ks = nm.keyStart();
	            var ke = nm.keyEnd();
	            if (ks > 0 && ke > ks) {
	                st = ks;
	                et = ke;
	            }
	        }
	    }
	    return {
	        code: c,
	        isWarning: w,
	        message: message,
	        node: node,
	        start: st,
	        end: et,
	        path: p ? (node.lowLevel().unit() ? node.lowLevel().unit().path() : "") : null,
	        extras: [],
	        unit: node ? node.lowLevel().unit() : null
	    };
	};
	function createIssue(c, message, node, w) {
	    if (w === void 0) { w = false; }
	    //console.log(node.name()+node.lowLevel().start()+":"+node.id());
	    var original = null;
	    var pr = null;
	    if (node) {
	        pr = node.property();
	        if (node.lowLevel().unit() != node.root().lowLevel().unit()) {
	            original = localError(node, c, w, message, true, pr);
	            var v = node.lowLevel().unit();
	            if (v) {
	                message = message + " " + v.path();
	            }
	            while (node.lowLevel().unit() != node.root().lowLevel().unit()) {
	                pr = node.property();
	                node = node.parent();
	            }
	        }
	    }
	    if (original) {
	        if (node.property() && node.property().name() == "uses" && node.parent() != null) {
	            pr = node.property(); //FIXME there should be other cases
	            node = node.parent();
	        }
	    }
	    var error = localError(node, c, w, message, false, pr);
	    if (original) {
	        error.extras.push(original);
	    }
	    //console.log(error.start+":"+error.end)
	    return error;
	}
	exports.createIssue = createIssue;
	//# sourceMappingURL=linter.js.map

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/tsd.d.ts" />
	var defs = __webpack_require__(21);
	var ts2Def = __webpack_require__(39);
	var _ = __webpack_require__(47);
	var selector = __webpack_require__(55);
	var typeExpression = __webpack_require__(31);
	var hlimpl = __webpack_require__(7);
	var linter = __webpack_require__(33);
	function templateFields(node, d) {
	    var u = node.root().definition().universe();
	    node.children().forEach(function (x) { return templateFields(x, d); });
	    if (node instanceof hlimpl.ASTPropImpl) {
	        var prop = node;
	        //TODO RECURSIVE PARAMETERS
	        var v = prop.value();
	        if (typeof v == 'string') {
	            var strV = v;
	            handleValue(strV, d, prop, false, u);
	        }
	        else {
	            node.lowLevel().visit(function (x) {
	                if (x.value()) {
	                    var strV = x.value() + "";
	                    handleValue(strV, d, prop, true, u);
	                }
	                return true;
	            });
	        }
	    }
	    else if (node instanceof hlimpl.BasicASTNode) {
	        var v = node.lowLevel().value();
	        if (typeof v == 'string') {
	            var strV = v;
	            handleValue(strV, d, null, false, u);
	        }
	        else {
	            node.lowLevel().visit(function (x) {
	                if (x.value()) {
	                    var strV = x.value() + "";
	                    handleValue(strV, d, null, true, u);
	                }
	                return true;
	            });
	        }
	    }
	}
	var handleValue = function (strV, d, prop, allwaysString, u) {
	    var ps = 0;
	    while (true) {
	        var pos = strV.indexOf("<<", ps);
	        if (pos != -1) {
	            var end = strV.indexOf(">>", pos);
	            var isFull = pos == 0 && end == strV.length - 2;
	            var parameterUsage = strV.substring(pos + 2, end);
	            ps = pos + 2;
	            var directiveIndex = parameterUsage.indexOf("|");
	            if (directiveIndex != -1) {
	                parameterUsage = parameterUsage.substring(0, directiveIndex);
	            }
	            parameterUsage = parameterUsage.trim();
	            if (parameterUsage == "resourcePathName" || parameterUsage == "methodName" || parameterUsage == "resourcePath") {
	                continue;
	            }
	            var q = d[parameterUsage];
	            var r = (prop) ? prop.property().range() : null;
	            if (prop) {
	                if (prop.property().name() == "type" || prop.property().name() == "schema") {
	                    if (prop.property().domain().name() == "DataElement") {
	                        r = u.getType("SchemaString");
	                    }
	                }
	            }
	            if (!isFull || allwaysString) {
	                r = u.getType("StringType");
	            }
	            //FIX ME NOT WHOLE TEMPLATES
	            if (q) {
	                q.push({
	                    tp: r,
	                    attr: prop
	                });
	            }
	            else {
	                d[parameterUsage] = [{
	                    tp: r,
	                    attr: prop
	                }];
	            }
	        }
	        else
	            break;
	    }
	};
	function typeFromNode(node) {
	    if (!node) {
	        return null;
	    }
	    if (node.associatedType()) {
	        return node.associatedType();
	    }
	    if (node.property() && node.property().name() == "annotationTypes") {
	        var result = new defs.AnnotationType(node.name(), node.definition().universe(), node, node.lowLevel().unit().path(), "");
	    }
	    else {
	        var result = new defs.UserDefinedClass(node.name(), node.definition().universe(), node, node.lowLevel().unit().path(), "");
	    }
	    node.setAssociatedType(result);
	    //result.setDeclaringNode(node);
	    var def = node.definition();
	    if (def.isInlinedTemplates()) {
	        var usages = {};
	        templateFields(node, usages);
	        Object.keys(usages).forEach(function (x) {
	            var prop = new defs.UserDefinedProp(x);
	            //prop._node=node;
	            prop.withDomain(result);
	            var tp = _.unique(usages[x]).map(function (x) { return x.tp; }).filter(function (x) { return x && x.name() != "StringType"; });
	            prop.withRange(tp.length == 1 ? tp[0] : node.definition().universe().getType("StringType"));
	            prop.withRequired(true);
	            if (usages[x].length > 0) {
	                prop._node = usages[x][0].attr;
	            }
	            prop.unmerge();
	        });
	        var keyProp = new defs.UserDefinedProp("key");
	        //prop._node=node;
	        keyProp.withDomain(result);
	        keyProp.withKey(true);
	        keyProp._node = node;
	        keyProp.withFromParentKey(true);
	        keyProp.withRange(node.definition().universe().getType("StringType"));
	    }
	    else if (def.getReferenceIs()) {
	        if (def.universe().version() == "RAML08") {
	            result.withAllowAny();
	        }
	        var p = def.property(def.getReferenceIs());
	        if (p) {
	            p.range().properties().forEach(function (x) {
	                var prop = new defs.Property(x.name());
	                prop.unmerge();
	                prop.withDomain(result);
	                prop.withRange(x.range());
	                prop.withMultiValue(x.isMultiValue());
	            });
	        }
	    }
	    else {
	        var rp = def.findMembersDeterminer();
	        if (rp) {
	            var elements = node.elementsOfKind(rp.name());
	            elements.forEach(function (x) {
	                var prop = elementToProp(x);
	                prop.withDomain(result);
	            });
	        }
	        //here we should found correct inheritance chain
	        var types = node.attributes("type");
	        var schema = node.attributes("schema");
	        types = types.concat(schema);
	        if (node.definition().name() == "GlobalSchema") {
	            var vl = node.attributes("value");
	            types = types.concat(vl);
	        }
	        var tp = types.length != 0;
	        types.forEach(function (tp) {
	            var vl = tp.value();
	            if (typeof vl == 'string' && vl) {
	                vl = vl.trim();
	                if (vl.charAt(0) == '{') {
	                    var et = new defs.ExternalType(node.name(), node.definition().universe(), node.lowLevel().unit().path(), "");
	                    et.schemaString = vl;
	                    et.node = node;
	                    var de = node.definition().universe().getType("ObjectField");
	                    if (de) {
	                        result._superTypes.push(de);
	                    }
	                    result._superTypes.push(et);
	                }
	                if (vl.charAt(0) == '<') {
	                    var et = new defs.ExternalType(node.name(), node.definition().universe(), node.lowLevel().unit().path(), "");
	                    et.schemaString = vl;
	                    et.node = node;
	                    var de = node.definition().universe().getType("ObjectField");
	                    if (de) {
	                        result._superTypes.push(de);
	                    }
	                    result._superTypes.push(et);
	                }
	            }
	            var types = {};
	            types[result.name()] = result;
	            var at = null;
	            if (vl != result.name()) {
	                at = typeExpression.getType(node.parent(), vl, types);
	            }
	            else {
	            }
	            if (at) {
	                result._superTypes.push(at);
	            }
	        });
	        result.addRequirement("type", node.name());
	        if (def.getExtendedType()) {
	            result._superTypes.push(def.getExtendedType());
	        }
	        {
	            //Adding runtime properties for object types TODO it should be done in more elegant way
	            var prop = _.find(node.lowLevel().children(), function (x) { return x.key() == "properties"; });
	            if (prop) {
	                var de = node.definition().universe().getType("ObjectField");
	                if (de) {
	                    result._superTypes.push(de);
	                }
	            }
	            else {
	                if (node.property() && node.property().name() == "body") {
	                    var de = node.definition().universe().getType("ObjectField");
	                    if (de) {
	                        result._superTypes.push(de);
	                    }
	                }
	                else if (!tp) {
	                    var de = node.definition().universe().getType("StrElement");
	                    if (de && node.definition().name() != "BodyLike" && node.definition().name() != "AnnotationType") {
	                        result._superTypes.push(de);
	                    }
	                }
	                if (result._superTypes.length == 0) {
	                    var de = node.definition().universe().getType("DataElement");
	                    if (de) {
	                        result._superTypes.push(de);
	                    }
	                }
	            }
	            var pn = node.definition().universe().getType("ObjectField");
	            if (pn) {
	                node.lowLevel().children().forEach(function (x) {
	                    if (x.key() == "facets") {
	                        return;
	                    }
	                    if (x.key() == "annotations") {
	                        return;
	                    }
	                    if (x.key() == "properties") {
	                        return;
	                    }
	                    if (!pn.property(x.key())) {
	                        result.fixFacet(x.key(), x);
	                    }
	                });
	            }
	        }
	    }
	    return result;
	}
	exports.typeFromNode = typeFromNode;
	function parsePropertyName(name) {
	    var v = { name: "", regexp: null };
	    if (name.length > 2) {
	        name = name.substr(1, name.length - 2);
	        var pos = name.lastIndexOf("#");
	        if (pos != -1) {
	            v.name = name.substr(pos + 1);
	            v.regexp = name.substr(0, pos);
	        }
	        else {
	            v.regexp = name;
	        }
	    }
	    return v;
	}
	exports.parsePropertyName = parsePropertyName;
	function libraryLocation(definition) {
	    var node = definition.getDeclaringNode();
	    var result = null;
	    if (node != null) {
	        var library = node.parent();
	        if (library) {
	            var libraryAnnotations = library.attributes("annotations");
	            libraryAnnotations.forEach(function (x) {
	                var value = x.value();
	                if (value instanceof hlimpl.StructuredValue) {
	                    if (value.lowLevel().key() == "(LibraryLocation)") {
	                        var hlv = value.toHighlevel(library);
	                        if (hlv) {
	                            result = valueOf(hlv);
	                        }
	                    }
	                }
	            });
	        }
	    }
	    return result;
	}
	exports.libraryLocation = libraryLocation;
	function valueOf(hl) {
	    if (hl) {
	        var vl = hl.attr("value");
	        if (vl) {
	            return vl.value();
	        }
	    }
	    return null;
	}
	exports.valueOf = valueOf;
	var scriptToValidator = {};
	var loophole = __webpack_require__(48);
	function evalInSandbox(code, thisArg, args) {
	    return new loophole.Function(code).call(thisArg, args);
	}
	var ValidatorHolder = (function () {
	    function ValidatorHolder() {
	    }
	    ValidatorHolder.prototype.register = function (mm) {
	        this._result = mm;
	    };
	    return ValidatorHolder;
	})();
	function aquireValidator(value) {
	    if (value) {
	        var nm = scriptToValidator[value];
	        if (nm) {
	            if (nm == aquireValidator) {
	                return null;
	            }
	            return nm;
	        }
	        try {
	            var holder = new ValidatorHolder();
	            evalInSandbox(value, holder, []);
	            if (holder._result) {
	                scriptToValidator[value] = holder._result;
	                return holder._result;
	            }
	            else {
	                scriptToValidator[value] = aquireValidator;
	            }
	        }
	        catch (e) {
	            scriptToValidator[value] = aquireValidator;
	        }
	    }
	    return null;
	}
	exports.aquireValidator = aquireValidator;
	function elementToProp(e, toRuntime) {
	    if (toRuntime === void 0) { toRuntime = false; }
	    var nm = e.name();
	    var optional = false;
	    if (nm.length > 0 && nm.charAt(nm.length - 1) == '?') {
	        nm = nm.substr(0, nm.length - 1);
	        optional = true;
	    }
	    var result = new defs.UserDefinedProp(nm);
	    result._node = e;
	    try {
	        var example = e.attr("example");
	        if (example) {
	            var obj = new linter.ExampleValidator().parseObject(example, {
	                begin: function () {
	                },
	                end: function () {
	                },
	                accept: function (f) {
	                }
	            }, false);
	            result.setDefaultVal(obj);
	        }
	        else {
	            var exampleElements = e.elementsOfKind("examples");
	            exampleElements.forEach(function (x) {
	                var cnt = x.attr("content");
	                if (cnt) {
	                    var obj = new linter.ExampleValidator().parseObject(cnt, {
	                        begin: function () {
	                        },
	                        end: function () {
	                        },
	                        accept: function (f) {
	                        }
	                    }, false);
	                    result.setDefaultVal(obj);
	                }
	            });
	        }
	    }
	    catch (e) {
	        console.log(e); //TODO remove me
	    }
	    var annotations = e.attributes("annotations");
	    annotations.forEach(function (annotation) {
	        var value = annotation.value();
	        if (value instanceof hlimpl.StructuredValue) {
	            var highLevel = value.toHighlevel(e);
	            if (highLevel) {
	                var definition = highLevel.definition();
	                if (definition.name() == "FacetInstanceValidator") {
	                    var node = definition.getDeclaringNode();
	                    var ll = libraryLocation(definition);
	                    if (ll == "http://raml.org/library/common.raml") {
	                        var value = valueOf(highLevel);
	                        var facetValidator = aquireValidator(value);
	                        if (facetValidator) {
	                            result.setFacetValidator(facetValidator);
	                        }
	                    }
	                }
	            }
	        }
	    });
	    if (nm.length > 0) {
	        if (nm[0] == '[') {
	            optional = true;
	            var info = parsePropertyName(nm);
	            if (info.regexp) {
	                result.withKeyRegexp(info.regexp);
	            }
	            else {
	                result.withKeyRestriction("");
	            }
	            if (info.name) {
	                result.withDescription(info.name);
	            }
	            result.withMultiValue();
	        }
	        else {
	            result.unmerge();
	        }
	    }
	    var props = e.definition().properties();
	    var tp = e.attr("type");
	    if (tp) {
	        var typeName = tp.value();
	        if (typeName == "any") {
	            result.withMultiValue(true);
	            var rm = new defs.NodeClass("ObjectField", e.definition().universe(), "", "");
	            rm.withAllowAny();
	            result.withRange(rm);
	        }
	        else {
	            var tpv = typeExpression.getType(e, typeName, {}, true);
	            if (tpv) {
	                tpv = tpv.toRuntime();
	                if (tpv instanceof defs.Array) {
	                    var at = tpv;
	                    //FIXME
	                    at._af = {};
	                    //var fs=tpv.getFixedFacets();
	                    //for (var i in fs){
	                    //    at._af[i]=fs[i];
	                    //}
	                    at.findFacets(e, at._af);
	                }
	            }
	            result.withRange(tpv);
	        }
	        //FIXME
	        if (typeName == "pointer") {
	            var scope = e.attr("target");
	            if (scope) {
	                try {
	                    var sm = selector.parse(e, "" + scope.value());
	                    result.setSelector(sm);
	                }
	                catch (e) {
	                }
	            }
	        }
	    }
	    //FIXME Literals
	    if (nm == "value" && e.parent() && e.parent().definition().isAssignableFrom("AnnotationType")) {
	        result.withCanBeValue();
	    }
	    e.definition().allProperties().forEach(function (p) {
	        if (p.name() != "type") {
	            if (p.describesAnnotation()) {
	                var annotationName = p.describedAnnotation();
	                var args = [];
	                var vl = e.attributes(p.name()).map(function (a) { return a.value(); });
	                if (vl.length == 1) {
	                    args.push(vl[0]);
	                }
	                else {
	                    args.push(vl);
	                }
	                //TODO ANNOTATIONS WITH MULTIPLE ARGUMENTS
	                var an = {
	                    name: annotationName,
	                    arguments: args
	                };
	                ts2Def.recordAnnotation(result, an);
	            }
	        }
	    });
	    if (optional) {
	        result.withRequired(false);
	    }
	    var vn = _.find(e.lowLevel().children(), function (x) { return x.key() == "properties"; });
	    if (vn) {
	        var of = e.definition().universe().getType("ObjectField");
	        var node = new hlimpl.ASTNodeImpl(e.lowLevel(), e.parent(), of, result);
	        var nc = new defs.UserDefinedClass("", of.universe(), node, e.lowLevel().unit().path(), "");
	        nc._superTypes.push(of);
	        result.withRange(nc.toRuntime());
	    }
	    if (result.range() == null) {
	        result.withRange(new defs.ValueType("String", e.definition().universe(), ""));
	    }
	    if (result.range().name() == "ObjectField" && result.range() instanceof defs.NodeClass) {
	        var rm = new defs.NodeClass("ObjectField", result.range().universe(), "", "");
	        rm.withAllowAny();
	        result.withRange(rm);
	    }
	    return result;
	}
	exports.elementToProp = elementToProp;
	//# sourceMappingURL=typeBuilder.js.map

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/tsd.d.ts" />
	var defs = __webpack_require__(21);
	var hl = __webpack_require__(17);
	var _ = __webpack_require__(47);
	var typeExpression = __webpack_require__(31);
	var ramlSignature = __webpack_require__(16);
	var hlimpl = __webpack_require__(7);
	var typeBuilder = __webpack_require__(34);
	//FIXME CORRECTLY STRUCTURE IT
	function resolveRamlPointer(point, path) {
	    var components = path.split(".");
	    var currentNode = point;
	    if (currentNode.definition().isAnnotation()) {
	        currentNode = currentNode.parent();
	    }
	    components.forEach(function (x) {
	        if (currentNode == null) {
	            return;
	        }
	        if (x == '$parent') {
	            currentNode = currentNode.parent();
	            return;
	        }
	        if (x == '$root') {
	            currentNode = currentNode.root();
	            return;
	        }
	        if (x == '$top') {
	            currentNode = exports.declRoot(currentNode);
	            return;
	        }
	        var newEl = _.find(currentNode.elements(), function (y) { return y.name() == x; });
	        currentNode = newEl;
	    });
	    return currentNode;
	}
	exports.resolveRamlPointer = resolveRamlPointer;
	exports.declRoot = function (h) {
	    var declRoot = h;
	    while (true) {
	        if (declRoot.definition().name() == "Library" && (!declRoot.definition().isUserDefined())) {
	            break;
	        }
	        var np = declRoot.parent();
	        if (!np) {
	            break;
	        }
	        declRoot = np;
	    }
	    return declRoot;
	};
	function globalDeclarations(h) {
	    var decl = exports.declRoot(h);
	    return findDeclarations(decl);
	}
	exports.globalDeclarations = globalDeclarations;
	function mark(h, rs) {
	    var n = h.lowLevel();
	    n = n._node ? n._node : n;
	    if (n['mark']) {
	        return rs;
	    }
	    n['mark'] = rs;
	    return null;
	}
	function unmark(h) {
	    var n = h.lowLevel();
	    n = n._node ? n._node : n;
	    delete n['mark'];
	}
	function findDeclarations(h) {
	    var rs = [];
	    var q = mark(h, rs);
	    if (q) {
	    }
	    try {
	        h.elements().forEach(function (x) {
	            if (x.definition().name() == "Library") {
	                rs = rs.concat(findDeclarations(x));
	            }
	            rs.push(x);
	        });
	        return rs;
	    }
	    finally {
	        unmark(h);
	    }
	}
	exports.findDeclarations = findDeclarations;
	function getIndent2(offset, text) {
	    var spaces = "";
	    for (var i = offset - 1; i >= 0; i--) {
	        var c = text.charAt(i);
	        if (c == ' ' || c == '\t') {
	            if (spaces) {
	                spaces += c;
	            }
	            else {
	                spaces = c;
	            }
	        }
	        else if (c == '\r' || c == '\n') {
	            return spaces;
	        }
	    }
	}
	function deepFindNode(n, offset, end, goToOtherUnits) {
	    if (goToOtherUnits === void 0) { goToOtherUnits = true; }
	    if (n == null) {
	        return null;
	    }
	    if (n.lowLevel()) {
	        //var node:ASTNode=<ASTNode>n;
	        if (n.lowLevel().start() <= offset && n.lowLevel().end() >= end) {
	            if (n instanceof hlimpl.ASTNodeImpl) {
	                var hn = n;
	                var all = goToOtherUnits ? hn.children() : hn.directChildren();
	                for (var i = 0; i < all.length; i++) {
	                    if (!goToOtherUnits && all[i].lowLevel().unit() != n.lowLevel().unit()) {
	                        continue;
	                    }
	                    var node = deepFindNode(all[i], offset, end, goToOtherUnits);
	                    if (node) {
	                        return node;
	                    }
	                }
	                return n;
	            }
	            if (n instanceof hlimpl.ASTPropImpl) {
	                var attr = n;
	                if (!attr.property().isKey()) {
	                    var vl = attr.value();
	                    if (vl instanceof hlimpl.StructuredValue) {
	                        var st = vl;
	                        var hl = st.toHighlevel();
	                        if (hl) {
	                            if (!goToOtherUnits && hl.lowLevel().unit() != n.lowLevel().unit()) {
	                                return null;
	                            }
	                        }
	                        var node = deepFindNode(hl, offset, end, goToOtherUnits);
	                        if (node) {
	                            return node;
	                        }
	                    }
	                    return attr;
	                }
	                return null;
	            }
	            return n;
	        }
	    }
	    return null;
	}
	function getValueAt(text, offset) {
	    var sp = -1;
	    for (var i = offset - 1; i >= 0; i--) {
	        var c = text.charAt(i);
	        if (c == '\r' || c == '\n' || c == ' ' || c == '\t' || c == '"' || c == '\'' || c == ':') {
	            sp = i + 1;
	            break;
	        }
	    }
	    var ep = -1;
	    for (var i = offset; i < text.length; i++) {
	        var c = text.charAt(i);
	        if (c == '\r' || c == '\n' || c == ' ' || c == '\t' || c == '"' || c == '\'' || c == ':') {
	            ep = i;
	            break;
	        }
	    }
	    if (sp != -1 && ep != -1) {
	        return text.substring(sp, ep);
	    }
	    return "";
	}
	function extractName(cleaned, offset) {
	    var txt = "";
	    for (var i = offset; i >= 0; i--) {
	        var c = cleaned[i];
	        if (c == ' ' || c == '\r' || c == '\n' || c == '|' || c == '[' || c == ']' || c == ':' || c == '(' || c == ')') {
	            break;
	        }
	        txt = c + txt;
	    }
	    for (var i = offset + 1; i < cleaned.length; i++) {
	        var c = cleaned[i];
	        if (c == ' ' || c == '\r' || c == '\n' || c == '|' || c == '[' || c == ']' || c == ':' || c == '(' || c == ')') {
	            break;
	        }
	        txt = txt + c;
	    }
	    return txt;
	}
	exports.extractName = extractName;
	var searchInTheValue = function (offset, content, attr, hlnode, p) {
	    if (p === void 0) { p = attr.property(); }
	    var targets = p.referenceTargets(hlnode);
	    var txt = extractName(content, offset);
	    var t = _.find(targets, function (x) { return hlimpl.qName(x, hlnode) == txt; });
	    if (t) {
	        //TODO EXTRACT COMMON OPEN NODE FUNC
	        return t;
	    }
	    if (attr.property() instanceof defs.UserDefinedProp) {
	        var up = attr.property();
	        return up._node;
	    }
	    return null;
	};
	function findUsages(unit, offset) {
	    var decl = findDeclaration(unit, offset);
	    if (decl) {
	        if (decl instanceof hlimpl.ASTNodeImpl) {
	            var hnode = decl;
	            return { node: hnode, results: hnode.findReferences() };
	        }
	        if (decl instanceof hlimpl.ASTPropImpl) {
	        }
	    }
	    var node = deepFindNode(hl.fromUnit(unit), offset, offset, false);
	    if (node instanceof hlimpl.ASTNodeImpl) {
	        return { node: node, results: node.findReferences() };
	    }
	    if (node instanceof hlimpl.ASTPropImpl) {
	        var prop = node;
	        if (prop.property().canBeValue()) {
	            return { node: prop.parent(), results: prop.parent().findReferences() };
	        }
	    }
	    return { node: null, results: [] };
	}
	exports.findUsages = findUsages;
	function findDeclaration(unit, offset) {
	    var node = deepFindNode(hl.fromUnit(unit), offset, offset, false);
	    var kind = determineCompletionKind(unit.contents(), offset);
	    if (kind == 0 /* VALUE_COMPLETION */) {
	        var hlnode = node;
	        if (node instanceof hlimpl.ASTPropImpl) {
	            var attr = node;
	            if (attr) {
	                if (attr.value()) {
	                    if (attr.value() instanceof hlimpl.StructuredValue) {
	                        var sval = attr.value();
	                        var hlvalue = sval.toHighlevel();
	                        if (hlvalue) {
	                            var newAttr = _.find(hlvalue.attrs(), function (x) { return x.lowLevel().start() < offset && x.lowLevel().end() >= offset; });
	                            if (newAttr) {
	                                return searchInTheValue(offset, unit.contents(), newAttr, hlvalue, attr.property());
	                            }
	                        }
	                    }
	                    else {
	                        return searchInTheValue(offset, unit.contents(), attr, hlnode);
	                    }
	                }
	            }
	        }
	    }
	    if (kind == 1 /* KEY_COMPLETION */ || kind == 6 /* SEQUENCE_KEY_COPLETION */) {
	        var hlnode = node;
	        var pp = node.property();
	        if (pp instanceof defs.UserDefinedProp) {
	            var up = pp;
	            return up.node();
	        }
	        if (node instanceof hlimpl.ASTNodeImpl) {
	            if (hlnode.definition() instanceof defs.UserDefinedClass) {
	                var uc = hlnode.definition();
	                if (uc.isAssignableFrom("DataElement")) {
	                    return node;
	                }
	                return uc.getDeclaringNode();
	            }
	        }
	        if (node instanceof hlimpl.ASTPropImpl) {
	            var pr = node;
	            if (isExampleNodeContent(pr)) {
	                var contentType = findExampleContentType(pr);
	                if (contentType) {
	                    var documentationRoot = parseDocumentationContent(pr, contentType.toRuntime());
	                    if (documentationRoot) {
	                        var node = deepFindNode(documentationRoot, offset, offset);
	                        var pp = node.property();
	                        if (pp instanceof defs.UserDefinedProp) {
	                            var up = pp;
	                            return up.node();
	                        }
	                        if (node instanceof hlimpl.ASTNodeImpl) {
	                            if (hlnode.definition() instanceof defs.UserDefinedClass) {
	                                var uc = hlnode.definition();
	                                return uc.getDeclaringNode();
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	    if (kind == 2 /* PATH_COMPLETION */) {
	        var inclpath = getValueAt(unit.contents(), offset);
	        if (inclpath) {
	            var ap = unit.resolve(inclpath);
	            return ap;
	        }
	    }
	}
	exports.findDeclaration = findDeclaration;
	function findExampleContentType(node) {
	    var p = node.parent();
	    if (node.property().name() == "content") {
	        p = p.parent();
	    }
	    return hlimpl.typeFromNode(p);
	}
	exports.findExampleContentType = findExampleContentType;
	function parseDocumentationContent(attribute, type) {
	    if (!(attribute.value() instanceof hlimpl.StructuredValue)) {
	        return null;
	    }
	    return new hlimpl.ASTNodeImpl(attribute.value().lowLevel(), attribute.parent(), type, attribute.property());
	}
	exports.parseDocumentationContent = parseDocumentationContent;
	function isExampleNodeContent(node) {
	    if (!(node instanceof hlimpl.ASTPropImpl)) {
	        return false;
	    }
	    var property = node;
	    if ("content" == property.name() && "StringType" == property.definition().name()) {
	        if (property.parent() instanceof hlimpl.ASTNodeImpl && ("examples" == property.parent().property().name() || "example" == property.parent().property().name())) {
	            if (property.parent().parent() instanceof hlimpl.ASTNodeImpl && property.parent().parent().definition().isAssignableFrom("ObjectField")) {
	                return true;
	            }
	        }
	    }
	    else if ("example" == property.name() && "StringType" == property.definition().name()) {
	        if (property.parent() instanceof hlimpl.ASTNodeImpl && property.parent().definition().isAssignableFrom("ObjectField")) {
	            return true;
	        }
	    }
	    return false;
	}
	exports.isExampleNodeContent = isExampleNodeContent;
	function determineCompletionKind(text, offset) {
	    var hasIn = false;
	    var hasSeq = false;
	    var canBeInComment = false;
	    var canBeAnnotation = false;
	    for (var i = offset - 1; i >= 0; i--) {
	        var c = text.charAt(i);
	        if (c == '(') {
	            canBeAnnotation = true;
	        }
	        else if (canBeAnnotation) {
	            if (c == '\r' || c == '\n') {
	                var hasClosing = false;
	                for (var j = offset - 1; j < text.length; j++) {
	                    var ch = text[j];
	                    if (ch == ')') {
	                        hasClosing = true;
	                    }
	                    if (ch == '\r' || ch == "\n") {
	                        break;
	                    }
	                    if (ch == ':') {
	                        canBeAnnotation = false;
	                        break;
	                    }
	                }
	                if (canBeAnnotation && hasClosing) {
	                    return 5 /* ANNOTATION_COMPLETION */;
	                }
	                else {
	                    break;
	                }
	            }
	            if (c == ' ' || c == '\t') {
	                continue;
	            }
	            else {
	                break;
	            }
	        }
	        else {
	            if (c == '\r' || c == '\n') {
	                break;
	            }
	            if (c == ':') {
	                break;
	            }
	        }
	    }
	    for (var i = offset - 1; i >= 0; i--) {
	        var c = text.charAt(i);
	        if (c == '#') {
	            if (i == 0) {
	                return 4 /* VERSION_COMPLETION */;
	            }
	            return 7 /* INCOMMENT */;
	        }
	        if (c == ':') {
	            if (hasIn) {
	                return 3 /* DIRECTIVE_COMPLETION */;
	            }
	            return 0 /* VALUE_COMPLETION */;
	        }
	        if (c == '\r' || c == '\n') {
	            //check for multiline literal
	            var insideOfMultiline = false;
	            var ind = getIndent2(offset, text);
	            for (var a = i; a > 0; a--) {
	                c = text.charAt(a);
	                //TODO this can be further improved
	                if (c == ':') {
	                    if (insideOfMultiline) {
	                        var ll = getIndent2(a, text);
	                        if (ll.length < ind.length) {
	                            return 0 /* VALUE_COMPLETION */;
	                        }
	                    }
	                    break;
	                }
	                if (c == '|') {
	                    insideOfMultiline = true;
	                    continue;
	                }
	                if (c == '\r' || c == '\n') {
	                    insideOfMultiline = false;
	                }
	                if (c != ' ' && c != '\t') {
	                    insideOfMultiline = false;
	                }
	            }
	            if (hasSeq) {
	                return 6 /* SEQUENCE_KEY_COPLETION */;
	            }
	            return 1 /* KEY_COMPLETION */;
	        }
	        if (c == '-') {
	            hasSeq = true;
	        }
	        if (c == '!') {
	            if (text.indexOf("!include", i) == i) {
	                return 2 /* PATH_COMPLETION */;
	            }
	            if (text.indexOf("!i", i) == i) {
	                hasIn = true;
	            }
	        }
	    }
	}
	exports.determineCompletionKind = determineCompletionKind;
	(function (LocationKind) {
	    LocationKind[LocationKind["VALUE_COMPLETION"] = 0] = "VALUE_COMPLETION";
	    LocationKind[LocationKind["KEY_COMPLETION"] = 1] = "KEY_COMPLETION";
	    LocationKind[LocationKind["PATH_COMPLETION"] = 2] = "PATH_COMPLETION";
	    LocationKind[LocationKind["DIRECTIVE_COMPLETION"] = 3] = "DIRECTIVE_COMPLETION";
	    LocationKind[LocationKind["VERSION_COMPLETION"] = 4] = "VERSION_COMPLETION";
	    LocationKind[LocationKind["ANNOTATION_COMPLETION"] = 5] = "ANNOTATION_COMPLETION";
	    LocationKind[LocationKind["SEQUENCE_KEY_COPLETION"] = 6] = "SEQUENCE_KEY_COPLETION";
	    LocationKind[LocationKind["INCOMMENT"] = 7] = "INCOMMENT";
	})(exports.LocationKind || (exports.LocationKind = {}));
	var LocationKind = exports.LocationKind;
	function resolveReference(point, path) {
	    if (!path) {
	        return null;
	    }
	    var sp = path.split("/");
	    var result = point;
	    for (var i = 0; i < sp.length; i++) {
	        if (sp[i] == '#') {
	            result = point.unit().ast();
	            continue;
	        }
	        result = _.find(result.children(), function (x) { return x.key() == sp[i]; });
	        if (!result) {
	            return null;
	        }
	    }
	    return result;
	}
	exports.resolveReference = resolveReference;
	/**
	 * return all sub types of given type visible from parent node
	 * @param range
	 * @param parentNode
	 * @returns ITypeDefinition[]
	 */
	exports.subTypesWithLocals = function (range, parentNode) {
	    if (range == null) {
	        return [];
	    }
	    var name = range.name();
	    parentNode = exports.declRoot(parentNode);
	    var actual = parentNode;
	    if (actual._subTypesCache) {
	        var cached = actual._subTypesCache[name];
	        if (cached) {
	            return cached;
	        }
	    }
	    else {
	        actual._subTypesCache = {};
	    }
	    var result = range.allSubTypes();
	    if (range.getRuntimeExtenders().length > 0 && parentNode) {
	        var decls = globalDeclarations(parentNode);
	        var extenders = range.getRuntimeExtenders();
	        var root = parentNode.root();
	        extenders.forEach(function (x) {
	            var definitionNodes = decls.filter(function (z) {
	                var def = z.definition().allSuperTypes();
	                def.push(z.definition());
	                var rr = (z.definition() == x) || (_.find(def, function (d) { return d == x; }) != null) || (_.find(def, function (d) { return d == range; }) != null);
	                return rr;
	            });
	            result = result.concat(definitionNodes.map(function (x) { return typeBuilder.typeFromNode(x); }));
	        });
	    }
	    result = _.unique(result);
	    actual._subTypesCache[name] = result;
	    return result;
	};
	exports.subTypesWithName = function (tname, parentNode, backup) {
	    parentNode = exports.declRoot(parentNode);
	    var decls = globalDeclarations(parentNode);
	    var declNode = _.find(decls, function (x) { return hlimpl.qName(x, parentNode) == tname && x.property() && (x.property().name() == 'types'); });
	    var result = typeBuilder.typeFromNode(declNode);
	    return result;
	};
	exports.schemasWithName = function (tname, parentNode, backup) {
	    parentNode = exports.declRoot(parentNode);
	    var decls = globalDeclarations(parentNode);
	    var declNode = _.find(decls, function (x) { return hlimpl.qName(x, parentNode) == tname && x.property() && (x.property().name() == 'schemas'); });
	    var result = typeBuilder.typeFromNode(declNode);
	    return result;
	};
	exports.nodesDeclaringType = function (range, n) {
	    var result = [];
	    if (range.getRuntimeExtenders().length > 0 && n) {
	        var extenders = range.getRuntimeExtenders();
	        var root = n;
	        extenders.forEach(function (x) {
	            var definitionNodes = globalDeclarations(root).filter(function (z) { return z.definition() == x; });
	            result = result.concat(definitionNodes);
	        });
	    }
	    var isElementType = !range.isValueType();
	    if (isElementType && range.isInlinedTemplates() && n) {
	        var root = n;
	        //TODO I did not like it it might be written much better
	        var definitionNodes = globalDeclarations(root).filter(function (z) { return z.definition() == range; });
	        result = result.concat(definitionNodes);
	    }
	    else {
	        var root = n;
	        var q = {};
	        range.allSubTypes().forEach(function (x) { return q[x.name()] = true; });
	        q[range.name()] = true;
	        var definitionNodes = globalDeclarations(root).filter(function (z) { return q[z.definition().name()]; });
	        result = result.concat(definitionNodes);
	    }
	    return result;
	};
	function findAllSubTypes(p, n) {
	    var range = p.range();
	    return exports.subTypesWithLocals(range, n);
	}
	exports.findAllSubTypes = findAllSubTypes;
	;
	function possibleNodes(p, c) {
	    if (c) {
	        if (p.isDescriminating()) {
	            var range = p.range();
	            if (range.getRuntimeExtenders().length > 0 && c) {
	                var extenders = range.getRuntimeExtenders();
	                var result = [];
	                extenders.forEach(function (x) {
	                    var definitionNodes = globalDeclarations(c).filter(function (z) { return z.definition() == x; });
	                    result = result.concat(definitionNodes);
	                });
	                return result;
	            }
	            return [];
	        }
	        if (p.isReference()) {
	            return exports.nodesDeclaringType(p.referencesTo(), c);
	        }
	        if (p.range().isValueType()) {
	            var vt = p.range();
	            if (vt.globallyDeclaredBy && vt.globallyDeclaredBy().length > 0) {
	                var definitionNodes = globalDeclarations(c).filter(function (z) { return _.find(vt.globallyDeclaredBy(), function (x) { return x == z.definition(); }) != null; });
	                return definitionNodes;
	            }
	        }
	    }
	    return this._enumOptions;
	}
	function allChildren(node) {
	    var res = [];
	    gather(node, res);
	    return res;
	}
	exports.allChildren = allChildren;
	function gather(node, result) {
	    node.children().forEach(function (x) {
	        result.push(x);
	        gather(x, result);
	    });
	}
	var testUsage = function (ck, x, node, result) {
	    if (ck instanceof defs.UserDefinedClass) {
	        var ud = ck;
	        if (ud.getDeclaringNode() == node) {
	            result.push(x);
	        }
	    }
	    if (ck instanceof defs.Array) {
	        var cmp = ck;
	        testUsage(cmp.component, x, node, result);
	    }
	    if (ck instanceof defs.Union) {
	        var uni = ck;
	        testUsage(uni.left, x, node, result);
	        testUsage(uni.right, x, node, result);
	    }
	};
	function refFinder(root, node, result) {
	    root.elements().forEach(function (x) {
	        refFinder(x, node, result);
	        //console.log(x.name())
	        var ck = x.definition();
	        //testUsage(ck, x, node, result);
	    });
	    root.attrs().forEach(function (a) {
	        var pr = a.property();
	        var vl = a.value();
	        //if (pr.isTypeExpr()){
	        //    typeExpression.
	        //}
	        if (pr instanceof defs.UserDefinedProp) {
	            var up = pr.node();
	            if (up == node) {
	                result.push(a);
	            }
	            else if (up.lowLevel().start() == node.lowLevel().start()) {
	                if (up.lowLevel().unit() == node.lowLevel().unit()) {
	                    result.push(a);
	                }
	            }
	        }
	        if (isExampleNodeContent(a)) {
	            var contentType = findExampleContentType(a);
	            if (contentType) {
	                var documentationRoot = parseDocumentationContent(a, contentType.toRuntime());
	                if (documentationRoot) {
	                    refFinder(documentationRoot, node, result);
	                }
	            }
	        }
	        else if (pr.isTypeExpr() && typeof vl == "string") {
	            if (pr.name() == "signature") {
	                var sig = ramlSignature.parse(a);
	                if (sig) {
	                    if (sig.args) {
	                        sig.args.forEach(function (x) {
	                            var tp = typeExpression.deriveType(root, x.type);
	                            if (tp) {
	                                testUsage(tp, a, node, result);
	                            }
	                        });
	                    }
	                    if (sig.returnType) {
	                        var tp = typeExpression.deriveType(root, sig.returnType);
	                        if (tp) {
	                            testUsage(tp, a, node, result);
	                        }
	                    }
	                }
	            }
	            else {
	                var tpa = typeExpression.getType(root, "" + vl, {});
	                testUsage(tpa, a, node, result);
	                var libraryName = hl.getLibraryName(node);
	                if (libraryName && vl.indexOf(libraryName) != -1) {
	                    var referencingLibrary = getLibraryDefiningNode(a);
	                    if (referencingLibrary && referencingLibrary.lowLevel().start() == node.lowLevel().start()) {
	                        result.push(a);
	                    }
	                }
	            }
	        }
	        if (pr.isReference() || pr.isDescriminator()) {
	            if (typeof vl == 'string') {
	                var pn = possibleNodes(pr, root);
	                if (_.find(pn, function (x) { return x.name() == vl && x == node; })) {
	                    result.push(a);
	                }
	                var libraryName = hl.getLibraryName(node);
	                if (libraryName && vl.indexOf(libraryName) != -1) {
	                    var referencingLibrary = getLibraryDefiningNode(a);
	                    if (referencingLibrary && referencingLibrary.lowLevel().start() == node.lowLevel().start()) {
	                        result.push(a);
	                    }
	                }
	            }
	            else {
	                var st = vl;
	                if (st) {
	                    var vn = st.valueName();
	                    var pn = possibleNodes(pr, root);
	                    if (_.find(pn, function (x) { return x.name() == vn && x == node; })) {
	                        result.push(a);
	                    }
	                    var hnode = st.toHighlevel();
	                    if (hnode) {
	                        refFinder(hnode, node, result);
	                    }
	                    var libraryName = hl.getLibraryName(node);
	                    if (libraryName && vn.indexOf(libraryName) != -1) {
	                        var referencingLibrary = getLibraryDefiningNode(vl);
	                        if (referencingLibrary && referencingLibrary.lowLevel().start() == node.lowLevel().start()) {
	                            result.push(a);
	                        }
	                    }
	                }
	            }
	        }
	        else {
	            var pn = possibleNodes(pr, root);
	            if (_.find(pn, function (x) { return x.name() == vl && x == node; })) {
	                result.push(a);
	            }
	        }
	    });
	}
	exports.refFinder = refFinder;
	/**
	 * Returns library node that definition of the current node is located in, or null
	 * if current node is not defined in a library.
	 */
	function getLibraryDefiningNode(nodeToCheck) {
	    if (!nodeToCheck.lowLevel) {
	        return null;
	    }
	    var lowLevelNode = nodeToCheck.lowLevel();
	    if (!lowLevelNode) {
	        return null;
	    }
	    if (lowLevelNode.key()) {
	        var offset = Math.floor((lowLevelNode.keyEnd() + lowLevelNode.keyStart()) / 2);
	        var result = getLibraryDefiningNodeByOffset(lowLevelNode.unit(), offset);
	        if (result)
	            return result;
	    }
	    if (lowLevelNode.value()) {
	        var offset = Math.floor((lowLevelNode.valueEnd() + lowLevelNode.valueStart()) / 2);
	        var result = getLibraryDefiningNodeByOffset(lowLevelNode.unit(), offset);
	        if (result)
	            return result;
	    }
	    return null;
	}
	function getLibraryDefiningNodeByOffset(unit, offset) {
	    var declaration = findDeclaration(unit, offset);
	    if (declaration && hl.asNode(declaration)) {
	        var declarationNode = hl.asNode(declaration);
	        var parent = declarationNode;
	        while (parent) {
	            if (parent.definition().name() == "Library") {
	                return parent;
	            }
	            parent = parent.parent();
	        }
	    }
	    return null;
	}
	//# sourceMappingURL=search.js.map

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var factory10 = __webpack_require__(68);
	var factory08 = __webpack_require__(69);
	function buildWrapperNode(node) {
	    var ramlVersion = node.definition().universe().version();
	    if (ramlVersion == 'RAML10') {
	        return factory10.buildWrapperNode(node);
	    }
	    else if (ramlVersion == 'RAML08') {
	        return factory08.buildWrapperNode(node);
	    }
	    return null;
	}
	exports.buildWrapperNode = buildWrapperNode;
	//# sourceMappingURL=modelFactory.js.map

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/tsd.d.ts" />
	var hl = __webpack_require__(17);
	var _ = __webpack_require__(47);
	var linter = __webpack_require__(33);
	var wrapperHelper = __webpack_require__(15);
	function escapeUri(u) {
	    var ss = "";
	    var level = 0;
	    for (var i = 0; i < u.length; i++) {
	        var c = u.charAt(i);
	        if (level == 0) {
	            ss = ss + c;
	        }
	        if (c == '{') {
	            level++;
	        }
	        if (c == '}') {
	            level--;
	        }
	    }
	    return ss;
	}
	var OverloadingValidator = (function () {
	    function OverloadingValidator() {
	        this.holder = {};
	        this.conflicting = {};
	    }
	    OverloadingValidator.prototype.validateApi = function (q, v) {
	        var _this = this;
	        q.resources().forEach(function (x) {
	            _this.acceptResource(x);
	            x.resources().forEach(function (y) { return _this.acceptResource(y); });
	        });
	        for (var c in this.conflicting) {
	            var ms = this.conflicting[c];
	            //now we should layout parameters by items
	            var overmapQuery = {};
	            var overmapHeaders = {};
	            var pushed = [];
	            ms.forEach(function (m) {
	                m.queryParameters().forEach(function (q) {
	                    var key = q.name();
	                    if (!q.required()) {
	                        return;
	                    }
	                    var set = overmapQuery[key];
	                    if (!set) {
	                        set = [];
	                        overmapQuery[key] = set;
	                    }
	                    set.push(m);
	                    pushed.push(m);
	                });
	                m.headers().forEach(function (q) {
	                    var key = q.name();
	                    if (!q.required()) {
	                        return;
	                    }
	                    var set = overmapHeaders[key];
	                    if (!set) {
	                        set = [];
	                        overmapHeaders[key] = set;
	                    }
	                    set.push(m);
	                    pushed.push(m);
	                });
	            });
	            var notPushed = ms.filter(function (x) { return !_.find(pushed, function (y) { return y == x; }); });
	            if (notPushed.length > 0) {
	                notPushed.forEach(function (m) {
	                    v.accept(linter.createIssue(5 /* KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT */, "method overloading is ambiguous", m.highLevel(), true));
	                });
	            }
	            for (var key in overmapQuery) {
	                var cm = overmapQuery[key];
	                if (cm.length > 1) {
	                    var over = {};
	                    var pushed2 = [];
	                    cm.forEach(function (m) {
	                        var pr = _.find(m.queryParameters(), function (x) { return x.name() == key; });
	                        if (pr['enum']) {
	                            var ev = pr['enum']();
	                            if (ev && ev.length > 0) {
	                                ev.forEach(function (value) {
	                                    var t = over[value];
	                                    if (!t) {
	                                        t = [];
	                                        over[value] = t;
	                                    }
	                                    t.push(m);
	                                    pushed2.push(m);
	                                });
	                            }
	                        }
	                    });
	                    var notPushed2 = cm.filter(function (x) { return !_.find(pushed2, function (y) { return y == x; }); });
	                    if (notPushed2.length > 0) {
	                        notPushed2.forEach(function (m) {
	                            v.accept(linter.createIssue(5 /* KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT */, "method overloading is ambiguous no domain restrictions", m.highLevel(), true));
	                        });
	                    }
	                    for (var k in over) {
	                        var rs = over[k];
	                        if (rs.length > 1) {
	                            rs.forEach(function (m) { return v.accept(linter.createIssue(5 /* KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT */, "method overloading is ambiguous ( enum value " + k + ")", m.highLevel(), true)); });
	                        }
	                    }
	                }
	            }
	        }
	    };
	    OverloadingValidator.prototype.acceptResource = function (x) {
	        var _this = this;
	        x.methods().forEach(function (m) {
	            _this.acceptMethod(x, m);
	        });
	    };
	    OverloadingValidator.prototype.acceptMethod = function (x, m) {
	        var uri = escapeUri(wrapperHelper.absoluteUri(x)) + m.method();
	        var pos = this.holder[uri];
	        if (!pos) {
	            pos = [];
	            this.holder[uri] = pos;
	        }
	        pos.push(m);
	        if (pos.length > 1) {
	            this.conflicting[uri] = pos;
	        }
	        //wrapperHelper.absoluteUri(m.parent().)
	    };
	    return OverloadingValidator;
	})();
	exports.OverloadingValidator = OverloadingValidator;
	//# sourceMappingURL=overloadingValidator.js.map

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by kor on 08/05/15.
	 */
	/// <reference path="../../typings/tsd.d.ts" />
	var ts = __webpack_require__(42);
	var tsm = __webpack_require__(71);
	var pth = __webpack_require__(11);
	var fs = __webpack_require__(12);
	function parse(content) {
	    return ts.createSourceFile("sample.ts", content, 0 /* ES3 */, "1.4.1", true);
	}
	var fld = tsm.Matching.field();
	var clazzMatcher = tsm.Matching.classDeclaration();
	var EnumDeclaration = (function () {
	    function EnumDeclaration() {
	    }
	    return EnumDeclaration;
	})();
	exports.EnumDeclaration = EnumDeclaration;
	(function (TypeKind) {
	    TypeKind[TypeKind["BASIC"] = 0] = "BASIC";
	    TypeKind[TypeKind["ARRAY"] = 1] = "ARRAY";
	    TypeKind[TypeKind["UNION"] = 2] = "UNION";
	})(exports.TypeKind || (exports.TypeKind = {}));
	var TypeKind = exports.TypeKind;
	function classDecl(name, isInteface) {
	    return {
	        name: name,
	        methods: [],
	        typeParameters: [],
	        typeParameterConstraint: [],
	        implements: [],
	        fields: [],
	        isInterface: isInteface,
	        annotations: [],
	        extends: [],
	        moduleName: null,
	        annotationOverridings: {}
	    };
	}
	exports.classDecl = classDecl;
	function parseStruct(content, modules, mpth) {
	    var mod = parse(content);
	    var module = { classes: [], aliases: [], enumDeclarations: [], imports: {}, name: mpth };
	    modules[mpth] = module;
	    var currentModule = null;
	    tsm.Matching.visit(mod, function (x) {
	        if (x.kind == 189 /* ModuleDeclaration */) {
	            var cmod = x;
	            currentModule = cmod.name.text;
	        }
	        if (x.kind == 191 /* ImportDeclaration */) {
	            var imp = x;
	            var namespace = imp.name.text;
	            if (namespace == "RamlWrapper") {
	                return;
	            }
	            if (imp.moduleReference.kind != 193 /* ExternalModuleReference */) {
	                throw new Error("Only external module references are supported now");
	            }
	            var path = imp.moduleReference;
	            if (path.expression.kind != 7 /* StringLiteral */) {
	                throw new Error("Only string literals are supported in module references ");
	            }
	            var literal = path.expression;
	            var importPath = literal.text;
	            var absPath = pth.resolve(pth.dirname(mpth) + "/", importPath) + ".ts";
	            if (!fs.existsSync(absPath)) {
	                throw new Error("Path " + importPath + " resolve to " + absPath + "do not exists");
	            }
	            if (!modules[absPath]) {
	                var cnt = fs.readFileSync(absPath).toString();
	                var mod = parseStruct(cnt, modules, absPath);
	            }
	            module.imports[namespace] = modules[absPath];
	        }
	        if (x.kind == 187 /* TypeAliasDeclaration */) {
	            var u = x;
	            var aliasName = u.name.text;
	            var type = buildType(u.type, mpth);
	            module.aliases.push({ name: aliasName, type: type });
	        }
	        if (x.kind == 188 /* EnumDeclaration */) {
	            var e = x;
	            var members = [];
	            e.members.forEach(function (y) {
	                members.push(y['name']['text']);
	            });
	            module.enumDeclarations.push({ name: e.name.text, members: members });
	        }
	        var isInterface = x.kind == 186 /* InterfaceDeclaration */;
	        var isClass = x.kind == 185 /* ClassDeclaration */;
	        if (!isInterface && !isClass) {
	            return;
	        }
	        var c = x;
	        if (c) {
	            var fields = {};
	            var clazz = classDecl(c.name.text, isInterface);
	            clazz.moduleName = currentModule;
	            module.classes.push(clazz);
	            c.members.forEach(function (x) {
	                if (x.kind == 125 /* Method */) {
	                    var md = x;
	                    var aliasName = md.name.text;
	                    var text = content.substring(md.pos, md.end);
	                    clazz.methods.push({ name: aliasName, start: md.pos, end: md.end, text: text });
	                }
	                var field = fld.doMatch(x);
	                if (field) {
	                    var f = buildField(field, mpth);
	                    if (f.name == '$') {
	                        clazz.annotations = f.annotations;
	                    }
	                    else if (f.name.charAt(0) != '$' || f.name == '$ref') {
	                        fields[f.name] = f;
	                        clazz.fields.push(f);
	                    }
	                    else {
	                        var targetField = f.name.substr(1);
	                        var of = fields[targetField];
	                        if (!of) {
	                            if (f.name != '$$') {
	                                //console.log('Overriding annotations for field:'+targetField);
	                                var overridings = clazz.annotationOverridings[targetField];
	                                if (!overridings) {
	                                    overridings = [];
	                                }
	                                clazz.annotationOverridings[targetField] = overridings.concat(f.annotations);
	                            }
	                        }
	                        else {
	                            of.annotations = f.annotations;
	                        }
	                    }
	                }
	            });
	            if (c.typeParameters) {
	                c.typeParameters.forEach(function (x) {
	                    clazz.typeParameters.push(x.name['text']);
	                    if (x.constraint == null) {
	                        clazz.typeParameterConstraint.push(null);
	                    }
	                    else {
	                        clazz.typeParameterConstraint.push(x.constraint['typeName']['text']);
	                    }
	                });
	            }
	            if (c.heritageClauses) {
	                c.heritageClauses.forEach(function (x) {
	                    x.types.forEach(function (y) {
	                        if (x.token == 77 /* ExtendsKeyword */) {
	                            clazz.extends.push(buildType(y, mpth));
	                        }
	                        else if (x.token == 100 /* ImplementsKeyword */) {
	                            clazz.implements.push(buildType(y, mpth));
	                        }
	                        else {
	                            throw new Error("Unknown token class heritage");
	                        }
	                    });
	                });
	            }
	            return tsm.Matching.SKIP;
	        }
	    });
	    return module;
	}
	exports.parseStruct = parseStruct;
	function buildField(f, path) {
	    return {
	        name: f.name['text'],
	        type: buildType(f.type, path),
	        annotations: f.name['text'].charAt(0) == '$' ? buildInitializer(f.initializer) : [],
	        valueConstraint: f.name['text'].charAt(0) != '$' ? buildConstraint(f.initializer) : null,
	        optional: f.questionToken != null
	    };
	}
	function buildConstraint(e) {
	    if (e == null) {
	        return null;
	    }
	    if (e.kind == 145 /* CallExpression */) {
	        return {
	            isCallConstraint: true,
	            value: buildAnnotation(e)
	        };
	    }
	    else {
	        return {
	            isCallConstraint: false,
	            value: parseArg(e)
	        };
	    }
	}
	function buildInitializer(i) {
	    if (i == null) {
	        return [];
	    }
	    if (i.kind == 141 /* ArrayLiteralExpression */) {
	        var arr = i;
	        var annotations = [];
	        arr.elements.forEach(function (x) {
	            annotations.push(buildAnnotation(x));
	        });
	        return annotations;
	    }
	    else {
	        throw new Error("Only Array Literals supported now");
	    }
	}
	function buildAnnotation(e) {
	    if (e.kind == 145 /* CallExpression */) {
	        var call = e;
	        var name = parseName(call.expression);
	        var a = {
	            name: name,
	            arguments: []
	        };
	        call.arguments.forEach(function (x) {
	            a.arguments.push(parseArg(x));
	        });
	        return a;
	    }
	    else {
	        throw new Error("Only call expressions may be annotations");
	    }
	}
	function parseArg(n) {
	    if (n.kind == 7 /* StringLiteral */) {
	        var l = n;
	        return l.text;
	    }
	    if (n.kind == 9 /* NoSubstitutionTemplateLiteral */) {
	        var ls = n;
	        return ls.text;
	    }
	    if (n.kind == 141 /* ArrayLiteralExpression */) {
	        var arr = n;
	        var annotations = [];
	        arr.elements.forEach(function (x) {
	            annotations.push(parseArg(x));
	        });
	        return annotations;
	    }
	    if (n.kind == 93 /* TrueKeyword */) {
	        return true;
	    }
	    if (n.kind == 143 /* PropertyAccessExpression */) {
	        var pa = n;
	        return parseArg(pa.expression) + "." + parseArg(pa.name);
	    }
	    if (n.kind == 63 /* Identifier */) {
	        var ident = n;
	        return ident.text;
	    }
	    if (n.kind == 78 /* FalseKeyword */) {
	        return false;
	    }
	    if (n.kind == 6 /* NumericLiteral */) {
	        var nl = n;
	        return nl.text;
	    }
	    if (n.kind == 157 /* BinaryExpression */) {
	        var bin = n;
	        if (bin.operator = 32 /* PlusToken */) {
	            return parseArg(bin.left) + parseArg(bin.right);
	        }
	    }
	    throw new Error("Unknown value in annotation");
	}
	function parseName(n) {
	    if (n.kind == 63 /* Identifier */) {
	        return n['text'];
	    }
	    if (n.kind == 143 /* PropertyAccessExpression */) {
	        var m = n;
	        return parseName(m.expression) + "." + parseName(m.name);
	    }
	    throw new Error("Only simple identifiers are supported now");
	}
	function basicType(n, path) {
	    var namespaceIndex = n.indexOf(".");
	    var namespace = namespaceIndex != -1 ? n.substring(0, namespaceIndex) : "";
	    var basicName = namespaceIndex != -1 ? n.substring(namespaceIndex + 1) : n;
	    return { typeName: n, nameSpace: namespace, basicName: basicName, typeKind: 0 /* BASIC */, typeArguments: [], modulePath: path };
	}
	function arrayType(b) {
	    return { base: b, typeKind: 1 /* ARRAY */ };
	}
	function unionType(b) {
	    return { options: b, typeKind: 2 /* UNION */ };
	}
	function buildType(t, path) {
	    if (t == null) {
	        return null;
	    }
	    if (t.kind == 118 /* StringKeyword */) {
	        return basicType("string", null);
	    }
	    if (t.kind == 116 /* NumberKeyword */) {
	        return basicType("number", null);
	    }
	    if (t.kind == 110 /* BooleanKeyword */) {
	        return basicType("boolean", null);
	    }
	    if (t.kind == 109 /* AnyKeyword */) {
	        return basicType("any", null);
	    }
	    if (t.kind == 132 /* TypeReference */) {
	        var tr = t;
	        var res = basicType(parseQualified(tr.typeName), path);
	        if (tr.typeArguments) {
	            tr.typeArguments.forEach(function (x) {
	                res.typeArguments.push(buildType(x, path));
	            });
	        }
	        return res;
	    }
	    if (t.kind == 137 /* ArrayType */) {
	        var q = t;
	        return arrayType(buildType(q.elementType, path));
	    }
	    if (t.kind == 139 /* UnionType */) {
	        var ut = t;
	        return unionType(ut.types.map(function (x) { return buildType(x, path); }));
	    }
	    throw new Error("Case not supported" + t.kind);
	}
	function parseQualified(n) {
	    if (n.kind == 63 /* Identifier */) {
	        return n['text'];
	    }
	    else {
	        var q = n;
	        return parseQualified(q.left) + "." + parseQualified(q.right);
	    }
	}
	//# sourceMappingURL=tsStructureParser.js.map

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = this.__extends || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	/// <reference path="../../typings/tsd.d.ts" />
	var tsStruct = __webpack_require__(38);
	var def = __webpack_require__(21);
	var _ = __webpack_require__(47);
	var khttp = __webpack_require__(81);
	var FieldWrapper = (function () {
	    function FieldWrapper(_field, _clazz) {
	        this._field = _field;
	        this._clazz = _clazz;
	    }
	    FieldWrapper.prototype.name = function () {
	        return this._field.name;
	    };
	    FieldWrapper.prototype.range = function () {
	        return this._clazz.getModule().typeFor(this._field.type, this._clazz);
	    };
	    FieldWrapper.prototype.isMultiValue = function () {
	        return this._field.type.typeKind == 1 /* ARRAY */;
	    };
	    FieldWrapper.prototype.isKey = function () {
	        return _.find(this._field.annotations, function (x) { return x.name == "MetaModel.key"; }) != null;
	    };
	    FieldWrapper.prototype.isSimpleValue = function () {
	        return _.find(this._field.annotations, function (x) { return x.name == "MetaModel.value"; }) != null;
	    };
	    FieldWrapper.prototype.annotations = function () {
	        return this._field.annotations;
	    };
	    return FieldWrapper;
	})();
	var FieldConstraint = (function () {
	    function FieldConstraint(_field, _clazz) {
	        this._field = _field;
	        this._clazz = _clazz;
	    }
	    FieldConstraint.prototype.name = function () {
	        return this._field.name;
	    };
	    FieldConstraint.prototype.value = function () {
	        return this._field.valueConstraint;
	    };
	    return FieldConstraint;
	})();
	var ClassWrapper = (function () {
	    function ClassWrapper(_clazz, mw) {
	        this._clazz = _clazz;
	        this.mw = mw;
	    }
	    ClassWrapper.prototype.typeMeta = function () {
	        return this._clazz.annotations;
	    };
	    ClassWrapper.prototype.path = function () {
	        return this.mw.path();
	    };
	    ClassWrapper.prototype.getModule = function () {
	        return this.mw;
	    };
	    ClassWrapper.prototype.typeArgs = function () {
	        return this._clazz.typeParameters;
	    };
	    ClassWrapper.prototype.typConstraints = function () {
	        var _this = this;
	        return this._clazz.typeParameterConstraint.map(function (x) {
	            if (x) {
	                return _this.mw.classForName(x);
	            }
	            return null;
	        });
	    };
	    ClassWrapper.prototype.methods = function () {
	        return this._clazz.methods;
	    };
	    ClassWrapper.prototype.name = function () {
	        return this._clazz.name;
	    };
	    ClassWrapper.prototype.members = function () {
	        var _this = this;
	        return this._clazz.fields.filter(function (x) { return x.valueConstraint == null; }).map(function (x) { return new FieldWrapper(x, _this); });
	    };
	    ClassWrapper.prototype.constraints = function () {
	        var _this = this;
	        return this._clazz.fields.filter(function (x) { return x.valueConstraint != null; }).map(function (x) { return new FieldConstraint(x, _this); });
	    };
	    ClassWrapper.prototype.isSubTypeOf = function (of) {
	        if (this == of) {
	            return true;
	        }
	        var _res = false;
	        this.getAllSuperTypes().forEach(function (x) {
	            if (!_res) {
	                _res = _res || x.isSubTypeOf(of);
	            }
	        });
	        return _res;
	    };
	    ClassWrapper.prototype.getExtendsClauses = function () {
	        return this._clazz.extends;
	    };
	    ClassWrapper.prototype.getSuperTypes = function () {
	        var _this = this;
	        var result = [];
	        this._clazz.extends.forEach(function (x) {
	            var tp = _this.mw.classForName(x.typeName);
	            if (tp) {
	                result.push(tp);
	            }
	        });
	        return result;
	    };
	    ClassWrapper.prototype.getAllSuperTypes = function () {
	        var _this = this;
	        var result = [];
	        this._clazz.extends.forEach(function (x) {
	            var tp = _this.mw.classForName(x.typeName);
	            if (tp) {
	                var mm = tp.getAllSuperTypes();
	                result.push(tp);
	                result.concat(mm);
	            }
	        });
	        return _.unique(result);
	    };
	    ClassWrapper.prototype.annotationOverridings = function () {
	        return this._clazz.annotationOverridings;
	    };
	    return ClassWrapper;
	})();
	var AbstractSimpleWrapper = (function () {
	    function AbstractSimpleWrapper() {
	    }
	    AbstractSimpleWrapper.prototype.members = function () {
	        return []; //this._clazz.members.map(x=>new FieldWrapper(x,this))
	    };
	    AbstractSimpleWrapper.prototype.methods = function () {
	        return [];
	    };
	    AbstractSimpleWrapper.prototype.isSubTypeOf = function (of) {
	        return false;
	    };
	    AbstractSimpleWrapper.prototype.getSuperTypes = function () {
	        return [];
	    };
	    AbstractSimpleWrapper.prototype.getAllSuperTypes = function () {
	        return [];
	    };
	    AbstractSimpleWrapper.prototype.name = function () {
	        return null;
	    };
	    AbstractSimpleWrapper.prototype.constraints = function () {
	        return [];
	    };
	    AbstractSimpleWrapper.prototype.typeMeta = function () {
	        return [];
	    };
	    AbstractSimpleWrapper.prototype.getModule = function () {
	        throw new Error("Not implemented");
	    };
	    AbstractSimpleWrapper.prototype.annotationOverridings = function () {
	        return {};
	    };
	    return AbstractSimpleWrapper;
	})();
	var EnumWrapper = (function (_super) {
	    __extends(EnumWrapper, _super);
	    function EnumWrapper(_clazz, mw) {
	        _super.call(this);
	        this._clazz = _clazz;
	        this.mw = mw;
	    }
	    EnumWrapper.prototype.getModule = function () {
	        return this.mw;
	    };
	    EnumWrapper.prototype.values = function () {
	        return this._clazz.members;
	    };
	    EnumWrapper.prototype.name = function () {
	        return this._clazz.name;
	    };
	    return EnumWrapper;
	})(AbstractSimpleWrapper);
	var UnionWrapper = (function (_super) {
	    __extends(UnionWrapper, _super);
	    function UnionWrapper(_clazz, mw) {
	        _super.call(this);
	        this._clazz = _clazz;
	        this.mw = mw;
	    }
	    UnionWrapper.prototype.elements = function () {
	        return this._clazz;
	    };
	    UnionWrapper.prototype.name = function () {
	        return this._clazz.map(function (x) { return x.name(); }).join("|");
	    };
	    return UnionWrapper;
	})(AbstractSimpleWrapper);
	var ModuleWrapper = (function () {
	    function ModuleWrapper(_univers) {
	        var _this = this;
	        this._univers = _univers;
	        this.name2Class = {};
	        this.namespaceToMod = {};
	        this._classes = [];
	        _univers.classes.forEach(function (x) {
	            var c = new ClassWrapper(x, _this);
	            _this._classes.push(c);
	            _this.name2Class[x.name] = c;
	            if (x.moduleName) {
	                //FIXME
	                _this.name2Class[x.moduleName + "." + x.name] = c;
	            }
	        });
	        _univers.enumDeclarations.forEach(function (x) {
	            var c = new EnumWrapper(x, _this);
	            _this._classes.push(c);
	            _this.name2Class[x.name] = c;
	        });
	    }
	    ModuleWrapper.prototype.typeFor = function (t, ow) {
	        var _this = this;
	        switch (t.typeKind) {
	            case 0 /* BASIC */:
	                var bt = t;
	                var typeName = bt.typeName;
	                if (typeName == "string") {
	                    typeName = "StringType";
	                }
	                if (typeName == "number") {
	                    typeName = "NumberType";
	                }
	                if (typeName == "boolean") {
	                    typeName = "BooleanType";
	                }
	                var ti = _.indexOf(ow.typeArgs(), typeName);
	                if (ti != -1) {
	                    var cnst = ow.typConstraints()[ti];
	                    if (!cnst) {
	                        return this.classForName("ValueType");
	                    }
	                    return cnst;
	                }
	                return this.classForName(typeName);
	            case 2 /* UNION */:
	                var ut = t;
	                return new UnionWrapper(ut.options.map(function (x) { return _this.typeFor(x, ow); }), this);
	            case 1 /* ARRAY */:
	                var at = t;
	                return this.typeFor(at.base, ow);
	        }
	        return null;
	    };
	    ModuleWrapper.prototype.path = function () {
	        return this._univers.name;
	    };
	    ModuleWrapper.prototype.classForName = function (name, stack) {
	        var _this = this;
	        if (stack === void 0) { stack = {}; }
	        if (!name) {
	            return null;
	        }
	        var result = this.name2Class[name];
	        if (!result && !stack[this.path()]) {
	            stack[this.path()] = this;
	            var nmsp = name.indexOf(".");
	            if (nmsp != -1) {
	                var actualMod = this.namespaceToMod[name.substring(0, nmsp)];
	                if (!actualMod) {
	                    throw new Error();
	                }
	                return actualMod.classForName(name.substring(nmsp + 1), stack);
	            }
	            Object.keys(this.namespaceToMod).forEach(function (x) {
	                if (x != "MetaModel") {
	                    var nm = _this.namespaceToMod[x].classForName(name, stack);
	                    if (nm) {
	                        result = nm;
	                    }
	                }
	            });
	        }
	        return result;
	    };
	    ModuleWrapper.prototype.classes = function () {
	        return this._classes;
	    };
	    return ModuleWrapper;
	})();
	var wrapperToType = function (range, u) {
	    if (range) {
	        var rangeType;
	        if (range instanceof UnionWrapper) {
	            var uw = range;
	            rangeType = new def.UnionType(uw.elements().map(function (x) { return wrapperToType(x, u); }));
	        }
	        else {
	            rangeType = u.type(range.name());
	        }
	        return rangeType;
	    }
	    else {
	        return;
	    }
	};
	var registerClasses = function (m, u) {
	    var valueType = m.classForName("ValueType");
	    m.classes().forEach(function (x) {
	        if (x instanceof EnumWrapper) {
	            var et = new def.EnumType(x.name(), u, x.getModule().path());
	            et.values = x.values();
	            u.register(et);
	            return;
	        }
	        if (x.isSubTypeOf(valueType)) {
	            var st = x.getAllSuperTypes();
	            st.push(x);
	            var refTo = null;
	            var scriptingHook = null;
	            st.forEach(function (t) {
	                var cs = t.getExtendsClauses();
	                cs.forEach(function (z) {
	                    if (z.typeKind == 0 /* BASIC */) {
	                        var bas = z;
	                        if (bas.basicName == 'Reference') {
	                            var of = bas.typeArguments[0];
	                            refTo = of.typeName;
	                        }
	                        if (bas.basicName == 'ScriptingHook') {
	                            var of = bas.typeArguments[0];
	                            scriptingHook = of.basicName;
	                        }
	                    }
	                });
	            });
	            if (refTo) {
	                //console.log("New reference type" + x.name())
	                var ref = new def.ReferenceType(x.name(), x.getModule().path(), refTo, u);
	                u.register(ref);
	            }
	            if (scriptingHook) {
	                //console.log("New scripting hook " + x.name())
	                var sc = new def.ScriptingHookType(x.name(), x.getModule().path(), scriptingHook, u);
	                u.register(sc);
	            }
	            var vt = new def.ValueType(x.name(), u, x.getModule().path());
	            u.register(vt);
	        }
	        else {
	            var gt = new def.NodeClass(x.name(), u, x.getModule().path());
	            u.register(gt);
	        }
	    });
	};
	var registerHierarchy = function (m, u) {
	    m.classes().forEach(function (x) {
	        x.getSuperTypes().forEach(function (y) {
	            var tp0 = u.type(x.name());
	            var tp1 = u.type(y.name());
	            if (!tp0 || !tp1) {
	                var tp0 = u.type(x.name());
	                var tp1 = u.type(y.name());
	                throw new Error();
	            }
	            u.registerSuperClass(tp0, tp1);
	        });
	    });
	};
	var registerEverything = function (m, u) {
	    m.classes().forEach(function (x) {
	        var tp = u.type(x.name());
	        x.typeMeta().forEach(function (a) {
	            if (a.name == 'MetaModel.declaresSubTypeOf') {
	                var rangeType = wrapperToType(x, u);
	                rangeType.setExtendedTypeName(a.arguments[0]);
	            }
	            if (a.name == 'MetaModel.nameAtRuntime') {
	                var rangeType = wrapperToType(x, u);
	                rangeType.setNameAtRuntime(a.arguments[0]);
	            }
	            if (a.name == 'MetaModel.description') {
	                var rangeType = wrapperToType(x, u);
	                rangeType.withDescription(a.arguments[0]);
	            }
	            if (a.name == 'MetaModel.inlinedTemplates') {
	                var rangeType = wrapperToType(x, u);
	                rangeType.setInlinedTemplates(true);
	            }
	            if (a.name == 'MetaModel.requireValue') {
	                var rangeType = wrapperToType(x, u);
	                rangeType.withContextRequirement("" + a.arguments[0], "" + a.arguments[1]);
	            }
	            if (a.name == 'MetaModel.referenceIs') {
	                var rangeType = wrapperToType(x, u);
	                rangeType.withReferenceIs("" + a.arguments[0]);
	            }
	            //MetaModel.referenceIs
	            if (a.name == 'MetaModel.actuallyExports') {
	                var rangeType = wrapperToType(x, u);
	                rangeType.withActuallyExports("" + a.arguments[0]);
	            }
	            if (a.name == 'MetaModel.convertsToGlobalOfType') {
	                var rangeType = wrapperToType(x, u);
	                rangeType.withConvertsToGlobal("" + a.arguments[0]);
	            }
	            if (a.name == 'MetaModel.allowAny') {
	                var rangeType = wrapperToType(x, u);
	                rangeType.withAllowAny();
	            }
	            if (a.name == 'MetaModel.allowQuestion') {
	                var rangeType = wrapperToType(x, u);
	                rangeType.withAllowQuestion();
	            }
	            if (a.name == 'MetaModel.functionalDescriminator') {
	                var r1 = wrapperToType(x, u);
	                r1.withFunctionalDescriminator("" + a.arguments[0]);
	            }
	            if (a.name == 'MetaModel.alias') {
	                var at = wrapperToType(x, u);
	                at.addAlias("" + a.arguments[0]);
	            }
	            if (a.name == 'MetaModel.consumesRefs') {
	                var at = wrapperToType(x, u);
	                at.setConsumesRefs(true);
	            }
	            if (a.name == 'MetaModel.canInherit') {
	                var nc = wrapperToType(x, u);
	                nc.withCanInherit("" + a.arguments[0]);
	            }
	            if (a.name == 'MetaModel.definingPropertyIsEnough') {
	                var nc = wrapperToType(x, u);
	                nc.definingPropertyIsEnough("" + a.arguments[0]);
	            }
	        });
	        x.members().forEach(function (x) {
	            var range = x.range();
	            var rangeType = wrapperToType(range, u);
	            if (rangeType == null) {
	                console.log(range + ":" + x.name());
	            }
	            createProp(x, tp, rangeType);
	        });
	        Object.keys(x.annotationOverridings()).forEach(function (fName) {
	            var arr = [].concat(x.annotationOverridings()[fName]);
	            var map = {};
	            arr.forEach(function (ann) { return map[ann.name] = true; });
	            var targetField;
	            var stArr = x.getSuperTypes();
	            var stMap = {};
	            for (var i = 0; i < stArr.length; i++) {
	                var st = stArr[i];
	                if (stMap[st.name()]) {
	                    continue;
	                }
	                stMap[st.name()] = true;
	                st.getSuperTypes().forEach(function (sst) { return stArr.push(sst); });
	                var arr1 = st.annotationOverridings()[fName];
	                if (arr1) {
	                    arr1.filter(function (ann) { return !map[ann.name]; }).forEach(function (ann) {
	                        map[ann.name] = true;
	                        arr.push(ann);
	                    });
	                }
	                else {
	                    var stFields = st.members();
	                    for (var j = 0; j < stFields.length; j++) {
	                        var stField = stFields[j];
	                        if (stField.name() == fName) {
	                            targetField = stField;
	                            break;
	                        }
	                    }
	                }
	                if (targetField) {
	                    var arr2 = targetField.annotations();
	                    arr2.filter(function (ann) { return !map[ann.name]; }).forEach(function (ann) {
	                        map[ann.name] = true;
	                        arr.push(ann);
	                    });
	                    break;
	                }
	            }
	            if (!targetField) {
	                return;
	            }
	            var range = targetField.range();
	            var rangeType = wrapperToType(range, u);
	            if (rangeType == null) {
	                console.log(range + ":" + x.name());
	            }
	            createProp(targetField, tp, rangeType, arr);
	        });
	        x.methods().forEach(function (x) {
	            var at = tp;
	            at.addMethod(x.name, x.text);
	            //console.log(x.name);
	            //createMember(x, <def.AbstractType>tp, rangeType)
	        });
	        x.constraints().forEach(function (x) {
	            if (x.value().isCallConstraint) {
	                throw new Error();
	            }
	            var mm = x.value();
	            tp.addRequirement(x.name(), "" + mm.value);
	        });
	    });
	    u.types().forEach(function (x) {
	        if (x instanceof def.AbstractType) {
	            var at = x;
	            at.getAliases().forEach(function (y) { return u.registerAlias(y, at); });
	        }
	    });
	};
	var processModule = function (ts, u, used, declared) {
	    if (ts.name.indexOf("metamodel.ts") != -1) {
	        return; //FIXME
	    }
	    if (declared[ts.name]) {
	        return declared[ts.name];
	    }
	    var m = new ModuleWrapper(ts);
	    used[ts.name] = m;
	    declared[ts.name] = m;
	    Object.keys(ts.imports).forEach(function (x) {
	        var pMod = ts.imports[x];
	        if (used[pMod.name]) {
	            m.namespaceToMod[x] = used[pMod.name];
	            return;
	        }
	        var vMod = processModule(pMod, u, used, declared);
	        m.namespaceToMod[x] = vMod;
	    });
	    used[ts.name] = null;
	    return m;
	};
	function toDefSystem(ts) {
	    var u = new def.Universe("");
	    var c = {};
	    processModule(ts, u, {}, c);
	    Object.keys(c).forEach(function (x) {
	        registerClasses(c[x], u);
	    });
	    Object.keys(c).forEach(function (x) {
	        registerHierarchy(c[x], u);
	    });
	    Object.keys(c).forEach(function (x) {
	        registerEverything(c[x], u);
	    });
	    u.types().forEach(function (x) {
	        if (x instanceof def.NodeClass) {
	            var cl = x;
	            cl.properties().forEach(function (y) {
	                var t = y.range();
	                if (!t.isValueType()) {
	                    t.properties().forEach(function (p0) {
	                        if (p0.isKey()) {
	                            var kp = p0.keyPrefix();
	                            if (kp) {
	                                y.withKeyRestriction(kp);
	                                y.merge();
	                            }
	                            var eo = p0.getEnumOptions();
	                            if (eo) {
	                                y.withEnumOptions(eo);
	                                y.merge();
	                            }
	                        }
	                    });
	                }
	            });
	            if (cl.isGlobalDeclaration()) {
	                if (cl.getActuallyExports() && cl.getActuallyExports() != "$self") {
	                    var tp = cl.property(cl.getActuallyExports()).range();
	                    if (tp.isValueType()) {
	                        var vt = tp;
	                        vt.setGloballyDeclaredBy(cl);
	                    }
	                }
	                if (cl.getConvertsToGlobal()) {
	                    var tp = u.getType(cl.getConvertsToGlobal());
	                    if (tp.isValueType()) {
	                        var vt = tp;
	                        vt.setGloballyDeclaredBy(cl);
	                    }
	                }
	            }
	        }
	    });
	    return u;
	}
	exports.toDefSystem = toDefSystem;
	var annotationHandlers = {
	    key: function (a, f) {
	        f.withFromParentKey();
	        f.withKey(true);
	    },
	    value: function (a, f) {
	        f.withFromParentValue();
	    },
	    canBeValue: function (a, f) {
	        f.withCanBeValue();
	    },
	    unmerged: function (a, f) {
	        f.unmerge();
	    },
	    startFrom: function (a, f) {
	        f.withKeyRestriction(a.arguments[0]);
	        f.merge();
	    },
	    oneOf: function (a, f) {
	        f.withEnumOptions(a.arguments[0]);
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    oftenKeys: function (a, f) {
	        f.withOftenKeys(a.arguments[0]);
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    embeddedInMaps: function (a, f) {
	        f.withEmbedMap();
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    system: function (a, f) {
	        f.withSystem(true);
	    },
	    required: function (a, f) {
	        if (a.arguments[0] != 'false') {
	            f.withRequired(true);
	        }
	    },
	    noDirectParse: function (a, f) {
	        if (a.arguments[0] != 'false') {
	            f.withNoDirectParse();
	        }
	    },
	    setsContextValue: function (a, f) {
	        f.addChildValueConstraint(new def.ChildValueConstraint("" + a.arguments[0], "" + a.arguments[1]));
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    defaultValue: function (a, f) {
	        f.setDefaultVal("" + a.arguments[0]);
	    },
	    facetId: function (a, f) {
	        if (a.arguments[0] == "minItems") {
	            f.setFacetValidator(function (x, f) {
	                if (x instanceof Array) {
	                    var length = Number.parseInt("" + f.value());
	                    if (length > x.length) {
	                        return "array should contain at least " + f.value() + " items";
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "maxItems") {
	            f.setFacetValidator(function (x, f) {
	                if (x instanceof Array) {
	                    var length = Number.parseInt("" + f.value());
	                    if (length < x.length) {
	                        return "array should contain not more then " + f.value() + " items";
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "minProperties") {
	            f.setFacetValidator(function (x, f) {
	                if (x instanceof Object) {
	                    var length = Number.parseInt("" + f.value());
	                    if (length > Object.keys(x).length) {
	                        return "object should contain at least " + f.value() + " properties";
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "maxProperties") {
	            f.setFacetValidator(function (x, f) {
	                if (x instanceof Object) {
	                    var length = Number.parseInt("" + f.value());
	                    if (length < Object.keys(x).length) {
	                        return "object should contain not more then " + f.value() + " properties";
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "uniqueItems") {
	            f.setFacetValidator(function (x, f) {
	                if (x instanceof Array) {
	                    var length = _.unique(x).length;
	                    if (length < x.length) {
	                        return "array should contain only unique items";
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "minLength") {
	            f.setFacetValidator(function (x, f) {
	                if (typeof x == 'number' || typeof x == 'boolean') {
	                    x = "" + x;
	                }
	                if (typeof x == 'string') {
	                    var length = Number.parseInt("" + f.value());
	                    if (length > x.length) {
	                        return "string length should be at least " + length;
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "maxLength") {
	            f.setFacetValidator(function (x, f) {
	                if (typeof x == 'number' || typeof x == 'boolean') {
	                    x = "" + x;
	                }
	                if (typeof x == 'string') {
	                    var length = Number.parseInt("" + f.value());
	                    if (length < x.length) {
	                        return "string length should be not more then " + length;
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "minimum") {
	            f.setFacetValidator(function (x, f) {
	                if (typeof x == 'string') {
	                    x = parseFloat(x);
	                }
	                if (typeof x == 'number') {
	                    var length = parseFloat(f.value());
	                    if (length > x) {
	                        return "value should be not less then " + length;
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "maximum") {
	            f.setFacetValidator(function (x, f) {
	                if (typeof x == 'string') {
	                    x = parseFloat(x);
	                }
	                if (typeof x == 'number') {
	                    var length = parseFloat(f.value());
	                    if (length < x) {
	                        return "value should be not more then " + length;
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "pattern") {
	            f.setFacetValidator(function (x, f) {
	                if (typeof x == 'number' || typeof x == 'boolean') {
	                    x = "" + x;
	                }
	                if (typeof x == 'string') {
	                    var regExp = new RegExp(f.value());
	                    if (!regExp.test(x)) {
	                        return "string should match to " + f.value();
	                    }
	                }
	                return null;
	            });
	        }
	    },
	    extraMetaKey: function (a, f) {
	        if (a.arguments[0] == "statusCodes") {
	            f.withOftenKeys(khttp.statusCodes.map(function (x) { return x.code; }));
	            f.setValueDocProvider(function (name) {
	                var s = _.find(khttp.statusCodes, function (x) { return x.code == name; });
	                if (s) {
	                    return (name + ":" + s.description);
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "annotationTargets") {
	            var targets = [];
	            targets.push("Parameter");
	            targets.push("Field");
	            targets.push("GlobalSchema");
	            targets = targets.concat(["API", "DocumentationItem", "Resource", "Method", "Response", "RequestBody", "ResponseBody", "DataElement", "NamedExample", "ResourceType", "Trait", "SecurityScheme", "SecuritySchemeSettings", "AnnotationType", "Library", "Overlay", "Extension"]);
	            f.withEnumOptions(targets);
	        }
	        if (a.arguments[0] == "headers") {
	            f.setValueSuggester(function (x) {
	                console.log(x);
	                var c = x.property().getChildValueConstraints();
	                if (_.find(c, function (x) {
	                    return x.name == "location" && x.value == "Params.ParameterLocation.HEADERS";
	                })) {
	                    return khttp.headers.map(function (x) { return x.header; });
	                }
	                if (x.property()) {
	                    if (x.property().name() == "headers") {
	                        return khttp.headers.map(function (x) { return x.header; });
	                    }
	                }
	                return null;
	            });
	            f.setValueDocProvider(function (name) {
	                var s = _.find(khttp.headers, function (x) { return x.header == name; });
	                if (s) {
	                    return (name + ":" + s.description);
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "methods") {
	            f.setValueDocProvider(function (name) {
	                var s = _.find(khttp.methods, function (x) { return x.method == name.toUpperCase(); });
	                if (s) {
	                    return (name + ":" + s.description);
	                }
	                return null;
	            });
	        }
	    },
	    requireValue: function (a, f) {
	        f.withContextRequirement("" + a.arguments[0], "" + a.arguments[1]);
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    allowMultiple: function (a, f) {
	        f.withMultiValue(true);
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    selector: function (a, f) {
	        f.setSelector("" + a.arguments[0]);
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    constraint: function (a, f) {
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    newInstanceName: function (a, f) {
	        f.withNewInstanceName("" + a.arguments[0]);
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    declaringFields: function (a, f) {
	        f.withThisPropertyDeclaresFields();
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    describesAnnotation: function (a, f) {
	        //f.withReferenceParameters();
	        f.withDescribes(a.arguments[0]);
	    },
	    allowNull: function (a, f) {
	        f.withAllowNull();
	    },
	    descriminatingProperty: function (a, f) {
	        //f.withReferenceParameters();
	        f.withDescriminating(true);
	    },
	    description: function (a, f) {
	        f.withDescription("" + a.arguments[0]);
	        //f.withReferenceParameters();
	        //f.withDescriminating(true)
	    },
	    issue: function (a, f) {
	        //f.withReferenceParameters();
	        //f.withDescriminating(true)
	        f.withIssue("" + a.arguments[0]);
	    },
	    inherited: function (a, f) {
	        f.withInherited(true);
	    },
	    version: function (a, f) {
	        f.withVersion("" + a.arguments[0]);
	    },
	    needsClarification: function (a, f) {
	        //f.withReferenceParameters();
	        //f.withDescriminating(true)
	        f.withClarify("" + a.arguments[0]);
	    },
	    thisFeatureCovers: function (a, f) {
	        //f.withReferenceParameters();
	        //f.withDescriminating(true)
	        f.withThisFeatureCovers("" + a.arguments[0]);
	    },
	    selfNode: function (a, f) {
	        f.withSelfNode();
	    },
	    valueRestriction: function (a, f) {
	        f.withValueRewstrinction("" + a.arguments[0], "" + a.arguments[1]);
	    },
	    grammarTokenKind: function (a, f) {
	        f.withPropertyGrammarType("" + a.arguments[0]);
	    },
	    canInherit: function (a, f) {
	        f.withInheritedContextValue("" + a.arguments[0]);
	    },
	    canBeDuplicator: function (a, f) {
	        f.setCanBeDuplicator();
	    },
	    hide: function (a, f) {
	        if (a.arguments.length == 0) {
	            f.setHidden(true);
	        }
	        else {
	            f.setHidden(a.arguments[0]);
	        }
	    },
	    documentationTableLabel: function (a, f) {
	        f.setDocTableName("" + a.arguments[0]);
	    },
	    markdownDescription: function (a, f) {
	        f.setMarkdownDescription("" + a.arguments[0]);
	    },
	    valueDescription: function (a, f) {
	        f.setValueDescription(a.arguments[0] != null ? ("" + a.arguments[0]) : null);
	    }
	};
	function recordAnnotation(p, a) {
	    annotationHandlers[a.name](a, p);
	}
	exports.recordAnnotation = recordAnnotation;
	var processAnnotations = function (x, p, annotations) {
	    if (!annotations) {
	        annotations = x.annotations();
	    }
	    annotations.forEach(function (x) {
	        var nm = x.name.substring(x.name.lastIndexOf(".") + 1);
	        if (!annotationHandlers[nm]) {
	            console.log("Can not find handler for:");
	        }
	        annotationHandlers[nm](x, p);
	    });
	};
	function createProp(x, clazz, t, annotations) {
	    var p = def.prop(x.name(), "", clazz, t);
	    if (x.isMultiValue()) {
	        p.withMultiValue(true);
	    }
	    p.unmerge();
	    if (!t.isValueType()) {
	        t.properties().forEach(function (p0) {
	            if (p0.isKey()) {
	                var kp = p0.keyPrefix();
	                if (kp) {
	                    p.withKeyRestriction(kp);
	                    p.merge();
	                }
	                var eo = p0.getEnumOptions();
	                if (eo) {
	                    p.withEnumOptions(eo);
	                    p.merge();
	                }
	            }
	        });
	    }
	    processAnnotations(x, p, annotations);
	}
	//# sourceMappingURL=tsStrut2Def.js.map

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var path = __webpack_require__(11);
	var fs = __webpack_require__(12);

	module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

	function mkdirP (p, opts, f, made) {
	    if (typeof opts === 'function') {
	        f = opts;
	        opts = {};
	    }
	    else if (!opts || typeof opts !== 'object') {
	        opts = { mode: opts };
	    }
	    
	    var mode = opts.mode;
	    var xfs = opts.fs || fs;
	    
	    if (mode === undefined) {
	        mode = 0777 & (~process.umask());
	    }
	    if (!made) made = null;
	    
	    var cb = f || function () {};
	    p = path.resolve(p);
	    
	    xfs.mkdir(p, mode, function (er) {
	        if (!er) {
	            made = made || p;
	            return cb(null, made);
	        }
	        switch (er.code) {
	            case 'ENOENT':
	                mkdirP(path.dirname(p), opts, function (er, made) {
	                    if (er) cb(er, made);
	                    else mkdirP(p, opts, cb, made);
	                });
	                break;

	            // In the case of any other error, just see if there's a dir
	            // there already.  If so, then hooray!  If not, then something
	            // is borked.
	            default:
	                xfs.stat(p, function (er2, stat) {
	                    // if the stat fails, then that's super weird.
	                    // let the original error be the failure reason.
	                    if (er2 || !stat.isDirectory()) cb(er, made)
	                    else cb(null, made);
	                });
	                break;
	        }
	    });
	}

	mkdirP.sync = function sync (p, opts, made) {
	    if (!opts || typeof opts !== 'object') {
	        opts = { mode: opts };
	    }
	    
	    var mode = opts.mode;
	    var xfs = opts.fs || fs;
	    
	    if (mode === undefined) {
	        mode = 0777 & (~process.umask());
	    }
	    if (!made) made = null;

	    p = path.resolve(p);

	    try {
	        xfs.mkdirSync(p, mode);
	        made = made || p;
	    }
	    catch (err0) {
	        switch (err0.code) {
	            case 'ENOENT' :
	                made = sync(path.dirname(p), opts, made);
	                sync(p, opts, made);
	                break;

	            // In the case of any other error, just see if there's a dir
	            // there already.  If so, then hooray!  If not, then something
	            // is borked.
	            default:
	                var stat;
	                try {
	                    stat = xfs.statSync(p);
	                }
	                catch (err1) {
	                    throw err0;
	                }
	                if (!stat.isDirectory()) throw err0;
	                break;
	        }
	    }

	    return made;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(72)))

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * media-typer
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	/**
	 * RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7
	 *
	 * parameter     = token "=" ( token | quoted-string )
	 * token         = 1*<any CHAR except CTLs or separators>
	 * separators    = "(" | ")" | "<" | ">" | "@"
	 *               | "," | ";" | ":" | "\" | <">
	 *               | "/" | "[" | "]" | "?" | "="
	 *               | "{" | "}" | SP | HT
	 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
	 * qdtext        = <any TEXT except <">>
	 * quoted-pair   = "\" CHAR
	 * CHAR          = <any US-ASCII character (octets 0 - 127)>
	 * TEXT          = <any OCTET except CTLs, but including LWS>
	 * LWS           = [CRLF] 1*( SP | HT )
	 * CRLF          = CR LF
	 * CR            = <US-ASCII CR, carriage return (13)>
	 * LF            = <US-ASCII LF, linefeed (10)>
	 * SP            = <US-ASCII SP, space (32)>
	 * SHT           = <US-ASCII HT, horizontal-tab (9)>
	 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
	 * OCTET         = <any 8-bit sequence of data>
	 */
	var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
	var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/
	var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/

	/**
	 * RegExp to match quoted-pair in RFC 2616
	 *
	 * quoted-pair = "\" CHAR
	 * CHAR        = <any US-ASCII character (octets 0 - 127)>
	 */
	var qescRegExp = /\\([\u0000-\u007f])/g;

	/**
	 * RegExp to match chars that must be quoted-pair in RFC 2616
	 */
	var quoteRegExp = /([\\"])/g;

	/**
	 * RegExp to match type in RFC 6838
	 *
	 * type-name = restricted-name
	 * subtype-name = restricted-name
	 * restricted-name = restricted-name-first *126restricted-name-chars
	 * restricted-name-first  = ALPHA / DIGIT
	 * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
	 *                          "$" / "&" / "-" / "^" / "_"
	 * restricted-name-chars =/ "." ; Characters before first dot always
	 *                              ; specify a facet name
	 * restricted-name-chars =/ "+" ; Characters after last plus always
	 *                              ; specify a structured syntax suffix
	 * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
	 * DIGIT =  %x30-39             ; 0-9
	 */
	var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/
	var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/
	var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;

	/**
	 * Module exports.
	 */

	exports.format = format
	exports.parse = parse

	/**
	 * Format object to media type.
	 *
	 * @param {object} obj
	 * @return {string}
	 * @api public
	 */

	function format(obj) {
	  if (!obj || typeof obj !== 'object') {
	    throw new TypeError('argument obj is required')
	  }

	  var parameters = obj.parameters
	  var subtype = obj.subtype
	  var suffix = obj.suffix
	  var type = obj.type

	  if (!type || !typeNameRegExp.test(type)) {
	    throw new TypeError('invalid type')
	  }

	  if (!subtype || !subtypeNameRegExp.test(subtype)) {
	    throw new TypeError('invalid subtype')
	  }

	  // format as type/subtype
	  var string = type + '/' + subtype

	  // append +suffix
	  if (suffix) {
	    if (!typeNameRegExp.test(suffix)) {
	      throw new TypeError('invalid suffix')
	    }

	    string += '+' + suffix
	  }

	  // append parameters
	  if (parameters && typeof parameters === 'object') {
	    var param
	    var params = Object.keys(parameters).sort()

	    for (var i = 0; i < params.length; i++) {
	      param = params[i]

	      if (!tokenRegExp.test(param)) {
	        throw new TypeError('invalid parameter name')
	      }

	      string += '; ' + param + '=' + qstring(parameters[param])
	    }
	  }

	  return string
	}

	/**
	 * Parse media type to object.
	 *
	 * @param {string|object} string
	 * @return {Object}
	 * @api public
	 */

	function parse(string) {
	  if (!string) {
	    throw new TypeError('argument string is required')
	  }

	  // support req/res-like objects as argument
	  if (typeof string === 'object') {
	    string = getcontenttype(string)
	  }

	  if (typeof string !== 'string') {
	    throw new TypeError('argument string is required to be a string')
	  }

	  var index = string.indexOf(';')
	  var type = index !== -1
	    ? string.substr(0, index)
	    : string

	  var key
	  var match
	  var obj = splitType(type)
	  var params = {}
	  var value

	  paramRegExp.lastIndex = index

	  while (match = paramRegExp.exec(string)) {
	    if (match.index !== index) {
	      throw new TypeError('invalid parameter format')
	    }

	    index += match[0].length
	    key = match[1].toLowerCase()
	    value = match[2]

	    if (value[0] === '"') {
	      // remove quotes and escapes
	      value = value
	        .substr(1, value.length - 2)
	        .replace(qescRegExp, '$1')
	    }

	    params[key] = value
	  }

	  if (index !== -1 && index !== string.length) {
	    throw new TypeError('invalid parameter format')
	  }

	  obj.parameters = params

	  return obj
	}

	/**
	 * Get content-type from req/res objects.
	 *
	 * @param {object}
	 * @return {Object}
	 * @api private
	 */

	function getcontenttype(obj) {
	  if (typeof obj.getHeader === 'function') {
	    // res-like
	    return obj.getHeader('content-type')
	  }

	  if (typeof obj.headers === 'object') {
	    // req-like
	    return obj.headers && obj.headers['content-type']
	  }
	}

	/**
	 * Quote a string if necessary.
	 *
	 * @param {string} val
	 * @return {string}
	 * @api private
	 */

	function qstring(val) {
	  var str = String(val)

	  // no need to quote tokens
	  if (tokenRegExp.test(str)) {
	    return str
	  }

	  if (str.length > 0 && !textRegExp.test(str)) {
	    throw new TypeError('invalid parameter value')
	  }

	  return '"' + str.replace(quoteRegExp, '\\$1') + '"'
	}

	/**
	 * Simply "type/subtype+siffx" into parts.
	 *
	 * @param {string} string
	 * @return {Object}
	 * @api private
	 */

	function splitType(string) {
	  var match = typeRegExp.exec(string.toLowerCase())

	  if (!match) {
	    throw new TypeError('invalid media type')
	  }

	  var type = match[1]
	  var subtype = match[2]
	  var suffix

	  // suffix after last +
	  var index = subtype.lastIndexOf('+')
	  if (index !== -1) {
	    suffix = subtype.substr(index + 1)
	    subtype = subtype.substr(0, index)
	  }

	  var obj = {
	    type: type,
	    subtype: subtype,
	    suffix: suffix
	  }

	  return obj
	}


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = typescript;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = child_process;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = _spawn_sync;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/* global define */

	(function (root, pluralize) {
	  /* istanbul ignore else */
	  if (true) {
	    // Node.
	    module.exports = pluralize();
	  } else if (typeof define === 'function' && define.amd) {
	    // AMD, registers as an anonymous module.
	    define(function () {
	      return pluralize();
	    });
	  } else {
	    // Browser global.
	    root.pluralize = pluralize();
	  }
	})(this, function () {
	  // Rule storage - pluralize and singularize need to be run sequentially,
	  // while other rules can be optimized using an object for instant lookups.
	  var pluralRules = [];
	  var singularRules = [];
	  var uncountables = {};
	  var irregularPlurals = {};
	  var irregularSingles = {};

	  /**
	   * Title case a string.
	   *
	   * @param  {string} str
	   * @return {string}
	   */
	  function toTitleCase (str) {
	    return str.charAt(0).toUpperCase() + str.substr(1).toLowerCase();
	  }

	  /**
	   * Sanitize a pluralization rule to a usable regular expression.
	   *
	   * @param  {(RegExp|string)} rule
	   * @return {RegExp}
	   */
	  function sanitizeRule (rule) {
	    if (typeof rule === 'string') {
	      return new RegExp('^' + rule + '$', 'i');
	    }

	    return rule;
	  }

	  /**
	   * Pass in a word token to produce a function that can replicate the case on
	   * another word.
	   *
	   * @param  {string}   word
	   * @param  {string}   token
	   * @return {Function}
	   */
	  function restoreCase (word, token) {
	    // Upper cased words. E.g. "HELLO".
	    if (word === word.toUpperCase()) {
	      return token.toUpperCase();
	    }

	    // Title cased words. E.g. "Title".
	    if (word[0] === word[0].toUpperCase()) {
	      return toTitleCase(token);
	    }

	    // Lower cased words. E.g. "test".
	    return token.toLowerCase();
	  }

	  /**
	   * Interpolate a regexp string.
	   *
	   * @param  {string} str
	   * @param  {Array}  args
	   * @return {string}
	   */
	  function interpolate (str, args) {
	    return str.replace(/\$(\d{1,2})/g, function (match, index) {
	      return args[index] || '';
	    });
	  }

	  /**
	   * Sanitize a word by passing in the word and sanitization rules.
	   *
	   * @param  {String}   token
	   * @param  {String}   word
	   * @param  {Array}    collection
	   * @return {String}
	   */
	  function sanitizeWord (token, word, collection) {
	    // Empty string or doesn't need fixing.
	    if (!token.length || uncountables.hasOwnProperty(token)) {
	      return word;
	    }

	    var len = collection.length;

	    // Iterate over the sanitization rules and use the first one to match.
	    while (len--) {
	      var rule = collection[len];

	      // If the rule passes, return the replacement.
	      if (rule[0].test(word)) {
	        return word.replace(rule[0], function (match, index, word) {
	          var result = interpolate(rule[1], arguments);

	          if (match === '') {
	            return restoreCase(word[index - 1], result);
	          }

	          return restoreCase(match, result);
	        });
	      }
	    }

	    return word;
	  }

	  /**
	   * Replace a word with the updated word.
	   *
	   * @param  {Object}   replaceMap
	   * @param  {Object}   keepMap
	   * @param  {Array}    rules
	   * @return {Function}
	   */
	  function replaceWord (replaceMap, keepMap, rules) {
	    return function (word) {
	      // Get the correct token and case restoration functions.
	      var token = word.toLowerCase();

	      // Check against the keep object map.
	      if (keepMap.hasOwnProperty(token)) {
	        return restoreCase(word, token);
	      }

	      // Check against the replacement map for a direct word replacement.
	      if (replaceMap.hasOwnProperty(token)) {
	        return restoreCase(word, replaceMap[token]);
	      }

	      // Run all the rules against the word.
	      return sanitizeWord(token, word, rules);
	    };
	  }

	  /**
	   * Pluralize or singularize a word based on the passed in count.
	   *
	   * @param  {String}  word
	   * @param  {Number}  count
	   * @param  {Boolean} inclusive
	   * @return {String}
	   */
	  function pluralize (word, count, inclusive) {
	    var pluralized = count === 1
	      ? pluralize.singular(word) : pluralize.plural(word);

	    return (inclusive ? count + ' ' : '') + pluralized;
	  }

	  /**
	   * Pluralize a word.
	   *
	   * @type {Function}
	   */
	  pluralize.plural = replaceWord(
	    irregularSingles, irregularPlurals, pluralRules
	  );

	  /**
	   * Singularize a word.
	   *
	   * @type {Function}
	   */
	  pluralize.singular = replaceWord(
	    irregularPlurals, irregularSingles, singularRules
	  );

	  /**
	   * Add a pluralization rule to the collection.
	   *
	   * @param {(string|RegExp)} rule
	   * @param {string}          replacement
	   */
	  pluralize.addPluralRule = function (rule, replacement) {
	    pluralRules.push([sanitizeRule(rule), replacement]);
	  };

	  /**
	   * Add a singularization rule to the collection.
	   *
	   * @param {(string|RegExp)} rule
	   * @param {string}          replacement
	   */
	  pluralize.addSingularRule = function (rule, replacement) {
	    singularRules.push([sanitizeRule(rule), replacement]);
	  };

	  /**
	   * Add an uncountable word rule.
	   *
	   * @param {(string|RegExp)} word
	   */
	  pluralize.addUncountableRule = function (word) {
	    if (typeof word === 'string') {
	      uncountables[word.toLowerCase()] = true;
	      return;
	    }

	    // Set singular and plural references for the word.
	    pluralize.addPluralRule(word, '$0');
	    pluralize.addSingularRule(word, '$0');
	  };

	  /**
	   * Add an irregular word definition.
	   *
	   * @param {String} single
	   * @param {String} plural
	   */
	  pluralize.addIrregularRule = function (single, plural) {
	    plural = plural.toLowerCase();
	    single = single.toLowerCase();

	    irregularSingles[single] = plural;
	    irregularPlurals[plural] = single;
	  };

	  /**
	   * Irregular rules.
	   */
	  [
	    // Pronouns.
	    ['I', 'we'],
	    ['me', 'us'],
	    ['he', 'they'],
	    ['she', 'they'],
	    ['them', 'them'],
	    ['myself', 'ourselves'],
	    ['yourself', 'yourselves'],
	    ['itself', 'themselves'],
	    ['herself', 'themselves'],
	    ['himself', 'themselves'],
	    ['themself', 'themselves'],
	    ['is', 'are'],
	    ['this', 'these'],
	    ['that', 'those'],
	    // Words ending in with a consonant and `o`.
	    ['echo', 'echoes'],
	    ['dingo', 'dingoes'],
	    ['volcano', 'volcanoes'],
	    ['tornado', 'tornadoes'],
	    ['torpedo', 'torpedoes'],
	    // Ends with `us`.
	    ['genus', 'genera'],
	    ['viscus', 'viscera'],
	    // Ends with `ma`.
	    ['stigma', 'stigmata'],
	    ['stoma', 'stomata'],
	    ['dogma', 'dogmata'],
	    ['lemma', 'lemmata'],
	    ['schema', 'schemata'],
	    ['anathema', 'anathemata'],
	    // Other irregular rules.
	    ['ox', 'oxen'],
	    ['axe', 'axes'],
	    ['die', 'dice'],
	    ['yes', 'yeses'],
	    ['foot', 'feet'],
	    ['eave', 'eaves'],
	    ['goose', 'geese'],
	    ['tooth', 'teeth'],
	    ['quiz', 'quizzes'],
	    ['human', 'humans'],
	    ['proof', 'proofs'],
	    ['carve', 'carves'],
	    ['valve', 'valves'],
	    ['thief', 'thieves'],
	    ['genie', 'genies'],
	    ['groove', 'grooves'],
	    ['pickaxe', 'pickaxes'],
	    ['whiskey', 'whiskies']
	  ].forEach(function (rule) {
	    return pluralize.addIrregularRule(rule[0], rule[1]);
	  });

	  /**
	   * Pluralization rules.
	   */
	  [
	    [/s?$/i, 's'],
	    [/([^aeiou]ese)$/i, '$1'],
	    [/(ax|test)is$/i, '$1es'],
	    [/(alias|[^aou]us|tlas|gas|ris)$/i, '$1es'],
	    [/(e[mn]u)s?$/i, '$1s'],
	    [/([^l]ias|[aeiou]las|[emjzr]as|[iu]am)$/i, '$1'],
	    [/(alumn|syllab|octop|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, '$1i'],
	    [/(alumn|alg|vertebr)(?:a|ae)$/i, '$1ae'],
	    [/(seraph|cherub)(?:im)?$/i, '$1im'],
	    [/(her|at|gr)o$/i, '$1oes'],
	    [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, '$1a'],
	    [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, '$1a'],
	    [/sis$/i, 'ses'],
	    [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, '$1$2ves'],
	    [/([^aeiouy]|qu)y$/i, '$1ies'],
	    [/([^ch][ieo][ln])ey$/i, '$1ies'],
	    [/(x|ch|ss|sh|zz)$/i, '$1es'],
	    [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, '$1ices'],
	    [/(m|l)(?:ice|ouse)$/i, '$1ice'],
	    [/(pe)(?:rson|ople)$/i, '$1ople'],
	    [/(child)(?:ren)?$/i, '$1ren'],
	    [/eaux$/i, '$0'],
	    [/m[ae]n$/i, 'men'],
	    ['thou', 'you']
	  ].forEach(function (rule) {
	    return pluralize.addPluralRule(rule[0], rule[1]);
	  });

	  /**
	   * Singularization rules.
	   */
	  [
	    [/s$/i, ''],
	    [/(ss)$/i, '$1'],
	    [/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)(?:sis|ses)$/i, '$1sis'],
	    [/(^analy)(?:sis|ses)$/i, '$1sis'],
	    [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, '$1fe'],
	    [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, '$1f'],
	    [/([^aeiouy]|qu)ies$/i, '$1y'],
	    [/(^[pl]|zomb|^(?:neck)?t|[aeo][lt]|cut)ies$/i, '$1ie'],
	    [/([^c][eor]n|smil)ies$/i, '$1ey'],
	    [/(m|l)ice$/i, '$1ouse'],
	    [/(seraph|cherub)im$/i, '$1'],
	    [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|tlas|gas|(?:her|at|gr)o|ris)(?:es)?$/i, '$1'],
	    [/(e[mn]u)s?$/i, '$1'],
	    [/(movie|twelve)s$/i, '$1'],
	    [/(cris|test|diagnos)(?:is|es)$/i, '$1is'],
	    [/(alumn|syllab|octop|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, '$1us'],
	    [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, '$1um'],
	    [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, '$1on'],
	    [/(alumn|alg|vertebr)ae$/i, '$1a'],
	    [/(cod|mur|sil|vert|ind)ices$/i, '$1ex'],
	    [/(matr|append)ices$/i, '$1ix'],
	    [/(pe)(rson|ople)$/i, '$1rson'],
	    [/(child)ren$/i, '$1'],
	    [/(eau)x?$/i, '$1'],
	    [/men$/i, 'man']
	  ].forEach(function (rule) {
	    return pluralize.addSingularRule(rule[0], rule[1]);
	  });

	  /**
	   * Uncountable rules.
	   */
	  [
	    // Singular words with no plurals.
	    'advice',
	    'agenda',
	    'bison',
	    'bream',
	    'buffalo',
	    'carp',
	    'chassis',
	    'cod',
	    'cooperation',
	    'corps',
	    'digestion',
	    'debris',
	    'diabetes',
	    'energy',
	    'equipment',
	    'elk',
	    'excretion',
	    'expertise',
	    'flounder',
	    'gallows',
	    'garbage',
	    'graffiti',
	    'headquarters',
	    'health',
	    'herpes',
	    'highjinks',
	    'homework',
	    'information',
	    'jeans',
	    'justice',
	    'kudos',
	    'labour',
	    'machinery',
	    'mackerel',
	    'media',
	    'mews',
	    'moose',
	    'news',
	    'pike',
	    'plankton',
	    'pliers',
	    'pollution',
	    'premises',
	    'rain',
	    'rice',
	    'salmon',
	    'scissors',
	    'series',
	    'sewage',
	    'shambles',
	    'shrimp',
	    'species',
	    'staff',
	    'swine',
	    'trout',
	    'tuna',
	    'whiting',
	    'wildebeest',
	    'wildlife',
	    'you',
	    // Regexes.
	    /pox$/i, // "chickpox", "smallpox"
	    /ois$/i,
	    /deer$/i, // "deer", "reindeer"
	    /fish$/i, // "fish", "blowfish", "angelfish"
	    /sheep$/i,
	    /measles$/i,
	    /[^aeiou]ese$/i // "chinese", "japanese"
	  ].forEach(pluralize.addUncountableRule);

	  return pluralize;
	});


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule invariant
	 */

	'use strict';

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var invariant = function(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        'Invariant Violation: ' +
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};

	module.exports = invariant;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(72)))

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3
	//     http://underscorejs.org
	//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind,
	    nativeCreate       = Object.create;

	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.8.3';

	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      case 2: return function(value, other) {
	        return func.call(context, value, other);
	      };
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };

	  // A mostly-internal function to generate callbacks that can be applied
	  // to each element in a collection, returning the desired result — either
	  // identity, an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function(value, context, argCount) {
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value)) return _.matcher(value);
	    return _.property(value);
	  };
	  _.iteratee = function(value, context) {
	    return cb(value, context, Infinity);
	  };

	  // An internal function for creating assigner functions.
	  var createAssigner = function(keysFunc, undefinedOnly) {
	    return function(obj) {
	      var length = arguments.length;
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };

	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  };

	  var property = function(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };

	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = property('length');
	  var isArrayLike = function(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };

	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  // Create a reducing function iterating left or right.
	  function createReduce(dir) {
	    // Optimized iterator function as using arguments.length
	    // in the main function will deoptimize the, see #1991.
	    function iterator(obj, iteratee, memo, keys, index, length) {
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    }

	    return function(obj, iteratee, memo, context) {
	      iteratee = optimizeCb(iteratee, context, 4);
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      // Determine the initial value if none is provided.
	      if (arguments.length < 3) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      return iterator(obj, iteratee, memo, keys, index, length);
	    };
	  }

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);

	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var key;
	    if (isArrayLike(obj)) {
	      key = _.findIndex(obj, predicate, context);
	    } else {
	      key = _.findKey(obj, predicate, context);
	    }
	    if (key !== void 0 && key !== -1) return obj[key];
	  };

	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };

	  // Determine if the array or object contains a given item (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return _.indexOf(obj, item, fromIndex) >= 0;
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      var func = isFunc ? method : value[method];
	      return func == null ? func : func.apply(value, args);
	    });
	  };

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };

	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Shuffle a collection, using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
	  _.shuffle = function(obj) {
	    var set = isArrayLike(obj) ? obj : _.values(obj);
	    var length = set.length;
	    var shuffled = Array(length);
	    for (var index = 0, rand; index < length; index++) {
	      rand = _.random(0, index);
	      if (rand !== index) shuffled[index] = shuffled[rand];
	      shuffled[rand] = set[index];
	    }
	    return shuffled;
	  };

	  // Sample **n** random values from a collection.
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };

	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iteratee(value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, iteratee, context) {
	      var result = {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key]++; else result[key] = 1;
	  });

	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };

	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var pass = [], fail = [];
	    _.each(obj, function(value, key, obj) {
	      (predicate(value, key, obj) ? pass : fail).push(value);
	    });
	    return [pass, fail];
	  };

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, startIndex) {
	    var output = [], idx = 0;
	    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        //flatten current level of array or arguments object
	        if (!shallow) value = flatten(value, shallow, strict);
	        var j = 0, len = value.length;
	        output.length += len;
	        while (j < len) {
	          output[idx++] = value[j++];
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };

	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(flatten(arguments, true, true));
	  };

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      for (var j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = flatten(arguments, true, true, 1);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    return _.unzip(arguments);
	  };

	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices
	  _.unzip = function(array) {
	    var length = array && _.max(array, getLength).length || 0;
	    var result = Array(length);

	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // Generator function to create the findIndex and findLastIndex functions
	  function createPredicateIndexFinder(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  }

	  // Returns the first index on an array-like that passes a predicate test
	  _.findIndex = createPredicateIndexFinder(1);
	  _.findLastIndex = createPredicateIndexFinder(-1);

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };

	  // Generator function to create the indexOf and lastIndexOf functions
	  function createIndexFinder(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	            i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), _.isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  }

	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
	  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = step || 1;

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);

	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }

	    return range;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments
	  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var args = slice.call(arguments, 2);
	    var bound = function() {
	      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
	    };
	    return bound;
	  };

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder, allowing any combination of arguments to be pre-filled.
	  _.partial = function(func) {
	    var boundArgs = slice.call(arguments, 1);
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  };

	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var i, length = arguments.length, key;
	    if (length <= 1) throw new Error('bindAll must be passed function names');
	    for (i = 1; i < length; i++) {
	      key = arguments[i];
	      obj[key] = _.bind(obj[key], obj);
	    }
	    return obj;
	  };

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){
	      return func.apply(null, args);
	    }, wait);
	  };

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    if (!options) options = {};
	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };
	    return function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;

	    var later = function() {
	      var last = _.now() - timestamp;

	      if (last < wait && last >= 0) {
	        timeout = setTimeout(later, wait - last);
	      } else {
	        timeout = null;
	        if (!immediate) {
	          result = func.apply(context, args);
	          if (!timeout) context = args = null;
	        }
	      }
	    };

	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = _.now();
	      var callNow = immediate && !timeout;
	      if (!timeout) timeout = setTimeout(later, wait);
	      if (callNow) {
	        result = func.apply(context, args);
	        context = args = null;
	      }

	      return result;
	    };
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };

	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };

	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);

	  // Object Functions
	  // ----------------

	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

	  function collectNonEnumProps(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  }

	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve all the property names of an object.
	  _.allKeys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };

	  // Returns the results of applying the iteratee to each element of the object
	  // In contrast to _.map it returns an object
	  _.mapObject = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys =  _.keys(obj),
	          length = keys.length,
	          results = {},
	          currentKey;
	      for (var index = 0; index < length; index++) {
	        currentKey = keys[index];
	        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	      }
	      return results;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);

	  // Assigns a given object with all the own properties in the passed-in object(s)
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);

	  // Returns the first key on an object that passes a predicate test
	  _.findKey = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj), key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(object, oiteratee, context) {
	    var result = {}, obj = object, iteratee, keys;
	    if (obj == null) return result;
	    if (_.isFunction(oiteratee)) {
	      keys = _.allKeys(obj);
	      iteratee = optimizeCb(oiteratee, context);
	    } else {
	      keys = flatten(arguments, false, false, 1);
	      iteratee = function(value, key, obj) { return key in obj; };
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  };

	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj, iteratee, context) {
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	    } else {
	      var keys = _.map(flatten(arguments, false, false, 1), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  };

	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);

	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  _.create = function(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) _.extendOwn(result, props);
	    return result;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function(object, attrs) {
	    var keys = _.keys(attrs), length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };


	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	    }

	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;

	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	                               _.isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }

	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);

	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return _.has(obj, 'callee');
	    };
	  }

	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), and in Safari 8 (#1929).
	  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj !== +obj;
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return obj != null && hasOwnProperty.call(obj, key);
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };

	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };

	  _.noop = function(){};

	  _.property = property;

	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function(obj) {
	    return obj == null ? function(){} : function(key) {
	      return obj[key];
	    };
	  };

	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  _.matcher = _.matches = function(attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function(obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };

	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };

	   // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);

	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property, fallback) {
	    var value = object == null ? void 0 : object[property];
	    if (value === void 0) {
	      value = fallback;
	    }
	    return _.isFunction(value) ? value.call(object) : value;
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escaper, escapeChar);
	      index = offset + match.length;

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }

	      // Adobe VMs need the match returned to produce the correct offest.
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';

	    try {
	      var render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var result = function(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result(this, func.apply(_, args));
	      };
	    });
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return result(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };

	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

	  _.prototype.toString = function() {
	    return '' + this._wrapped;
	  };

	  // AMD registration happens at the end for compatibility with AMD loaders
	  // that may not enforce next-turn semantics on modules. Even though general
	  // practice for AMD registration is to be anonymous, underscore registers
	  // as a named module because, like jQuery, it is a base library that is
	  // popular enough to be bundled in a third party lib, but not be part of
	  // an AMD load request. Those cases could generate an error when an
	  // anonymous define() is called outside of a loader request.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}.call(this));


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {(function() {
	  var vm,
	    __slice = [].slice;

	  vm = __webpack_require__(103);

	  exports.allowUnsafeEval = function(fn) {
	    var previousEval;
	    previousEval = global["eval"];
	    try {
	      global["eval"] = function(source) {
	        return vm.runInThisContext(source);
	      };
	      return fn();
	    } finally {
	      global["eval"] = previousEval;
	    }
	  };

	  exports.allowUnsafeNewFunction = function(fn) {
	    var previousFunction;
	    previousFunction = global.Function;
	    try {
	      global.Function = exports.Function;
	      return fn();
	    } finally {
	      global.Function = previousFunction;
	    }
	  };

	  exports.Function = function() {
	    var body, paramList, paramLists, params, _i, _j, _len;
	    paramLists = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), body = arguments[_i++];
	    params = [];
	    for (_j = 0, _len = paramLists.length; _j < _len; _j++) {
	      paramList = paramLists[_j];
	      if (typeof paramList === 'string') {
	        paramList = paramList.split(/\s*,\s*/);
	      }
	      params.push.apply(params, paramList);
	    }
	    return vm.runInThisContext("(function(" + (params.join(', ')) + ") {\n  " + body + "\n})");
	  };

	}).call(this);

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [
		{
			"classes": [
				{
					"name": "GlobalSchema",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "Sys.Referencable",
							"nameSpace": "Sys",
							"basicName": "Referencable",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "Sys.SchemaString",
									"nameSpace": "Sys",
									"basicName": "SchemaString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"fields": [
						{
							"name": "key",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of the global schema, used to refer on schema content"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "value",
							"type": {
								"typeName": "Sys.SchemaString",
								"nameSpace": "Sys",
								"basicName": "SchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Content of the schema"
									]
								},
								{
									"name": "MetaModel.canBeValue",
									"arguments": []
								},
								{
									"name": "MetaModel.value",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"value"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"Content of the schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLSimpleElement",
							"nameSpace": "Common",
							"basicName": "RAMLSimpleElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ImportDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "key",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name prefix (without dot) used to refer imported declarations"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "value",
							"type": {
								"typeName": "Library",
								"nameSpace": "",
								"basicName": "Library",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Content of the declared namespace"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLSimpleElement",
							"nameSpace": "Common",
							"basicName": "RAMLSimpleElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Library",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "schemas",
							"type": {
								"base": {
									"typeName": "GlobalSchema",
									"nameSpace": "",
									"basicName": "GlobalSchema",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Alias for the types property, for compatibility with RAML 0.8. Deprecated - may be removed in a future RAML version."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										""
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"contains description of why library exist"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "annotations",
							"type": {
								"base": {
									"typeName": "Decls.AnnotationRef",
									"nameSpace": "Decls",
									"basicName": "AnnotationRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.version",
									"arguments": [
										"MetaModel.RAMLVersion.RAML10"
									]
								},
								{
									"name": "MetaModel.noDirectParse",
									"arguments": []
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"datamodel.LocationKind.APISTRUCTURE"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"datamodel.ModelLocation.ANNOTATION"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Most of RAML model elements may have attached annotations decribing additional meta data about this element"
									]
								},
								{
									"name": "MetaModel.documentationTableLabel",
									"arguments": [
										"(&lt;annotationName&gt;)"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"A value corresponding to the declared type of this annotation."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "types",
							"type": {
								"base": {
									"typeName": "models.DataElement",
									"nameSpace": "models",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"models.LocationKind.MODELS"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of (data) types for use within this API"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Declarations of (data) types for use within this API. See [[raml-10-spec-types|Types]]."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map type names to type declarations; or an array of such objects"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "traits",
							"type": {
								"base": {
									"typeName": "RM.Trait",
									"nameSpace": "RM",
									"basicName": "Trait",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of traits used in this API"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of traits for use within this API"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Declarations of traits for use within this API. See [[raml-10-spec-resource-types-and-traits|Resource Types and Traits]]."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map trait names to trait declarations; or an array of such objects"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "resourceTypes",
							"type": {
								"base": {
									"typeName": "RM.ResourceType",
									"nameSpace": "RM",
									"basicName": "ResourceType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declaration of resource types used in this API"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of resource types for use within this API"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Declarations of resource types for use within this API. See [[raml-10-spec-resource-types-and-traits|Resource Types and Traits]]."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map resource type names to resource type declarations; or an array of such objects"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "annotationTypes",
							"type": {
								"base": {
									"typeName": "Decls.AnnotationType",
									"nameSpace": "Decls",
									"basicName": "AnnotationType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.version",
									"arguments": [
										"MetaModel.RAMLVersion.RAML10"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of annotation types for use by annotations"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Declarations of annotation types for use by annotations. See [[raml-10-spec-declaring-annotation-types|Annotation Types]]."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map annotation type names to annotation type declarations; or an array of such objects"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securitySchemaTypes",
							"type": {
								"base": {
									"typeName": "RM.SecuritySchemaType",
									"nameSpace": "RM",
									"basicName": "SecuritySchemaType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Security schemas types declarations"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securitySchemes",
							"type": {
								"base": {
									"typeName": "RM.SecuritySchema",
									"nameSpace": "RM",
									"basicName": "SecuritySchema",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Security schemas declarations"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of security schemes for use within this API."
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Declarations of security schemes for use within this API. See [[raml-10-spec-security|Security Schemes]]."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map security scheme names to security scheme declarations; or an array of such objects"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "uses",
							"type": {
								"base": {
									"typeName": "Library",
									"nameSpace": "",
									"basicName": "Library",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Importing libraries"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"decls",
										"true"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An array of libraries"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "OLibrary",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "schemas",
							"type": {
								"base": {
									"typeName": "GlobalSchema",
									"nameSpace": "",
									"basicName": "GlobalSchema",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Alias for the types property, for compatibility with RAML 0.8. Deprecated - may be removed in a future RAML version."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										""
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "types",
							"type": {
								"base": {
									"typeName": "models.DataElement",
									"nameSpace": "models",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"models.LocationKind.MODELS"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of (data) types for use within this API"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Declarations of (data) types for use within this API. See [[raml-10-spec-types|Types]]."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map type names to type declarations; or an array of such objects"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "traits",
							"type": {
								"base": {
									"typeName": "RM.Trait",
									"nameSpace": "RM",
									"basicName": "Trait",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of traits used in this API"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of traits for use within this API"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Declarations of traits for use within this API. See [[raml-10-spec-resource-types-and-traits|Resource Types and Traits]]."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map trait names to trait declarations; or an array of such objects"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "resourceTypes",
							"type": {
								"base": {
									"typeName": "RM.ResourceType",
									"nameSpace": "RM",
									"basicName": "ResourceType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declaration of resource types used in this API"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of resource types for use within this API"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Declarations of resource types for use within this API. See [[raml-10-spec-resource-types-and-traits|Resource Types and Traits]]."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map resource type names to resource type declarations; or an array of such objects"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "annotationTypes",
							"type": {
								"base": {
									"typeName": "Decls.AnnotationType",
									"nameSpace": "Decls",
									"basicName": "AnnotationType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"decls",
										"true"
									]
								},
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.version",
									"arguments": [
										"MetaModel.RAMLVersion.RAML10"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of annotation types for use by annotations"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Declarations of annotation types for use by annotations. See [[raml-10-spec-declaring-annotation-types|Annotation Types]]."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map annotation type names to annotation type declarations; or an array of such objects"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securitySchemaTypes",
							"type": {
								"base": {
									"typeName": "RM.SecuritySchemaType",
									"nameSpace": "RM",
									"basicName": "SecuritySchemaType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Security schemas types declarations"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securitySchemes",
							"type": {
								"base": {
									"typeName": "RM.SecuritySchema",
									"nameSpace": "RM",
									"basicName": "SecuritySchema",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Security schemas declarations"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of security schemes for use within this API."
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Declarations of security schemes for use within this API. See [[raml-10-spec-security|Security Schemes]]."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map security scheme names to security scheme declarations; or an array of such objects"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "uses",
							"type": {
								"base": {
									"typeName": "Library",
									"nameSpace": "",
									"basicName": "Library",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Importing libraries"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"decls",
										"true"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An array of libraries or a single library"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Overlay",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"contains description of why overlay exist"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "masterRef",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Short plain-text label for the API"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Api",
							"nameSpace": "",
							"basicName": "Api",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Extension",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"contains description of why extension exist"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "masterRef",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Short plain-text label for the API"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Api",
							"nameSpace": "",
							"basicName": "Api",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Api",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Short plain-text label for the API"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "version",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The version of the API, e.g. \"v1\""
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "baseUri",
							"type": {
								"typeName": "Sys.FullUriTemplate",
								"nameSpace": "Sys",
								"basicName": "FullUriTemplate",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A URI that's to be used as the base of all the resources' URIs. Often used as the base of the URL of each resource, containing the location of the API. Can be a template URI."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"URI template string"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "baseUriParameters",
							"type": {
								"base": {
									"typeName": "models.DataElement",
									"nameSpace": "models",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"models.ModelLocation.BURI"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"models.LocationKind.APISTRUCTURE"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Named parameters used in the baseUri (template)"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Object whose properties are base URI parameter names"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "protocols",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"HTTP",
											"HTTPS"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The protocols supported by the API"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Array of strings, with each being \"HTTP\" or \"HTTPS\", case-insensitive"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "mediaType",
							"type": {
								"typeName": "Bodies.MimeType",
								"nameSpace": "Bodies",
								"basicName": "MimeType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.oftenKeys",
									"arguments": [
										[
											"application/json",
											"application/xml",
											"application/x-www-form-urlencoded",
											"multipart/formdata"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The default media type to use for request and response bodies (payloads), e.g. \"application/json\""
									]
								},
								{
									"name": "MetaModel.inherited",
									"arguments": []
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Media type string"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "RM.SecuritySchemaRef",
									"nameSpace": "RM",
									"basicName": "SecuritySchemaRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The security schemes that apply to every resource and method in the API"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Array of security scheme names or a single security scheme name"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "resources",
							"type": {
								"base": {
									"typeName": "RM.Resource",
									"nameSpace": "RM",
									"basicName": "Resource",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.documentationTableLabel",
									"arguments": [
										"/&lt;relativeUri&gt;"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Resource"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The resources of the API, identified as relative URIs that begin with a slash (/). Every property whose key begins with a slash (/), and is either at the root of the API definition or is the child property of a resource property, is a resource property, e.g.: /users, /{groupId}, etc"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Object whose properties describe the resource"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "documentation",
							"type": {
								"base": {
									"typeName": "DocumentationItem",
									"nameSpace": "",
									"basicName": "DocumentationItem",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Additional overall documentation for the API"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An array of document objects (or a single document object), each having exactly two string-valued properties: title and content."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "OLibrary",
							"nameSpace": "",
							"basicName": "OLibrary",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"displayName": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						],
						"name": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						],
						"description": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"A longer, human-friendly description of the API"
								]
							}
						],
						"annotations": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Annotations to be applied to this API. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See the [[raml-10-spec-annotations|section on annotations]]."
								]
							}
						],
						"securitySchemaTypes": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						]
					}
				},
				{
					"name": "DocumentationItem",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Title of documentation section"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "content",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Content of documentation section"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"markdown string"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ScriptSpec",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "language",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "content",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ApiDescription",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "apiFiles",
							"type": {
								"base": {
									"typeName": "Api",
									"nameSpace": "",
									"basicName": "Api",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "script",
							"type": {
								"base": {
									"typeName": "ScriptSpec",
									"nameSpace": "",
									"basicName": "ScriptSpec",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"endpoint",
											"callback"
										]
									]
								},
								{
									"name": "MetaModel.descriminatingProperty",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "CallbackAPIDescription",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "callback"
							},
							"optional": false
						},
						{
							"name": "callbackFor",
							"type": {
								"typeName": "Api",
								"nameSpace": "",
								"basicName": "Api",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "ApiDescription",
							"nameSpace": "",
							"basicName": "ApiDescription",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "RAMLProject",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "relatedProjects",
							"type": {
								"base": {
									"typeName": "RAMLProject",
									"nameSpace": "",
									"basicName": "RAMLProject",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "declaredApis",
							"type": {
								"base": {
									"typeName": "ApiDescription",
									"nameSpace": "",
									"basicName": "ApiDescription",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "license",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "overview",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "url",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\raml-labs\\src\\raml1\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts",
				"RM": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts",
				"Decls": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\declarations.ts",
				"Params": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\parameters.ts",
				"Common": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\common.ts",
				"Bodies": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\bodies.ts",
				"models": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
			},
			"name": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
		},
		{
			"classes": [
				{
					"name": "SpecPartMetaData",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [
				{
					"name": "RAMLVersion",
					"members": [
						"RAML08",
						"RAML10"
					]
				}
			],
			"imports": {},
			"name": "c:\\GIT-repos\\raml-labs\\src\\raml1\\metamodel.ts"
		},
		{
			"classes": [
				{
					"name": "ValueType",
					"methods": [
						{
							"name": "parse",
							"start": 69,
							"end": 234,
							"text": "\n    /**\n     * parses inner structure of value type if value type has invalid value you should throw error\n     * with descriptive message\n     */\n    parse():any{}"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "StringType",
					"methods": [
						{
							"name": "value",
							"start": 321,
							"end": 349,
							"text": " value():string{return null}"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"string"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "NumberType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"number"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"integer"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"number"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "BooleanType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"boolean"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"boolean"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Referencable",
					"methods": [],
					"typeParameters": [
						"T"
					],
					"typeParameterConstraint": [
						null
					],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Reference",
					"methods": [],
					"typeParameters": [
						"T"
					],
					"typeParameterConstraint": [
						null
					],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DeclaresDynamicType",
					"methods": [],
					"typeParameters": [
						"T"
					],
					"typeParameterConstraint": [
						null
					],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [
						{
							"typeName": "Referencable",
							"nameSpace": "",
							"basicName": "Referencable",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "T",
									"nameSpace": "",
									"basicName": "T",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "UriTemplate",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This type currently serves both for absolute and relative urls"
							]
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"https://github.com/raml-org/raml-spec/issues/115"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "StatusCode",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ramlexpression",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "RelativeUri",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This  type describes relative uri templates"
							]
						}
					],
					"extends": [
						{
							"typeName": "UriTemplate",
							"nameSpace": "",
							"basicName": "UriTemplate",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "FullUriTemplate",
					"methods": [
						{
							"name": "validate",
							"start": 2412,
							"end": 3342,
							"text": "\n    //parse():string[]{\n    //    var value=this.value();\n    //    var result=[]\n    //    var temp=\"\";\n    //    var inPar=false;\n    //    var count=0;\n    //    for (var a=0;a<value.length;a++){\n    //        var c=value[a];\n    //        if (c=='{'){\n    //            count++;\n    //            inPar=true;\n    //            continue;\n    //        }\n    //        if (c=='}'){\n    //            count--;\n    //            inPar=false;\n    //            result.push(temp);\n    //            temp=\"\";\n    //            continue;\n    //        }\n    //        if (inPar){\n    //            temp+=c;\n    //        }\n    //    }\n    //    if (count>0){\n    //        throw new Error(\"Unmatched '{'\")\n    //    }\n    //    if (count<0){\n    //        throw new Error(\"Unmatched '}'\")\n    //    }\n    //    return result;\n    //}\n\n    validate(){\n        var str=this.value();\n        //write something to validate Url here\n    }"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This  type describes absolute uri templates"
							]
						}
					],
					"extends": [
						{
							"typeName": "UriTemplate",
							"nameSpace": "",
							"basicName": "UriTemplate",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "FixedUri",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This  type describes fixed uris"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ContentType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ValidityExpression",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "MarkdownString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.innerType",
							"arguments": [
								"markdown"
							]
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"https://github.com/raml-org/raml-spec/issues/80"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"Mardown string is a string which can contain markdown as an extension this markdown should support links with RAML Pointers since 1.0"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DateFormatSpec",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "FunctionalInterface",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SchemaString",
					"methods": [
						{
							"name": "validate",
							"start": 4227,
							"end": 4410,
							"text": "\n\n    validate(){\n        var str=this.value();\n        //write something to validate schema here here\n        //in fact it should check that content is valid json or xsd schema\n    }"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Schema at this moment only two subtypes are supported (json schema and xsd)"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ExampleString",
					"methods": [
						{
							"name": "validate",
							"start": 4564,
							"end": 4747,
							"text": "\n\n    validate(){\n        var str=this.value();\n        //write something to validate schema here here\n        //in fact it should check that content is valid json or xsd schema\n    }"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Examples at this moment only two subtypes are supported (json  and xml)"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "JSonSchemaString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.innerType",
							"arguments": [
								"json"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"JSON schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "SchemaString",
							"nameSpace": "",
							"basicName": "SchemaString",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "XMLSchemaString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.innerType",
							"arguments": [
								"xsd"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"XSD schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "SchemaString",
							"nameSpace": "",
							"basicName": "SchemaString",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ScriptingHook",
					"methods": [],
					"typeParameters": [
						"T"
					],
					"typeParameterConstraint": [
						null
					],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"script to inject to tooling environment"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "RAMLPointer",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "RAMLSelector",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\raml-labs\\src\\raml1\\metamodel.ts"
			},
			"name": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
		},
		{
			"classes": [
				{
					"name": "ResourceTypeRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Sys.Reference",
							"nameSpace": "Sys",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "ResourceType",
									"nameSpace": "",
									"basicName": "ResourceType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "TraitRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Sys.Reference",
							"nameSpace": "Sys",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "Trait",
									"nameSpace": "",
									"basicName": "Trait",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchemaPart",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "MethodBase",
							"nameSpace": "",
							"basicName": "MethodBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"headers": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Optional array of headers, documenting the possible headers that could be accepted. See [[raml-10-spec-headers|Headers]] section."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Object whose property names are the request header names and whose values describe the values."
								]
							}
						],
						"queryParameters": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Query parameters, used by the schema in order to authorize the request. Mutually exclusive with queryString. See [[raml-10-spec-query-parameters-in-a-query-string|Query Parameters]] section."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Object whose property names are the query parameter names and whose values describe the values."
								]
							}
						],
						"queryString": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Specifies the query string, used by the schema in order to authorize the request. Mutually exclusive with queryParameters."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Type name or type declaration"
								]
							}
						],
						"responses": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Optional array of responses, describing the possible responses that could be sent. See [[raml-10-spec-responses|Responses]] section."
								]
							}
						],
						"is": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						],
						"securedBy": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						],
						"displayName": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"An alternate, human-friendly name for the security scheme part"
								]
							}
						],
						"description": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"A longer, human-friendly description of the security scheme part"
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Markdown string"
								]
							}
						],
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Annotations to be applied to this security scheme part. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See [[raml-10-spec-annotations|the section on annotations]]."
								]
							}
						]
					}
				},
				{
					"name": "SecuritySchemaHook",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "parameters",
							"type": {
								"base": {
									"typeName": "models.DataElement",
									"nameSpace": "models",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "script",
							"type": {
								"typeName": "SecuritySchemaHookScript",
								"nameSpace": "",
								"basicName": "SecuritySchemaHookScript",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Allows customization of security schemeas"
							]
						}
					],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchemaHookScript",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Sys.ScriptingHook",
							"nameSpace": "Sys",
							"basicName": "ScriptingHook",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "auth.SecuritySchemeHook",
									"nameSpace": "auth",
									"basicName": "SecuritySchemeHook",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchemaType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "requiredSettings",
							"type": {
								"base": {
									"typeName": "models.DataElement",
									"nameSpace": "models",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"You may declare settings needed to use this type of security security schemas"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"models.LocationKind.DECLARATIONS"
									]
								},
								{
									"name": "MetaModel.declaringFields",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "describedBy",
							"type": {
								"typeName": "SecuritySchemaPart",
								"nameSpace": "",
								"basicName": "SecuritySchemaPart",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The describedBy attribute MAY be used to apply a trait-like structure to a security scheme mechanism so as to extend the mechanism, such as specifying response codes, HTTP headers or custom documentation.\n        This extension allows API designers to describe security schemes. As a best practice, even for standard security schemes, API designers SHOULD describe the security schemes' required artifacts, such as headers, URI parameters, and so on. Including the security schemes' description completes an API's documentation."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"SecuritySchemaSettings"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"Security schema type allows you to contribute your own security schema type with settings and optinal configurator for plugging into client sdks auth mechanism"
							]
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchemaSettings",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.issue",
							"arguments": [
								"Specification is actually very vague here"
							]
						},
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"$parent.type"
							]
						}
					],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "OAuth1SecuritySchemeSettings",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "requestTokenUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Temporary Credential Request endpoint as defined in RFC5849 Section 2.1"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"FixedUri"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "authorizationUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Resource Owner Authorization endpoint as defined in RFC5849 Section 2.2"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"FixedUri"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "tokenCredentialsUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Token Request endpoint as defined in RFC5849 Section 2.3"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"FixedUri"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "signatures",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"HMAC-SHA1",
											"RSA-SHA1",
											"PLAINTEXT"
										]
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"$parent.type=='OAuth 1.0'"
							]
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"Specification is actually very vague here"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchemaSettings",
							"nameSpace": "",
							"basicName": "SecuritySchemaSettings",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"displayName": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						],
						"description": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						],
						"annotations": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						],
						"authentificationConfigurator": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						]
					}
				},
				{
					"name": "OAuth2SecuritySchemeSettings",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "accessTokenUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Token Endpoint as defined in RFC6749 [RFC6748] Section 3.2. Not required forby implicit grant type."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"FixedUri"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "authorizationUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Authorization Endpoint as defined in RFC6749 [RFC6748] Section 3.1. Required forby authorization_code and implicit grant types."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"FixedUri"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "authorizationGrants",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"A list of the Authorization grants supported by the API as defined in RFC6749 [RFC6749] Sections 4.1, 4.2, 4.3 and 4.4, can be any of:<br>* authorization_code<br>* password<br>* client_credentials<br>* implicit<br>* refresh_token."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "scopes",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A list of scopes supported by the security scheme as defined in RFC6749 [RFC6749] Section 3.3"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"$parent.type=='OAuth 2.0'"
							]
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"Specification is actually very vague here"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchemaSettings",
							"nameSpace": "",
							"basicName": "SecuritySchemaSettings",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"displayName": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						],
						"description": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						],
						"annotations": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						],
						"authentificationConfigurator": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						]
					}
				},
				{
					"name": "PassThroughSettings",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "queryParameterName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "headerName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"$parent.type=='PassThrough'"
							]
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"Specification is actually very vague here"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchemaSettings",
							"nameSpace": "",
							"basicName": "SecuritySchemaSettings",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchemaRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Sys.Reference",
							"nameSpace": "Sys",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "SecuritySchema",
									"nameSpace": "",
									"basicName": "SecuritySchema",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchema",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "Sys.Referencable",
							"nameSpace": "Sys",
							"basicName": "Referencable",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "SecuritySchema",
									"nameSpace": "",
									"basicName": "SecuritySchema",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.startFrom",
									"arguments": [
										""
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"OAuth 1.0",
											"OAuth 2.0",
											"Basic Authentication",
											"Digest Authentication",
											"Pass Through",
											"x-{other}"
										]
									]
								},
								{
									"name": "MetaModel.descriminatingProperty",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The securitySchemes property MUST be used to specify an API's security mechanisms, including the required settings and the authentication methods that the API supports. one authentication method is allowed if the API supports them."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"string<br><br>The value MUST be one of<br>* OAuth 1.0,<br>* OAuth 2.0,<br>* Basic Authentication<br>* Digest Authentication<br>* Pass Through<br>* x-&lt;other&gt;"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The description attribute MAY be used to describe a security schemes property."
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The description MAY be used to describe a securityScheme."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "describedBy",
							"type": {
								"typeName": "SecuritySchemaPart",
								"nameSpace": "",
								"basicName": "SecuritySchemaPart",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A description of the request components related to Security that are determined by the scheme: the headers, query parameters or responses. As a best practice, even for standard security schemes, API designers SHOULD describe these properties of security schemes.\nIncluding the security scheme description completes an API documentation."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "settings",
							"type": {
								"typeName": "SecuritySchemaSettings",
								"nameSpace": "",
								"basicName": "SecuritySchemaSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The settings attribute MAY be used to provide security scheme-specific information. The required attributes vary depending on the type of security scheme is being declared.\nIt describes the minimum set of properties which any processing application MUST provide and validate if it chooses to implement the security scheme. Processing applications MAY choose to recognize other properties for things such as token lifetime, preferred cryptographic algorithms, and more."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Oath2",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "OAuth 2.0"
							},
							"optional": false
						},
						{
							"name": "settings",
							"type": {
								"typeName": "OAuth2SecuritySchemeSettings",
								"nameSpace": "",
								"basicName": "OAuth2SecuritySchemeSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchema",
							"nameSpace": "",
							"basicName": "SecuritySchema",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Oath1",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "OAuth 1.0"
							},
							"optional": false
						},
						{
							"name": "settings",
							"type": {
								"typeName": "OAuth1SecuritySchemeSettings",
								"nameSpace": "",
								"basicName": "OAuth1SecuritySchemeSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchema",
							"nameSpace": "",
							"basicName": "SecuritySchema",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "PassThrough",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "PassThrough"
							},
							"optional": false
						},
						{
							"name": "settings",
							"type": {
								"typeName": "PassThroughSettings",
								"nameSpace": "",
								"basicName": "PassThroughSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchema",
							"nameSpace": "",
							"basicName": "SecuritySchema",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Basic",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "Basic Authentication"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchema",
							"nameSpace": "",
							"basicName": "SecuritySchema",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Digest",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "Digest Authentication"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchema",
							"nameSpace": "",
							"basicName": "SecuritySchema",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Custom",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "x-{other}"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchema",
							"nameSpace": "",
							"basicName": "SecuritySchema",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "MethodBase",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "responses",
							"type": {
								"base": {
									"typeName": "Bodies.Response",
									"nameSpace": "Bodies",
									"basicName": "Response",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"response",
										"true"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Response"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Information about the expected responses to a request"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose keys are the HTTP status codes of the responses and whose values describe the responses."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "body",
							"type": {
								"base": {
									"typeName": "models.DataElement",
									"nameSpace": "models",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Body"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Some method verbs expect the resource to be sent as a request body. For example, to create a resource, the request must include the details of the resource to create.\nResources CAN have alternate representations. For example, an API might support both JSON and XML representations.\nA method's body is defined in the body property as a hashmap, in which the key MUST be a valid media type."
									]
								},
								{
									"name": "MetaModel.needsClarification",
									"arguments": [
										"Ensure that forms spec is consistent with it"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "protocols",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"HTTP",
											"HTTPS"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A method can override the protocols specified in the resource or at the API root, by employing this property."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"array of strings of value HTTP or HTTPS, or a single string of such kind, case-insensitive"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "is",
							"type": {
								"base": {
									"typeName": "TraitRef",
									"nameSpace": "",
									"basicName": "TraitRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instantiation of applyed traits"
									]
								},
								{
									"name": "MetaModel.thisFeatureCovers",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/98"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "SecuritySchemaRef",
									"nameSpace": "",
									"basicName": "SecuritySchemaRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.allowNull",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										" securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.\nTo indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Params.HasNormalParameters",
							"nameSpace": "Params",
							"basicName": "HasNormalParameters",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Trait",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "Sys.DeclaresDynamicType",
							"nameSpace": "Sys",
							"basicName": "DeclaresDynamicType",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "Trait",
									"nameSpace": "",
									"basicName": "Trait",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of the trait"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "uses",
							"type": {
								"base": {
									"typeName": "api.Library",
									"nameSpace": "api",
									"basicName": "Library",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"You may import library locally here it contents is accessible only inside of this trait"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"decls",
										"true"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An array of libraries or a single library"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.inlinedTemplates",
							"arguments": []
						},
						{
							"name": "MetaModel.allowQuestion",
							"arguments": []
						}
					],
					"extends": [
						{
							"typeName": "MethodBase",
							"nameSpace": "",
							"basicName": "MethodBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ResourceBase",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "methods",
							"type": {
								"base": {
									"typeName": "Method",
									"nameSpace": "",
									"basicName": "Method",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Methods that are part of this resource type definition"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"The methods available on this resource. See [[raml-10-spec-methods|the section on method properties]]."
									]
								},
								{
									"name": "MetaModel.documentationTableLabel",
									"arguments": [
										"get?<br>patch?<br>put?<br>post?<br>delete?<br>options?<br>head?"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Object describing the method"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "is",
							"type": {
								"base": {
									"typeName": "TraitRef",
									"nameSpace": "",
									"basicName": "TraitRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A list of the traits to apply to all methods declared (implicitly or explicitly) for this resource. See [[raml-10-spec-applying-resource-types-and-traits|Applying Resource Types and Traits]] section. Individual methods may override this declaration"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"array, which can contain each of the following elements:<br>* name of unparametrized trait<br>* a key-value pair with trait name as key and a map of trait parameters as value<br>* inline trait declaration<br><br>(or a single element of any above kind)"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "ResourceTypeRef",
								"nameSpace": "",
								"basicName": "ResourceTypeRef",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The resource type which this resource inherits. . See [[raml-10-spec-applying-resource-types-and-traits|Applying Resource Types and Traits]] section."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"one of the following elements:<br>* name of unparametrized resource type<br>* a key-value pair with resource type name as key and a map of its parameters as value<br>* inline resource type declaration"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "SecuritySchemaRef",
									"nameSpace": "",
									"basicName": "SecuritySchemaRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.allowNull",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The security schemes that apply to all methods declared (implicitly or explicitly) for this resource."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"array of security scheme names or a single security scheme name"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "uriParameters",
							"type": {
								"base": {
									"typeName": "models.DataElement",
									"nameSpace": "models",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"models.ModelLocation.URI"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"models.LocationKind.APISTRUCTURE"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.valueRestriction",
									"arguments": [
										"_.find(<br>&nbsp;&nbsp;relativeUri.templateArguments(),<br>&nbsp;&nbsp;$value.name)",
										"Uri parameter names should match to template names in relative uri"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Detailed information about any URI parameters of this resource"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"object whose property names are the URI parameter names and whose values describe the values"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ResourceType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "Sys.DeclaresDynamicType",
							"nameSpace": "Sys",
							"basicName": "DeclaresDynamicType",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "ResourceType",
									"nameSpace": "",
									"basicName": "ResourceType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of the resource type"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "uses",
							"type": {
								"base": {
									"typeName": "api.Library",
									"nameSpace": "api",
									"basicName": "Library",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"You may import library locally here it contents is accessible only inside of this resource type"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"decls",
										"true"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An array of libraries"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.inlinedTemplates",
							"arguments": []
						},
						{
							"name": "MetaModel.allowQuestion",
							"arguments": []
						}
					],
					"extends": [
						{
							"typeName": "ResourceBase",
							"nameSpace": "",
							"basicName": "ResourceBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ResourceTypeOrTrait",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instructions on how and when to use this resource type in a RAML spec"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Markdown string"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "uses",
							"type": {
								"base": {
									"typeName": "api.Library",
									"nameSpace": "api",
									"basicName": "Library",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"You may import library locally here it contents is accessible only inside of this trait"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An array of libraries"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "parameters",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Optional declaration of the parameters that the resource type employs."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose property names are the parameter names and whose property values describe the parameter data types."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Method",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "signature",
							"type": {
								"typeName": "Sys.SchemaString",
								"nameSpace": "Sys",
								"basicName": "SchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.canBeValue",
									"arguments": []
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "method",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.extraMetaKey",
									"arguments": [
										"methods"
									]
								},
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"get",
											"put",
											"post",
											"delete",
											"options",
											"head",
											"patch"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Method that can be called"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "MethodBase",
							"nameSpace": "",
							"basicName": "MethodBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"displayName": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"An alternate, human-friendly name for the method (in the resource's context)."
								]
							}
						],
						"description": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"A longer, human-friendly description of the method (in the resource's context)"
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Markdown string"
								]
							}
						],
						"queryString": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Specifies the query string needed by this method. Mutually exclusive with queryParameters."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Type name or type declaration"
								]
							}
						],
						"queryParameters": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Detailed information about any query parameters needed by this method. Mutually exclusive with queryString."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Object whose property names are the query parameter names and whose values describe the values."
								]
							}
						],
						"headers": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Detailed information about any request headers needed by this method."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Object whose property names are the request header names and whose values describe the values."
								]
							}
						],
						"body": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Some methods admit request bodies, which are described by this property."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Object whose properties are either<br>1) media types and whose values are type objects describing the request body for that media type, or<br>2) a type object describing the request body for the default media type specified in the root mediaType property"
								]
							}
						],
						"is": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"A list of the traits to apply to this method. See [[raml-10-spec-applying-resource-types-and-traits|Applying Resource Types and Traits]] section."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"array, which can contain each of the following elements:<br>* name of unparametrized trait<br>* a key-value pair with trait name as key and a map of trait parameters as value<br>* inline trait declaration<br><br>(or a single element of any above kind)"
								]
							}
						],
						"annotations": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Annotations to be applied to this method. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See the [[raml-10-spec-annotations|section on annotations]]."
								]
							}
						],
						"securedBy": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"The security schemes that apply to this method"
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Array of security scheme names or a  single security scheme name"
								]
							}
						]
					}
				},
				{
					"name": "Resource",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "signature",
							"type": {
								"typeName": "Sys.SchemaString",
								"nameSpace": "Sys",
								"basicName": "SchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.canBeValue",
									"arguments": []
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "relativeUri",
							"type": {
								"typeName": "Sys.RelativeUri",
								"nameSpace": "Sys",
								"basicName": "RelativeUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.grammarTokenKind",
									"arguments": [
										"entity.name.tag.yaml"
									]
								},
								{
									"name": "MetaModel.startFrom",
									"arguments": [
										"/"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Relative URL of this resource from the parent resource"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "resources",
							"type": {
								"base": {
									"typeName": "Resource",
									"nameSpace": "",
									"basicName": "Resource",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Resource"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A nested resource is identified as any property whose name begins with a slash (\"/\") and is therefore treated as a relative URI."
									]
								},
								{
									"name": "MetaModel.documentationTableLabel",
									"arguments": [
										"/&lt;relativeUri&gt;"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"object describing the nested resource"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "ResourceBase",
							"nameSpace": "",
							"basicName": "ResourceBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"displayName": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"An alternate, human-friendly name for the resource."
								]
							}
						],
						"description": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"A longer, human-friendly description of the resource."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Markdown string"
								]
							}
						],
						"annotations": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Annotations to be applied to this resource. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See the [[raml-10-spec-annotations|section on annotations]]."
								]
							}
						]
					}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\raml-labs\\src\\raml1\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts",
				"Params": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\parameters.ts",
				"Bodies": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\bodies.ts",
				"Common": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\common.ts",
				"Declarations": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\declarations.ts",
				"models": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts",
				"auth": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\auth.ts",
				"api": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\api.ts"
			},
			"name": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
		},
		{
			"classes": [
				{
					"name": "FileParameter",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "file"
							},
							"optional": false
						},
						{
							"name": "fileTypes",
							"type": {
								"base": {
									"typeName": "Sys.ContentType",
									"nameSpace": "Sys",
									"basicName": "ContentType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\parameters.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"It should also include a new property: fileTypes, which should be a list of valid content-type strings for the file. The file type */* should be a valid value."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "minLength",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The minLength attribute specifies the parameter value's minimum number of bytes."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "maxLength",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The maxLength attribute specifies the parameter value's maximum number of bytes."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.thisFeatureCovers",
							"arguments": [
								"https://github.com/raml-org/raml-spec/issues/94"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"(Applicable only to Form properties) Value is a file. Client generators SHOULD use this type to handle file uploads correctly."
							]
						}
					],
					"extends": [
						{
							"typeName": "datamodel.DataElement",
							"nameSpace": "datamodel",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "HasNormalParameters",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "queryParameters",
							"type": {
								"base": {
									"typeName": "datamodel.DataElement",
									"nameSpace": "datamodel",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\parameters.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/78"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"datamodel.ModelLocation.QUERY"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"datamodel.LocationKind.APISTRUCTURE"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New query parameter"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"An APIs resources MAY be filtered (to return a subset of results) or altered (such as transforming a response body from JSON to XML format) by the use of query strings. If the resource or its method supports a query string, the query string MUST be defined by the queryParameters property"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "headers",
							"type": {
								"base": {
									"typeName": "datamodel.DataElement",
									"nameSpace": "datamodel",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\parameters.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/59"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"datamodel.ModelLocation.HEADERS"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"datamodel.LocationKind.APISTRUCTURE"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Headers that allowed at this position"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Header"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"It is not clear if this also allowed for resources(check)"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"cover wildcards ({*})"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "queryString",
							"type": {
								"typeName": "datamodel.DataElement",
								"nameSpace": "datamodel",
								"basicName": "DataElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\parameters.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\raml-labs\\src\\raml1\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts",
				"Common": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\common.ts",
				"datamodel": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
			},
			"name": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\parameters.ts"
		},
		{
			"classes": [
				{
					"name": "RAMLLanguageElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "displayName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The displayName attribute specifies the $self's display name. It is a friendly name used only for display or documentation purposes. If displayName is not specified, it defaults to the element's key (the name of the property itself)."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\common.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The description attribute describes the intended use or meaning of the $self. This value MAY be formatted using Markdown [MARKDOWN]"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Markdown string"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "annotations",
							"type": {
								"base": {
									"typeName": "Decls.AnnotationRef",
									"nameSpace": "Decls",
									"basicName": "AnnotationRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\common.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.version",
									"arguments": [
										"MetaModel.RAMLVersion.RAML10"
									]
								},
								{
									"name": "MetaModel.noDirectParse",
									"arguments": []
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"datamodel.LocationKind.APISTRUCTURE"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"datamodel.ModelLocation.ANNOTATION"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Most of RAML model elements may have attached annotations decribing additional meta data about this element"
									]
								},
								{
									"name": "MetaModel.documentationTableLabel",
									"arguments": [
										"(&lt;annotationName&gt;)"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"A value corresponding to the declared type of this annotation."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "RAMLSimpleElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\raml-labs\\src\\raml1\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts",
				"Decls": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\declarations.ts"
			},
			"name": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\common.ts"
		},
		{
			"classes": [
				{
					"name": "AnnotationType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "Sys.DeclaresDynamicType",
							"nameSpace": "Sys",
							"basicName": "DeclaresDynamicType",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "AnnotationType",
									"nameSpace": "",
									"basicName": "AnnotationType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\declarations.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\declarations.ts"
						}
					],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of this annotation type"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instructions on how and when to use this annotation in a RAML spec."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Markdown string"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "properties",
							"type": {
								"base": {
									"typeName": "datamodel.DataElement",
									"nameSpace": "datamodel",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\declarations.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.declaringFields",
									"arguments": []
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"datamodel.LocationKind.APISTRUCTURE"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"datamodel.ModelLocation.ANNOTATION"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of parameters allowed in this annotation type"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose property names are the parameter names the annotation expects and whose values are their data types."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "allowMultiple",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.declaringFields",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Whether multiple instances of annotations of this type may be applied simultaneously at the same location"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "allowedTargets",
							"type": {
								"base": {
									"typeName": "AnnotationTarget",
									"nameSpace": "",
									"basicName": "AnnotationTarget",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\declarations.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.extraMetaKey",
									"arguments": [
										"annotationTargets"
									]
								},
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"API",
											"DocumentationItem",
											"Resource",
											"Method",
											"Response",
											"RequestBody",
											"ResponseBody",
											"DataElement",
											"NamedExample",
											"ResourceType",
											"Trait",
											"SecurityScheme",
											"SecuritySchemeSettings",
											"AnnotationType",
											"Library",
											"Overlay",
											"Extension"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Restrictions on where annotations of this type can be applied. If this property is specified, annotations of this type may only be applied on a property corresponding to one of the target names specified as the value of this property."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An array of names (or a single name) from the list of Target Names in the [[raml-10-spec-target-locations-table|Target Locations table]]  below. "
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"Annotation"
							]
						},
						{
							"name": "MetaModel.thisFeatureCovers",
							"arguments": [
								"https://github.com/raml-org/raml-spec/issues/147"
							]
						}
					],
					"extends": [
						{
							"typeName": "common.RAMLLanguageElement",
							"nameSpace": "common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\declarations.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"displayName": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"An alternate, human-friendly name for the annotation"
								]
							}
						],
						"description": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"A longer, human-friendly description of the annotation"
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Markdown string"
								]
							}
						]
					}
				},
				{
					"name": "AnnotationRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Instantiation of annotations. It allows you to attach some meta information to your API"
							]
						}
					],
					"extends": [
						{
							"typeName": "Sys.Reference",
							"nameSpace": "Sys",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "AnnotationType",
									"nameSpace": "",
									"basicName": "AnnotationType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\declarations.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\declarations.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "AnnotationTarget",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Sys.ValueType",
							"nameSpace": "Sys",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\declarations.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Annotation",
					"methods": [],
					"typeParameters": [
						"T"
					],
					"typeParameterConstraint": [
						null
					],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\raml-labs\\src\\raml1\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts",
				"datamodel": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts",
				"common": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\common.ts"
			},
			"name": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\declarations.ts"
		},
		{
			"classes": [
				{
					"name": "ExampleSpec",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "content",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.selfNode",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The example itself"
									]
								},
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"* Valid value for this type<br>* String representing the serialized version of a valid value"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "strict",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"By default, examples are validated against any type declaration. Set this to false to allow examples that need not validate."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"displayName": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"An alternate, human-friendly name for the example"
								]
							}
						],
						"description": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"A longer, human-friendly description of the example"
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"markdown string"
								]
							}
						],
						"annotations": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Annotations to be applied to this example. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See the [[raml-10-spec-annotations|section on annotations]]."
								]
							}
						]
					}
				},
				{
					"name": "DataElementProperty",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"name of the parameter"
									]
								},
								{
									"name": "MetaModel.extraMetaKey",
									"arguments": [
										"headers"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "location",
							"type": {
								"typeName": "ModelLocation",
								"nameSpace": "",
								"basicName": "ModelLocation",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.system",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Location of the parameter (can not be edited by user)"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "locationKind",
							"type": {
								"typeName": "LocationKind",
								"nameSpace": "",
								"basicName": "LocationKind",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.system",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Kind of location"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "default",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Provides default value for a property"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"any"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "required",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.requireValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Sets if property is optional or not"
									]
								},
								{
									"name": "MetaModel.describesAnnotation",
									"arguments": [
										"required"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"boolean = true"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DataElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"name of the parameter"
									]
								},
								{
									"name": "MetaModel.extraMetaKey",
									"arguments": [
										"headers"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "xml",
							"type": {
								"typeName": "XMLInfo",
								"nameSpace": "",
								"basicName": "XMLInfo",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "facets",
							"type": {
								"base": {
									"typeName": "DataElement",
									"nameSpace": "",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.declaringFields",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"When extending from a type you can define new facets (which can then be set to concrete values by subtypes)."
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "schema",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Alias for the type property, for compatibility with RAML 0.8. Deprecated - may be removed in a future RAML version."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Single string denoting the base type or type expression"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.allowMultiple",
									"arguments": []
								},
								{
									"name": "MetaModel.canBeValue",
									"arguments": []
								},
								{
									"name": "MetaModel.defaultValue",
									"arguments": [
										"string"
									]
								},
								{
									"name": "MetaModel.descriminatingProperty",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A base type which the current type extends, or more generally a type expression."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"string denoting the base type or type expression"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "location",
							"type": {
								"typeName": "ModelLocation",
								"nameSpace": "",
								"basicName": "ModelLocation",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.system",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Location of the parameter (can not be edited by user)"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "locationKind",
							"type": {
								"typeName": "LocationKind",
								"nameSpace": "",
								"basicName": "LocationKind",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.system",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Kind of location"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "default",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Provides default value for a property"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "example",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.selfNode",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"An example of an instance of this type. This can be used, e.g., by documentation generators to generate sample values for an object of this type. Cannot be present if the examples property is present."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"* Valid value for this type<br>* String representing the serialized version of a valid value"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "examples",
							"type": {
								"base": {
									"typeName": "ExampleSpec",
									"nameSpace": "",
									"basicName": "ExampleSpec",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"An object containing named examples of instances of this type. This can be used, e.g., by documentation generators to generate sample values for an object of this type. Cannot be present if the examples property is present."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map example names to Example objects (see [[raml-10-spec-examples|Examples]] section); or an array of Example objects."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "repeat",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.requireValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The repeat attribute specifies that the parameter can be repeated. If the parameter can be used multiple times, the repeat parameter value MUST be set to 'true'. Otherwise, the default value is 'false' and the parameter may not be repeated."
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "required",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.requireValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Sets if property is optional or not"
									]
								},
								{
									"name": "MetaModel.describesAnnotation",
									"arguments": [
										"required"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.convertsToGlobalOfType",
							"arguments": [
								"SchemaString"
							]
						},
						{
							"name": "MetaModel.canInherit",
							"arguments": [
								"mediaType"
							]
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"displayName": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"An alternate, human-friendly name for the type"
								]
							}
						],
						"description": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"A longer, human-friendly description of the type"
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"markdown string"
								]
							}
						],
						"annotations": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Annotations to be applied to this type. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See the [[raml-10-spec-annotations|section on annotations]]."
								]
							}
						]
					}
				},
				{
					"name": "ScalarElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "facets",
							"type": {
								"base": {
									"typeName": "DataElement",
									"nameSpace": "",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.declaringFields",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"When extending from a scalar type you can define new facets (which can then be set to concrete values by subtypes)."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map facets names to their types."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "enum",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.describesAnnotation",
									"arguments": [
										"oneOf"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Enumeration of possible values for this primitive type. Cannot be used with the file type."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Array containing string representations of possible values, or a single string if there is only one possible value."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "XMLInfo",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "namespace",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "prefix",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "attribute",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "wrapped",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ArrayField",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "array"
							},
							"optional": false
						},
						{
							"name": "uniqueItems",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"uniqueItems"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Should items in array be unique"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "items",
							"type": {
								"typeName": "DataElement",
								"nameSpace": "",
								"basicName": "DataElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Array component type."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Inline type declaration or type name."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "minItems",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"minItems"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Minimum amount of items in array"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"integer ( >= 0 ). Defaults to 0"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "maxItems",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"maxItems"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Maximum amount of items in array"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"integer ( >= 0 ). Defaults to undefined."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.convertsToGlobalOfType",
							"arguments": [
								"SchemaString"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"array"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"DataElement"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "UnionField",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "discriminator",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.selector",
									"arguments": [
										"*.DataElement"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "union"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.convertsToGlobalOfType",
							"arguments": [
								"SchemaString"
							]
						},
						{
							"name": "MetaModel.requireValue",
							"arguments": [
								"locationKind",
								"LocationKind.MODELS"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"DataElement"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DataElementRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Sys.Reference",
							"nameSpace": "Sys",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "DataElement",
									"nameSpace": "",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ObjectField",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "properties",
							"type": {
								"base": {
									"typeName": "DataElement",
									"nameSpace": "",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The properties that instances of this type may or must have."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose keys are the properties' names and whose values are property declarations."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "minProperties",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"minProperties"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The minimum number of properties allowed for instances of this type."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "maxProperties",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"maxProperties"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The maximum number of properties allowed for instances of this type."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "additionalProperties",
							"type": {
								"typeName": "DataElement",
								"nameSpace": "",
								"basicName": "DataElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"JSON schema style syntax for declaring maps"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"JSON schema style syntax for declaring maps. See [[raml-10-spec-map-types|Map Types]]."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Inline type declaration or typename"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "patternProperties",
							"type": {
								"base": {
									"typeName": "DataElement",
									"nameSpace": "",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"JSON schema style syntax for declaring key restricted maps"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"JSON schema style syntax for declaring key restricted maps. See [[raml-10-spec-map-types|Map Types]]."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map regular expressions (which are regarded as defining ranges for property names) to types of properties expressed as Inline type declaration or typename."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "discriminator",
							"type": {
								"typeName": "pointer",
								"nameSpace": "",
								"basicName": "pointer",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.selector",
									"arguments": [
										"*.DataElement"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "discriminatorValue",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": null,
							"annotations": [
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "object"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.definingPropertyIsEnough",
							"arguments": [
								"properties"
							]
						},
						{
							"name": "MetaModel.setsContextValue",
							"arguments": [
								"field",
								"true"
							]
						},
						{
							"name": "MetaModel.convertsToGlobalOfType",
							"arguments": [
								"SchemaString"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"DataElement"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "StrElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "pattern",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"pattern"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Regular expression that this string should path"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"regexp"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "minLength",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"minLength"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Minimum length of the string"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "maxLength",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"maxLength"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Maximum length of the string"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "string"
							},
							"optional": false
						},
						{
							"name": "enum",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.thisFeatureCovers",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/82"
									]
								},
								{
									"name": "MetaModel.describesAnnotation",
									"arguments": [
										"oneOf"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error."
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value must be a string"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"DataElement"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "BooleanElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "boolean"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value must be a boolean"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"DataElement"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ValueElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "value"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value must be a boolean"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"DataElement"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "NumberElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "number"
							},
							"optional": false
						},
						{
							"name": "minimum",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"minimum"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type number or integer) The minimum attribute specifies the parameter's minimum value."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "maximum",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"maximum"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type number or integer) The maximum attribute specifies the parameter's maximum value."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "enum",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.thisFeatureCovers",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/82"
									]
								},
								{
									"name": "MetaModel.describesAnnotation",
									"arguments": [
										"oneOf"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error."
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "format",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"int32",
											"int64",
											"int",
											"long",
											"float",
											"double",
											"int16",
											"int8"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Value format"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "multipleOf",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A numeric instance is valid against \"multipleOf\" if the result of the division of the instance by this keyword's value is an integer."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value MUST be a number. Indicate floating point numbers as defined by YAML."
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"DataElement"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "IntegerElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "integer"
							},
							"optional": false
						},
						{
							"name": "format",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"int32",
											"int64",
											"int",
											"long",
											"int16",
											"int8"
										]
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value MUST be a integer."
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"DataElement"
							]
						}
					],
					"extends": [
						{
							"typeName": "NumberElement",
							"nameSpace": "",
							"basicName": "NumberElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "RAMLPointerElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "pointer"
							},
							"optional": false
						},
						{
							"name": "target",
							"type": {
								"typeName": "Sys.RAMLSelector",
								"nameSpace": "Sys",
								"basicName": "RAMLSelector",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.requireValue",
							"arguments": [
								"locationKind",
								"LocationKind.APISTRUCTURE"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "pointer",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Sys.ValueType",
							"nameSpace": "Sys",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "RAMLExpression",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "ramlexpression"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.requireValue",
							"arguments": [
								"locationKind",
								"LocationKind.APISTRUCTURE"
							]
						},
						{
							"name": "MetaModel.requireValue",
							"arguments": [
								"location",
								"ModelLocation.ANNOTATION"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ScriptHookElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "script"
							},
							"optional": false
						},
						{
							"name": "declaredIn",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Typescript file defining interface which this scrip should comply to"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "interfaceName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of the interface which scripts should comply to"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.requireValue",
							"arguments": [
								"locationKind",
								"LocationKind.APISTRUCTURE"
							]
						},
						{
							"name": "MetaModel.requireValue",
							"arguments": [
								"location",
								"ModelLocation.ANNOTATION"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SchemaElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "schema"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.requireValue",
							"arguments": [
								"locationKind",
								"LocationKind.APISTRUCTURE"
							]
						},
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"SchemaString"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DateElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "date"
							},
							"optional": false
						},
						{
							"name": "dateFormat",
							"type": {
								"typeName": "Sys.DateFormatSpec",
								"nameSpace": "Sys",
								"basicName": "DateFormatSpec",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.thisFeatureCovers",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/105"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value MUST be a string representation of a date as defined in RFC2616 Section 3.3 [RFC2616]. or according to specified date format"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"DataElement"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [
				{
					"name": "ModelLocation",
					"members": [
						"QUERY",
						"HEADERS",
						"URI",
						"FORM",
						"BURI",
						"ANNOTATION",
						"MODEL",
						"SECURITYSCHEMATYPE"
					]
				},
				{
					"name": "LocationKind",
					"members": [
						"APISTRUCTURE",
						"DECLARATIONS",
						"MODELS"
					]
				}
			],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\raml-labs\\src\\raml1\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts",
				"Bodies": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\bodies.ts",
				"Common": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\common.ts",
				"Declarations": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\declarations.ts"
			},
			"name": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts"
		},
		{
			"classes": [
				{
					"name": "MimeTypeModel",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "tree",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": true
						},
						{
							"name": "subtype",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "suffix",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": true
						},
						{
							"name": "parameters",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": true
						}
					],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "MimeType",
					"methods": [
						{
							"name": "isForm",
							"start": 383,
							"end": 608,
							"text": "\n    isForm(){\n        if (this.value()==\"application/x-www-form-urlencoded\"||this.value()=='multipart/form-data'){\n            return true;\n        }\n        //TODO USE PARSE\n        return false;//more smart code here\n    }"
						},
						{
							"name": "isXML",
							"start": 608,
							"end": 779,
							"text": "\n\n    isXML(){\n        //TODO USE PARSE\n\n        if (this.value()==\"application/xml\"){\n            return true;\n        }\n        return false;//more smart code here\n    }"
						},
						{
							"name": "isJSON",
							"start": 779,
							"end": 952,
							"text": "\n\n    isJSON(){\n        //TODO USE PARSE\n\n        if (this.value()==\"application/json\"){\n            return true;\n        }\n        return false;//more smart code here\n    }"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This sub type of the string represents mime types"
							]
						}
					],
					"extends": [
						{
							"typeName": "Sys.StringType",
							"nameSpace": "Sys",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\bodies.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Response",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "code",
							"type": {
								"typeName": "Sys.StatusCode",
								"nameSpace": "Sys",
								"basicName": "StatusCode",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\bodies.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.extraMetaKey",
									"arguments": [
										"statusCodes"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Responses MUST be a map of one or more HTTP status codes, where each status code itself is a map that describes that status code."
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "headers",
							"type": {
								"base": {
									"typeName": "models.DataElement",
									"nameSpace": "models",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\bodies.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"models.ModelLocation.HEADERS"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"models.LocationKind.APISTRUCTURE"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Header"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"it seems to use different wildcard then in methods and resources"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Detailed information about any response headers returned by this method"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Object whose property names are the response header names and whose values describe the values."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "body",
							"type": {
								"base": {
									"typeName": "models.DataElement",
									"nameSpace": "models",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\bodies.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Body"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The body of the response: a body declaration"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Object whose properties are either<br>* Media types and whose values are type objects describing the request body for that media type, or<br>* a type object describing the request body for the default media type specified in the root mediaType property."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\bodies.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"displayName": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"An alternate, human-friendly name for the response"
								]
							}
						],
						"description": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"A longer, human-friendly description of the response"
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Markdown string"
								]
							}
						],
						"annotations": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Annotations to be applied to this response. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See the [[raml-10-spec-annotations|section on annotations]]."
								]
							}
						]
					}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\raml-labs\\src\\raml1\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts",
				"models": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\datamodel.ts",
				"Common": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\common.ts"
			},
			"name": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\bodies.ts"
		},
		{
			"classes": [
				{
					"name": "Status",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "code",
							"type": {
								"typeName": "StatusCode",
								"nameSpace": "",
								"basicName": "StatusCode",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\auth.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "message",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "AuthentificationState",
					"methods": [
						{
							"name": "testAccessControl",
							"start": 435,
							"end": 564,
							"text": "\n\n    /**\n     * allows to test if method can be accessed\n     * @param req\n     */\n    testAccessControl(req:har.Request):Status"
						},
						{
							"name": "testAccessControl",
							"start": 564,
							"end": 622,
							"text": "\n\n\n    testAccessControl(method:RamlWrapper.Method):Status"
						},
						{
							"name": "status",
							"start": 622,
							"end": 644,
							"text": "\n\n    status():Status;"
						},
						{
							"name": "schemeId",
							"start": 644,
							"end": 667,
							"text": "\n\n    schemeId():string"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "AuthentificationParameters",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "AuthData",
					"methods": [
						{
							"name": "api",
							"start": 754,
							"end": 780,
							"text": "\n    api():RamlWrapper.Api"
						},
						{
							"name": "apiUrl",
							"start": 780,
							"end": 801,
							"text": "\n    apiUrl():string;"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "authentificationParameters",
							"type": {
								"typeName": "AuthentificationParameters",
								"nameSpace": "",
								"basicName": "AuthentificationParameters",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\auth.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ParameterSpec",
					"methods": [
						{
							"name": "name",
							"start": 887,
							"end": 905,
							"text": "\n    name():string"
						},
						{
							"name": "required",
							"start": 905,
							"end": 929,
							"text": "\n    required():boolean;"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "PromptSpec",
					"methods": [
						{
							"name": "name",
							"start": 1031,
							"end": 1049,
							"text": "\n    name():string"
						},
						{
							"name": "description",
							"start": 1049,
							"end": 1074,
							"text": "\n    description():string"
						},
						{
							"name": "toPrompt",
							"start": 1074,
							"end": 1106,
							"text": "\n    toPrompt():ParameterSpec[];"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "UserResponse",
					"methods": [
						{
							"name": "isCancelled",
							"start": 1157,
							"end": 1183,
							"text": "\n    isCancelled():boolean"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "QueryListener",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "EndPoint",
					"methods": [
						{
							"name": "endpointUrl",
							"start": 1265,
							"end": 1290,
							"text": "\n    endpointUrl():string"
						},
						{
							"name": "addListener",
							"start": 1290,
							"end": 1331,
							"text": "\n    addListener(listener:QueryListener);"
						},
						{
							"name": "removeListener",
							"start": 1331,
							"end": 1374,
							"text": "\n    removeListener(listenr:QueryListener);"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "EndPointSpec",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "url",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "needToSendResponse",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecurityEnvironment",
					"methods": [
						{
							"name": "executeHTTPRequest",
							"start": 1481,
							"end": 1635,
							"text": "\n\n    /**\n     * execute authentification step to external service\n     * @param reg\n     */\n    executeHTTPRequest(reg:har.Request):Promise<har.Response>"
						},
						{
							"name": "askForExtraData",
							"start": 1635,
							"end": 1822,
							"text": "\n\n\n    /**\n     * asks for extra parameters( stored in cfg file or asked in dialog)\n     * @param parameterSpec\n     */\n    askForExtraData(parameterSpec:PromptSpec):Promise<UserResponse>"
						},
						{
							"name": "getOrCreateEndPoint",
							"start": 1822,
							"end": 1894,
							"text": "\n\n\n    // create\n    getOrCreateEndPoint(EndPointSpec):Promise<EndPoint>"
						},
						{
							"name": "hasEndpoints",
							"start": 1894,
							"end": 1923,
							"text": "\n\n    hasEndpoints():boolean;"
						},
						{
							"name": "isInteractive",
							"start": 1923,
							"end": 1952,
							"text": "\n    isInteractive():boolean;"
						},
						{
							"name": "isGraphical",
							"start": 1952,
							"end": 1978,
							"text": "\n    isGraphical():boolean"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "AuthentificationManager",
					"methods": [
						{
							"name": "supports",
							"start": 2016,
							"end": 2067,
							"text": "\n\n    supports(client:SecurityEnvironment):boolean;"
						},
						{
							"name": "doAuth",
							"start": 2067,
							"end": 2318,
							"text": "\n\n    /**\n     * performs authentification\n     * everything may happen here even sending horse rider to a new city\n     * or flight to moon\n     * @param env\n     */\n    doAuth(env:SecurityEnvironment,authData:AuthData):Promise<AuthentificationState>"
						},
						{
							"name": "doLogout",
							"start": 2318,
							"end": 2540,
							"text": "\n\n    /**\n     * performs log out\n     * if it is needed to blow a nuke to logout it is possible\n     * @param env\n     */\n    doLogout(env:SecurityEnvironment,authData:AuthentificationState):Promise<AuthentificationState>"
						},
						{
							"name": "addAuthDataToRequest",
							"start": 2540,
							"end": 2780,
							"text": "\n\n\n    /**\n     * performs arbitrary request transform (as a sample might change actual url)\n     * or do complex encoding\n     * @param req\n     */\n    addAuthDataToRequest(req:har.Request,state:AuthentificationState):Promise<har.Response>"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SchemeInfo",
					"methods": [
						{
							"name": "name",
							"start": 2838,
							"end": 2856,
							"text": "\n    name():string"
						},
						{
							"name": "description",
							"start": 2856,
							"end": 2881,
							"text": "\n    description():string"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "parameterSpec",
							"type": {
								"base": {
									"typeName": "ParameterSpec",
									"nameSpace": "",
									"basicName": "ParameterSpec",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\auth.ts"
								},
								"typeKind": 1
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecurityScheme",
					"methods": [
						{
							"name": "info",
							"start": 2909,
							"end": 2932,
							"text": "\n\n    info():SchemeInfo"
						},
						{
							"name": "id",
							"start": 2932,
							"end": 2948,
							"text": "\n    id():string"
						},
						{
							"name": "needsEndpoints",
							"start": 2948,
							"end": 2978,
							"text": "\n    needsEndpoints():boolean;"
						},
						{
							"name": "isInteractive",
							"start": 2978,
							"end": 3007,
							"text": "\n    isInteractive():boolean;"
						},
						{
							"name": "isGraphical",
							"start": 3007,
							"end": 3126,
							"text": "\n    /***\n     * means that you potentially need to have graphical display to pass it\n     */\n    isGraphical():boolean"
						},
						{
							"name": "createAuthManager",
							"start": 3126,
							"end": 3176,
							"text": "\n\n    createAuthManager():AuthentificationManager;"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecurityAwareApiClient",
					"methods": [
						{
							"name": "api",
							"start": 3213,
							"end": 3239,
							"text": "\n    api():RamlWrapper.Api"
						},
						{
							"name": "securitySchemes",
							"start": 3239,
							"end": 3279,
							"text": "\n\n    securitySchemes():SecurityScheme[]"
						},
						{
							"name": "getOrCreateAuthManager",
							"start": 3279,
							"end": 3349,
							"text": "\n\n    getOrCreateAuthManager(s:SecurityScheme):AuthentificationManager"
						},
						{
							"name": "doAuth",
							"start": 3349,
							"end": 3415,
							"text": "\n\n    doAuth(scheme:SecurityScheme):Promise<AuthentificationState>"
						},
						{
							"name": "doAuthSync",
							"start": 3415,
							"end": 3475,
							"text": "\n    doAuthSync(scheme:SecurityScheme):AuthentificationState"
						},
						{
							"name": "setCurrentAuthData",
							"start": 3475,
							"end": 3531,
							"text": "\n\n\n\n    setCurrentAuthData(state:AuthentificationState);"
						},
						{
							"name": "getCurrentAuthData",
							"start": 3531,
							"end": 3605,
							"text": "//needed for multiple users\n    getCurrentAuthData():AuthentificationState"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchemeHook",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [
				{
					"name": "StatusCode",
					"members": [
						"OK",
						"WARNING",
						"ERROR",
						"UNKNOWN",
						"CANCELLED"
					]
				}
			],
			"imports": {
				"Sys": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\systemTypes.ts"
			},
			"name": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-1.0\\auth.ts"
		}
	]

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [
		{
			"classes": [
				{
					"name": "GlobalSchema",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "Sys.Referencable",
							"nameSpace": "Sys",
							"basicName": "Referencable",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "Sys.SchemaString",
									"nameSpace": "Sys",
									"basicName": "SchemaString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\api.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\api.ts"
						}
					],
					"fields": [
						{
							"name": "key",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of the global schema, used to refer on schema content"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "value",
							"type": {
								"typeName": "Sys.SchemaString",
								"nameSpace": "Sys",
								"basicName": "SchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Content of the schema"
									]
								},
								{
									"name": "MetaModel.value",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"value"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"Content of the schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLSimpleElement",
							"nameSpace": "Common",
							"basicName": "RAMLSimpleElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\api.ts"
						}
					],
					"moduleName": "RAMLSpec",
					"annotationOverridings": {}
				},
				{
					"name": "Api",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The title property is a short plain text description of the RESTful API. The title property's value SHOULD be suitable for use as a title for the contained user documentation."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "version",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"If the RAML API definition is targeted to a specific API version, the API definition MUST contain a version property. The version property is OPTIONAL and should not be used if:\nThe API itself is not versioned.\nThe API definition does not change between versions. The API architect can decide whether a change to user documentation elements, but no change to the API's resources, constitutes a version change.\nThe API architect MAY use any versioning scheme so long as version numbers retain the same format. For example, \"v3\", \"v3.0\", and \"V3\" are all allowed, but are not considered to be equal."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "baseUri",
							"type": {
								"typeName": "Sys.FullUriTemplate",
								"nameSpace": "Sys",
								"basicName": "FullUriTemplate",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional during development; Required after implementation) A RESTful API's resources are defined relative to the API's base URI. The use of the baseUri field is OPTIONAL to allow describing APIs that have not yet been implemented. After the API is implemented (even a mock implementation) and can be accessed at a service endpoint, the API definition MUST contain a baseUri property. The baseUri property's value MUST conform to the URI specification [RFC2396] or a Level 1 Template URI as defined in RFC 6570 [RFC6570].\n            The baseUri property SHOULD only be used as a reference value. API client generators MAY make the baseUri configurable by the API client's users.\n            If the baseUri value is a Level 1 Template URI, the following reserved base URI parameters are available for replacement:"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/72"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/119"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"Overrriding on resource level looks pretty strange"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "baseUriParameters",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.BURI"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Base uri parameters are named parameters which described template parameters in the base uri"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"Specification is not good enough"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/150"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "uriParameters",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.BURI"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"URI parameters can be further defined by using the uriParameters property. The use of uriParameters is OPTIONAL. The uriParameters property MUST be a map in which each key MUST be the name of the URI parameter as defined in the baseUri property. The uriParameters CANNOT contain a key named version because it is a reserved URI parameter name. The value of the uriParameters property is itself a map that specifies  the property's attributes as named parameters"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"Duplicate of base uri parameters"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/61"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "protocols",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"HTTP",
											"HTTPS"
										]
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"Not clear how it should work in combination with baseUri"
									]
								},
								{
									"name": "MetaModel.needsClarification",
									"arguments": [
										"Actually it is a set"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A RESTful API can be reached HTTP, HTTPS, or both. The protocols property MAY be used to specify the protocols that an API supports. If the protocols property is not specified, the protocol specified at the baseUri property is used. The protocols property MUST be an array of strings, of values `HTTP` and/or `HTTPS`."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "mediaType",
							"type": {
								"typeName": "Bodies.MimeType",
								"nameSpace": "Bodies",
								"basicName": "MimeType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.oftenKeys",
									"arguments": [
										[
											"application/json",
											"application/xml",
											"application/x-www-form-urlencoded",
											"multipart/formdata"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional) The media types returned by API responses, and expected from API requests that accept a body, MAY be defaulted by specifying the mediaType property. This property is specified at the root level of the API definition. The property's value MAY be a single string with a valid media type:\nOne of the following YAML media types:\ntext/yaml\ntext/x-yaml\napplication/yaml\napplication/x-yaml*\nAny type from the list of IANA MIME Media Types, http://www.iana.org/assignments/media-types\nA custom type that conforms to the regular expression, \"application/[A-Za-z.-0-1]*+?(json|xml)\"\nFor any combination of resource and operation in the API, if a media type is specified as a key of the body property for that resource and operation, or if a media type is specified in the mediaType property, the body MUST be in the specified media types. Moreover, if the client specifies an Accepts header containing multiple media types that are allowed by the specification for the requested resource and operation, the server SHOULD return a body using the media type in the Accepts header's mediaType list.\n"
									]
								},
								{
									"name": "MetaModel.needsClarification",
									"arguments": [
										"should be open enum"
									]
								},
								{
									"name": "MetaModel.inherited",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "schemas",
							"type": {
								"base": {
									"typeName": "GlobalSchema",
									"nameSpace": "",
									"basicName": "GlobalSchema",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"To better achieve consistency and simplicity, the API definition SHOULD include an OPTIONAL schemas property in the root section. The schemas property specifies collections of schemas that could be used anywhere in the API definition. The value of the schemas property is an array of maps; in each map, the keys are the schema name, and the values are schema definitions. The schema definitions MAY be included inline or by using the RAML !include user-defined data type."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "traits",
							"type": {
								"base": {
									"typeName": "RM.Trait",
									"nameSpace": "RM",
									"basicName": "Trait",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of traits used in this API"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "RM.SecuritySchemaRef",
									"nameSpace": "RM",
									"basicName": "SecuritySchemaRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.issue",
									"arguments": [
										"Not stated clearly in spec"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A list of the security schemas to apply to all methods, these must be defined in the securitySchemes declaration."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securitySchemes",
							"type": {
								"base": {
									"typeName": "RM.SecuritySchema",
									"nameSpace": "RM",
									"basicName": "SecuritySchema",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Security schemas that can be applied with securedBy"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "resourceTypes",
							"type": {
								"base": {
									"typeName": "RM.ResourceType",
									"nameSpace": "RM",
									"basicName": "ResourceType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declaration of resource types used in this API"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "resources",
							"type": {
								"base": {
									"typeName": "RM.Resource",
									"nameSpace": "RM",
									"basicName": "Resource",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Resource"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Resources are identified by their relative URI, which MUST begin with a slash (/).\nA resource defined as a root-level property is called a top-level resource. Its property's key is the resource's URI relative to the baseUri.\nA resource defined as a child property of another resource is called a nested resource, and its property's key is its URI relative to its parent resource's URI.\nEvery property whose key begins with a slash (/), and is either at the root of the API definition or is the child property of a resource property, is a resource property. The key of a resource, i.e. its relative URI, MAY consist of multiple URI path fragments separated by slashes; e.g. \"/bom/items\" may indicate the collection of items in a bill of materials as a single resource. However, if the individual URI path fragments are themselves resources, the API definition SHOULD use nested resources to describe this structure; e.g. if \"/bom\" is itself a resource then \"/items\" should be a nested resource of \"/bom\", while \"/bom/items\" should not be used."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "documentation",
							"type": {
								"base": {
									"typeName": "DocumentationItem",
									"nameSpace": "",
									"basicName": "DocumentationItem",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The API definition can include a variety of documents that serve as a user guides and reference documentation for the API. Such documents can clarify how the API works or provide business context.\n            Documentation-generators MUST include all the sections in an API definition's documentation property in the documentation output, and they MUST preserve the order in which the documentation is declared.\n            To add user documentation to the API, include the documentation property at the root of the API definition. The documentation property MUST be an array of documents. Each document MUST contain title and content attributes, both of which are REQUIRED. If the documentation property is specified, it MUST include at least one document.\n            Documentation-generators MUST process the content field as if it was defined using Markdown [MARKDOWN].\n\n        This example shows an API definition with a single user document."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\api.ts"
						}
					],
					"moduleName": "RAMLSpec",
					"annotationOverridings": {}
				},
				{
					"name": "DocumentationItem",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"title of documentation section"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "content",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Content of documentation section"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"Needs better documentation, I would like to polish it in 1.0"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLSimpleElement",
							"nameSpace": "Common",
							"basicName": "RAMLSimpleElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\api.ts"
						}
					],
					"moduleName": "RAMLSpec",
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\raml-labs\\src\\raml1\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts",
				"RM": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts",
				"Decls": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\declarations.ts",
				"Params": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\parameters.ts",
				"Common": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\common.ts",
				"Bodies": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\bodies.ts"
			},
			"name": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\api.ts"
		},
		{
			"classes": [
				{
					"name": "SpecPartMetaData",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [
				{
					"name": "RAMLVersion",
					"members": [
						"RAML08",
						"RAML10"
					]
				}
			],
			"imports": {},
			"name": "c:\\GIT-repos\\raml-labs\\src\\raml1\\metamodel.ts"
		},
		{
			"classes": [
				{
					"name": "ValueType",
					"methods": [
						{
							"name": "parse",
							"start": 69,
							"end": 235,
							"text": "\n\n    /**\n     * parses inner structure of value type if value type has invalid value you should throw error\n     * with descriptive message\n     */\n    parse():any{}"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "StringType",
					"methods": [
						{
							"name": "value",
							"start": 321,
							"end": 349,
							"text": " value():string{return null}"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"string"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "NumberType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"number"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "BooleanType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"boolean"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Referencable",
					"methods": [],
					"typeParameters": [
						"T"
					],
					"typeParameterConstraint": [
						null
					],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Reference",
					"methods": [],
					"typeParameters": [
						"T"
					],
					"typeParameterConstraint": [
						null
					],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DeclaresDynamicType",
					"methods": [],
					"typeParameters": [
						"T"
					],
					"typeParameterConstraint": [
						null
					],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [
						{
							"typeName": "Referencable",
							"nameSpace": "",
							"basicName": "Referencable",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "T",
									"nameSpace": "",
									"basicName": "T",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "UriTemplate",
					"methods": [
						{
							"name": "templateArguments",
							"start": 1141,
							"end": 1579,
							"text": "\n\n    templateArguments():string[]{\n        var pos=0;\n        var str=this.value();\n        var result=[];\n        while(true){\n            var start=str.indexOf(\"{\",pos)\n            if (start!=-1){\n                var end=str.indexOf(\"}\",start+1);\n                result.push(str.substring(start+1,end))\n                pos=end;\n            }\n            else{\n                break;\n            }\n        }\n        return result;\n    }"
						},
						{
							"name": "validate",
							"start": 1579,
							"end": 1679,
							"text": "\n\n    validate(){\n        var str=this.value();\n        //write something to validate Url here\n    }"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This type currently serves both for absolute and relative urls"
							]
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"https://github.com/raml-org/raml-spec/issues/115"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "RelativeUri",
					"methods": [
						{
							"name": "parse",
							"start": 1804,
							"end": 2598,
							"text": "\n    parse():string[]{\n        //FIXME INHERITANCE\n        var value=this.value();\n        var result=[]\n        var temp=\"\";\n        var inPar=false;\n        var count=0;\n        for (var a=0;a<value.length;a++){\n            var c=value[a];\n            if (c=='{'){\n                count++;\n                inPar=true;\n                continue;\n            }\n            if (c=='}'){\n                count--;\n                inPar=false;\n                result.push(temp);\n                temp=\"\";\n                continue;\n            }\n            if (inPar){\n                temp+=c;\n            }\n        }\n        if (count>0){\n            throw new Error(\"Unmatched '{'\")\n        }\n        if (count<0){\n            throw new Error(\"Unmatched '}'\")\n        }\n        return result;\n    }"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This  type describes relative uri templates"
							]
						}
					],
					"extends": [
						{
							"typeName": "UriTemplate",
							"nameSpace": "",
							"basicName": "UriTemplate",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "FullUriTemplate",
					"methods": [
						{
							"name": "parse",
							"start": 2727,
							"end": 3512,
							"text": "\n    parse():string[]{//FIXME INHERITANCE\n        var value=this.value();\n        var result=[]\n        var temp=\"\";\n        var inPar=false;\n        var count=0;\n        for (var a=0;a<value.length;a++){\n            var c=value[a];\n            if (c=='{'){\n                count++;\n                inPar=true;\n                continue;\n            }\n            if (c=='}'){\n                count--;\n                inPar=false;\n                result.push(temp);\n                temp=\"\";\n                continue;\n            }\n            if (inPar){\n                temp+=c;\n            }\n        }\n        if (count>0){\n            throw new Error(\"Unmatched '{'\")\n        }\n        if (count<0){\n            throw new Error(\"Unmatched '}'\")\n        }\n        return result;\n    }"
						},
						{
							"name": "validate",
							"start": 3512,
							"end": 3611,
							"text": "\n    validate(){\n        var str=this.value();\n        //write something to validate Url here\n    }"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This  type describes absolute uri templates"
							]
						}
					],
					"extends": [
						{
							"typeName": "UriTemplate",
							"nameSpace": "",
							"basicName": "UriTemplate",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "FixedUri",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This  type describes fixed uris"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "MarkdownString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.innerType",
							"arguments": [
								"markdown"
							]
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"https://github.com/raml-org/raml-spec/issues/80"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"Mardown string is a string which can contain markdown as an extension this markdown should support links with RAML Pointers since 1.0"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SchemaString",
					"methods": [
						{
							"name": "validate",
							"start": 4224,
							"end": 4407,
							"text": "\n\n    validate(){\n        var str=this.value();\n        //write something to validate schema here here\n        //in fact it should check that content is valid json or xsd schema\n    }"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Schema at this moment only two subtypes are supported (json schema and xsd)"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "JSonSchemaString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"this.mediaType&&this.mediaType.isJSON()"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"JSON schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "SchemaString",
							"nameSpace": "",
							"basicName": "SchemaString",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "XMLSchemaString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.innerType",
							"arguments": [
								"xml"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"XSD schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "SchemaString",
							"nameSpace": "",
							"basicName": "SchemaString",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ExampleString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "StatusCode",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "JSONExample",
					"methods": [
						{
							"name": "parse",
							"start": 4939,
							"end": 5341,
							"text": "\n\n    parse():any{\n        try {\n            JSON.parse(this.value());\n        } catch (e){\n            var ne=new Error(\"Warning: Can not parse JSON:\"+e.message);\n            throw ne\n        }\n        var a=this.$$.parent().attr('schema');\n        if (a) {\n          var sm=  a.findReferencedValue()\n          if (sm&&sm.validate){\n              sm.validate(this.value());\n          }\n        }\n    }"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"this.mediaType.isJSON()"
							]
						}
					],
					"extends": [
						{
							"typeName": "ExampleString",
							"nameSpace": "",
							"basicName": "ExampleString",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "XMLExample",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"this.mediaType.isXML()"
							]
						}
					],
					"extends": [
						{
							"typeName": "ExampleString",
							"nameSpace": "",
							"basicName": "ExampleString",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\raml-labs\\src\\raml1\\metamodel.ts"
			},
			"name": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts"
		},
		{
			"classes": [
				{
					"name": "ResourceTypeRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Sys.Reference",
							"nameSpace": "Sys",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "ResourceType",
									"nameSpace": "",
									"basicName": "ResourceType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "TraitRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Sys.Reference",
							"nameSpace": "Sys",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "Trait",
									"nameSpace": "",
									"basicName": "Trait",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchemaPart",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.allowAny",
							"arguments": []
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"Specification is actually very vague here"
							]
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLSimpleElement",
							"nameSpace": "Common",
							"basicName": "RAMLSimpleElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchemaSettings",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.allowAny",
							"arguments": []
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"Specification is actually very vague here"
							]
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLSimpleElement",
							"nameSpace": "Common",
							"basicName": "RAMLSimpleElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "OAuth1SecuritySchemeSettings",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "requestTokenUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Temporary Credential Request endpoint as defined in RFC5849 Section 2.1"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "authorizationUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Resource Owner Authorization endpoint as defined in RFC5849 Section 2.2"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "tokenCredentialsUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Token Request endpoint as defined in RFC5849 Section 2.3"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"$parent.type=='OAuth 1.0'"
							]
						},
						{
							"name": "MetaModel.allowAny",
							"arguments": []
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"Specification is actually very vague here"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchemaSettings",
							"nameSpace": "",
							"basicName": "SecuritySchemaSettings",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "OAuth2SecuritySchemeSettings",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "accessTokenUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Token Endpoint as defined in RFC6749 [RFC6748] Section 3.2"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "authorizationUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Authorization Endpoint as defined in RFC6749 [RFC6748] Section 3.1"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "authorizationGrants",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A list of the Authorization grants supported by the API As defined in RFC6749 [RFC6749] Sections 4.1, 4.2, 4.3 and 4.4, can be any of: code, token, owner or credentials."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "scopes",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A list of scopes supported by the API as defined in RFC6749 [RFC6749] Section 3.3"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"$parent.type=='OAuth 2.0'"
							]
						},
						{
							"name": "MetaModel.allowAny",
							"arguments": []
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"Specification is actually very vague here"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchemaSettings",
							"nameSpace": "",
							"basicName": "SecuritySchemaSettings",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchemaRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Sys.Reference",
							"nameSpace": "Sys",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "SecuritySchema",
									"nameSpace": "",
									"basicName": "SecuritySchema",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchema",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "Sys.Referencable",
							"nameSpace": "Sys",
							"basicName": "Referencable",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "SecuritySchema",
									"nameSpace": "",
									"basicName": "SecuritySchema",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"OAuth 1.0",
											"OAuth 2.0",
											"Basic Authentication",
											"Digest Authentication",
											"x-{other}"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The securitySchemes property MUST be used to specify an API's security mechanisms, including the required settings and the authentication methods that the API supports. one authentication method is allowed if the API supports them."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The description attribute MAY be used to describe a securitySchemes property."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "describedBy",
							"type": {
								"typeName": "SecuritySchemaPart",
								"nameSpace": "",
								"basicName": "SecuritySchemaPart",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The describedBy attribute MAY be used to apply a trait-like structure to a security scheme mechanism so as to extend the mechanism, such as specifying response codes, HTTP headers or custom documentation.\n        This extension allows API designers to describe security schemes. As a best practice, even for standard security schemes, API designers SHOULD describe the security schemes' required artifacts, such as headers, URI parameters, and so on. Including the security schemes' description completes an API's documentation."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "settings",
							"type": {
								"typeName": "SecuritySchemaSettings",
								"nameSpace": "",
								"basicName": "SecuritySchemaSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The settings attribute MAY be used to provide security schema-specific information. Depending on the value of the type parameter, its attributes can vary.\n        The following lists describe the minimum set of properties which any processing application MUST provide and validate if it chooses to implement the Security Scheme type. Processing applications MAY choose to recognize other properties for things such as token lifetime, preferred cryptographic algorithms, an so on."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referancable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "MethodBase",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "responses",
							"type": {
								"base": {
									"typeName": "Bodies.Response",
									"nameSpace": "Bodies",
									"basicName": "Response",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Response"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Resource methods MAY have one or more responses. Responses MAY be described using the description property, and MAY include example attributes or schema properties.\n"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "body",
							"type": {
								"base": {
									"typeName": "Bodies.BodyLike",
									"nameSpace": "Bodies",
									"basicName": "BodyLike",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Body"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Some method verbs expect the resource to be sent as a request body. For example, to create a resource, the request must include the details of the resource to create.\nResources CAN have alternate representations. For example, an API might support both JSON and XML representations.\nA method's body is defined in the body property as a hashmap, in which the key MUST be a valid media type."
									]
								},
								{
									"name": "MetaModel.needsClarification",
									"arguments": [
										"Ensure that forms spec is consistent with it"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "is",
							"type": {
								"base": {
									"typeName": "TraitRef",
									"nameSpace": "",
									"basicName": "TraitRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instantiation of applyed traits"
									]
								},
								{
									"name": "MetaModel.thisFeatureCovers",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/98"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "SecuritySchemaRef",
									"nameSpace": "",
									"basicName": "SecuritySchemaRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.allowNull",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A list of the security schemas to apply, these must be defined in the securitySchemes declaration.\nTo indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme.\nSecurity schemas may also be applied to a resource with securedBy, which is equivalent to applying the security schemas to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Params.HasNormalParameters",
							"nameSpace": "Params",
							"basicName": "HasNormalParameters",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Trait",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "Sys.DeclaresDynamicType",
							"nameSpace": "Sys",
							"basicName": "DeclaresDynamicType",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "Trait",
									"nameSpace": "",
									"basicName": "Trait",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of the trait"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.inlinedTemplates",
							"arguments": []
						},
						{
							"name": "MetaModel.allowQuestion",
							"arguments": []
						}
					],
					"extends": [
						{
							"typeName": "MethodBase",
							"nameSpace": "",
							"basicName": "MethodBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ResourceType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "Sys.DeclaresDynamicType",
							"nameSpace": "Sys",
							"basicName": "DeclaresDynamicType",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "ResourceType",
									"nameSpace": "",
									"basicName": "ResourceType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of the resource type"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "methods",
							"type": {
								"base": {
									"typeName": "Method",
									"nameSpace": "",
									"basicName": "Method",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Methods that are part of this resource type definition"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"definition system did not represents that ? is allowed after method names here"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "is",
							"type": {
								"base": {
									"typeName": "TraitRef",
									"nameSpace": "",
									"basicName": "TraitRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instantiation of applyed traits"
									]
								},
								{
									"name": "MetaModel.thisFeatureCovers",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/98"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "ResourceTypeRef",
								"nameSpace": "",
								"basicName": "ResourceTypeRef",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instantiation of applyed resource type"
									]
								},
								{
									"name": "MetaModel.thisFeatureCovers",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/98"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "SecuritySchemaRef",
									"nameSpace": "",
									"basicName": "SecuritySchemaRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.allowNull",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										" securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.\nTo indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "uriParameters",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/71"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.URI"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Uri parameters of this resource"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.inlinedTemplates",
							"arguments": []
						},
						{
							"name": "MetaModel.allowQuestion",
							"arguments": []
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Method",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "method",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.extraMetaKey",
									"arguments": [
										"methods"
									]
								},
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"get",
											"put",
											"post",
											"delete",
											"patch",
											"options",
											"head"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Method that can be called"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/95"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "protocols",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"HTTP",
											"HTTPS"
										]
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"Not clear how it should work in combination with baseUri also is it also related to resources and types/traits"
									]
								},
								{
									"name": "MetaModel.needsClarification",
									"arguments": [
										"Actually it is a set"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A method can override an API's protocols value for that single method by setting a different value for the fields."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "SecuritySchemaRef",
									"nameSpace": "",
									"basicName": "SecuritySchemaRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.allowNull",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										" securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.\nTo indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Method object allows description of http methods"
							]
						}
					],
					"extends": [
						{
							"typeName": "MethodBase",
							"nameSpace": "",
							"basicName": "MethodBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Resource",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "relativeUri",
							"type": {
								"typeName": "Sys.RelativeUri",
								"nameSpace": "Sys",
								"basicName": "RelativeUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/73"
									]
								},
								{
									"name": "MetaModel.grammarTokenKind",
									"arguments": [
										"entity.name.tag.yaml"
									]
								},
								{
									"name": "MetaModel.startFrom",
									"arguments": [
										"/"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Relative URL of this resource from the parent resource"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/87"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "ResourceTypeRef",
								"nameSpace": "",
								"basicName": "ResourceTypeRef",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instantiation of applyed resource type"
									]
								},
								{
									"name": "MetaModel.thisFeatureCovers",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/98"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "is",
							"type": {
								"base": {
									"typeName": "TraitRef",
									"nameSpace": "",
									"basicName": "TraitRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instantiation of applyed traits"
									]
								},
								{
									"name": "MetaModel.thisFeatureCovers",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/98"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "SecuritySchemaRef",
									"nameSpace": "",
									"basicName": "SecuritySchemaRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.allowNull",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										" securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.\nTo indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "uriParameters",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/71"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.URI"
									]
								},
								{
									"name": "MetaModel.valueRestriction",
									"arguments": [
										"_.find(relativeUri.parse(),$value.name)",
										"Uri parameter names should match to template names in relative uri"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Uri parameters of this resource"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "methods",
							"type": {
								"base": {
									"typeName": "Method",
									"nameSpace": "",
									"basicName": "Method",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Method"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Methods that can be called on this resource"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "resources",
							"type": {
								"base": {
									"typeName": "Resource",
									"nameSpace": "",
									"basicName": "Resource",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Resource"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Children resources"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "displayName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "baseUriParameters",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.BURI"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A resource or a method can override a base URI template's values. This is useful to restrict or change the default or parameter selection in the base URI. The baseUriParameters property MAY be used to override any or all parameters defined at the root level baseUriParameters property, as well as base URI parameters not specified at the root level."
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"This feature is not consistent (causes not solvable overloading)"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\raml-labs\\src\\raml1\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts",
				"Params": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\parameters.ts",
				"Bodies": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\bodies.ts",
				"Common": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\common.ts"
			},
			"name": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
		},
		{
			"classes": [
				{
					"name": "Parameter",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"name of the parameter"
									]
								},
								{
									"name": "MetaModel.extraMetaKey",
									"arguments": [
										"headers"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "displayName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.defaultValue",
									"arguments": [
										"string"
									]
								},
								{
									"name": "MetaModel.descriminatingProperty",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The type attribute specifies the primitive type of the parameter's resolved value. API clients MUST return/throw an error if the parameter's resolved value does not match the specified type. If type is not specified, it defaults to string."
									]
								},
								{
									"name": "MetaModel.canBeDuplicator",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "location",
							"type": {
								"typeName": "ParameterLocation",
								"nameSpace": "",
								"basicName": "ParameterLocation",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\parameters.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.system",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Location of the parameter (can not be edited by user)"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "required",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Set to true if parameter is required"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "default",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The default attribute specifies the default value to use for the property if the property is omitted or its value is not specified. This SHOULD NOT be interpreted as a requirement for the client to send the default attribute's value if there is no other value to send. Instead, the default attribute's value is the value the server uses if the client does not send a value."
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/86"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "example",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional) The example attribute shows an example value for the property. This can be used, e.g., by documentation generators to generate sample values for the property."
									]
								},
								{
									"name": "MetaModel.needsClarification",
									"arguments": [
										"It sounds consistent to allow multiple examples for parameters, but it will make hard to describe difference between 0.8 and 1.0 in terms of def system"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "repeat",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The repeat attribute specifies that the parameter can be repeated. If the parameter can be used multiple times, the repeat parameter value MUST be set to 'true'. Otherwise, the default value is 'false' and the parameter may not be repeated."
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"semantic of repeat is not clearly specified and actually multiple possible reasonable options exists at the same time "
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/152"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.issue",
							"arguments": [
								"Multiple  parameter types are not supported in this specification we should think about how to cover them properly using same key and redefining parameter looks pretty reasonable for 1.0"
							]
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "StrElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "pattern",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.thisFeatureCovers",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/97"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type string) The pattern attribute is a regular expression that a parameter of type string MUST match. Regular expressions MUST follow the regular expression specification from ECMA 262/Perl 5. The pattern MAY be enclosed in double quotes for readability and clarity."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "enum",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/82"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "minLength",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/93"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/141"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type string) The minLength attribute specifies the parameter value's minimum number of characters."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "maxLength",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type string) The maxLength attribute specifies the parameter value's maximum number of characters."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "string"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value must be a string"
							]
						}
					],
					"extends": [
						{
							"typeName": "Parameter",
							"nameSpace": "",
							"basicName": "Parameter",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "BooleanElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "boolean"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value must be a boolean"
							]
						}
					],
					"extends": [
						{
							"typeName": "Parameter",
							"nameSpace": "",
							"basicName": "Parameter",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "NumberElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "number"
							},
							"optional": false
						},
						{
							"name": "minimum",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type number or integer) The minimum attribute specifies the parameter's minimum value."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "maximum",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type number or integer) The maximum attribute specifies the parameter's maximum value."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value MUST be a number. Indicate floating point numbers as defined by YAML."
							]
						}
					],
					"extends": [
						{
							"typeName": "Parameter",
							"nameSpace": "",
							"basicName": "Parameter",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "IntegerElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "integer"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value MUST be a integer."
							]
						}
					],
					"extends": [
						{
							"typeName": "NumberElement",
							"nameSpace": "",
							"basicName": "NumberElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DateElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "date"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value MUST be a string representation of a date as defined in RFC2616 Section 3.3 [RFC2616]. "
							]
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"https://github.com/raml-org/raml-spec/issues/105"
							]
						}
					],
					"extends": [
						{
							"typeName": "Parameter",
							"nameSpace": "",
							"basicName": "Parameter",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "FileElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "file"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.requireValue",
							"arguments": [
								"location",
								"ParameterLocation.FORM"
							]
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"https://github.com/raml-org/raml-spec/issues/94"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"(Applicable only to Form properties) Value is a file. Client generators SHOULD use this type to handle file uploads correctly."
							]
						}
					],
					"extends": [
						{
							"typeName": "Parameter",
							"nameSpace": "",
							"basicName": "Parameter",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "HasNormalParameters",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "queryParameters",
							"type": {
								"base": {
									"typeName": "Parameter",
									"nameSpace": "",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\parameters.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/53"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/78"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/46"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"ParameterLocation.QUERY"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New query parameter"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"An APIs resources MAY be filtered (to return a subset of results) or altered (such as transforming a response body from JSON to XML format) by the use of query strings. If the resource or its method supports a query string, the query string MUST be defined by the queryParameters property"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "displayName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.issue",
									"arguments": [
										"I am not sure that it should be here but it is actually used"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "headers",
							"type": {
								"base": {
									"typeName": "Parameter",
									"nameSpace": "",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\parameters.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/59"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"ParameterLocation.HEADERS"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Headers that allowed at this position"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Header"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"It is not clear if this also allowed for resources(check)"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"cover wildcards ({*})"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [
				{
					"name": "ParameterLocation",
					"members": [
						"QUERY",
						"HEADERS",
						"URI",
						"FORM",
						"BURI"
					]
				}
			],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\raml-labs\\src\\raml1\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts",
				"Common": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\common.ts"
			},
			"name": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\parameters.ts"
		},
		{
			"classes": [
				{
					"name": "RAMLLanguageElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\common.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The description attribute describes the intended use or meaning of the $self. This value MAY be formatted using Markdown [MARKDOWN]"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "RAMLSimpleElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\raml-labs\\src\\raml1\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts",
				"Decls": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\declarations.ts"
			},
			"name": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\common.ts"
		},
		{
			"classes": [
				{
					"name": "DeclarationWithoutAnotations",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\raml-labs\\src\\raml1\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts"
			},
			"name": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\declarations.ts"
		},
		{
			"classes": [
				{
					"name": "MimeTypeModel",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "tree",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": true
						},
						{
							"name": "subtype",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "suffix",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": true
						},
						{
							"name": "parameters",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": true
						}
					],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "MimeType",
					"methods": [
						{
							"name": "isForm",
							"start": 430,
							"end": 631,
							"text": "\n    isForm(){\n        if (this.value()==\"application/x-www-form-urlencoded\"||this.value()=='multipart/form-data'){\n            return true;\n        }\n\n        return false;//more smart code here\n    }"
						},
						{
							"name": "isXML",
							"start": 631,
							"end": 776,
							"text": "\n\n    isXML(){\n        if (this.value()==\"application/xml\"){\n            return true;\n        }\n        return false;//more smart code here\n    }"
						},
						{
							"name": "isJSON",
							"start": 776,
							"end": 923,
							"text": "\n\n    isJSON(){\n        if (this.value()==\"application/json\"){\n            return true;\n        }\n        return false;//more smart code here\n    }"
						},
						{
							"name": "parse",
							"start": 1006,
							"end": 1548,
							"text": "\n    parse(){\n        /**\n         * top-level type name / subtype name [ ; parameters ]\n         *\n         * top-level type name / [ tree. ] subtype name [ +suffix ] [ ; parameters ]\n         */\n        var v=this.value();\n        if (v==\"*/*\"){\n            return\n        }\n        var res= mediaTypeParser.parse(v);\n        var types={application:1, audio:1, example:1, image:1, message:1, model:1, multipart:1, text:1, video:1}\n        if (!types[res.type]){\n            throw new Error(\"Unknown media type 'type' value\")\n        }\n    }"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This sub type of the string represents mime types"
							]
						}
					],
					"extends": [
						{
							"typeName": "Sys.StringType",
							"nameSpace": "Sys",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\bodies.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "BodyLike",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Mime type of the request or response body"
									]
								},
								{
									"name": "MetaModel.canInherit",
									"arguments": [
										"mediaType"
									]
								},
								{
									"name": "MetaModel.oftenKeys",
									"arguments": [
										[
											"application/json",
											"application/xml",
											"application/x-www-form-urlencoded",
											"multipart/formdata"
										]
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "schema",
							"type": {
								"typeName": "Sys.SchemaString",
								"nameSpace": "Sys",
								"basicName": "SchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\bodies.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/8"
									]
								},
								{
									"name": "MetaModel.requireValue",
									"arguments": [
										"this.name.isForm()",
										"false"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"\n    The structure of a request or response body MAY be further specified by the schema property under the appropriate media type.\n\nThe schema key CANNOT be specified if a body's media type is application/x-www-form-urlencoded or multipart/form-data.\n\nAll parsers of RAML MUST be able to interpret JSON Schema [JSON_SCHEMA] and XML Schema [XML_SCHEMA].\n\nSchema MAY be declared inline or in an external file. However, if the schema is sufficiently large so as to make it difficult for a person to read the API definition, or the schema is reused across multiple APIs or across multiple miles in the same API, the !include user-defined data type SHOULD be used instead of including the content inline.\nAlternatively, the value of the schema field MAY be the name of a schema specified in the root-level schemas property (see Named Parameters, or it MAY be declared in an external file and included by using the by using the RAML !include user-defined data type."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "example",
							"type": {
								"typeName": "Sys.ExampleString",
								"nameSpace": "Sys",
								"basicName": "ExampleString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\bodies.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/75"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/70"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/24"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Documentation generators MUST use body properties' example attributes to generate example invocations.\n\nThis example shows example attributes for two body property media types."
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/107"
									]
								},
								{
									"name": "MetaModel.needsClarification",
									"arguments": [
										"Multiple examples"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/113"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "formParameters",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\bodies.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.FORM"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Web forms REQUIRE special encoding and custom declaration.\nIf the API's media type is either application/x-www-form-urlencoded or multipart/form-data, the formParameters property MUST specify the name-value pairs that the API is expecting.\nThe formParameters property is a map in which the key is the name of the web form parameter, and the value is itself a map the specifies the web form parameter's attributes"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.canInherit",
							"arguments": [
								"mediaType"
							]
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\bodies.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "XMLBody",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "schema",
							"type": {
								"typeName": "Sys.XMLSchemaString",
								"nameSpace": "Sys",
								"basicName": "XMLSchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\bodies.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"XSD Schema"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"this.mime.isXML()"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"Needed to set connection between xml related mime types and xsd schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "BodyLike",
							"nameSpace": "",
							"basicName": "BodyLike",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\bodies.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "JSONBody",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "schema",
							"type": {
								"typeName": "Sys.JSonSchemaString",
								"nameSpace": "Sys",
								"basicName": "JSonSchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\bodies.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"JSON Schema"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"this.mime.isJSON()"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"Needed to set connection between json related mime types and json schema"
							]
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"https://github.com/raml-org/raml-spec/issues/160"
							]
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"https://github.com/raml-org/raml-spec/issues/81"
							]
						}
					],
					"extends": [
						{
							"typeName": "BodyLike",
							"nameSpace": "",
							"basicName": "BodyLike",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\bodies.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Response",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "code",
							"type": {
								"typeName": "Sys.StatusCode",
								"nameSpace": "Sys",
								"basicName": "StatusCode",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\bodies.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.extraMetaKey",
									"arguments": [
										"statusCodes"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Responses MUST be a map of one or more HTTP status codes, where each status code itself is a map that describes that status code."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "headers",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\bodies.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.HEADERS"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Header"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"it seems to use different wildcard then in methods and resources"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"An API's methods may support custom header values in responses. The custom, non-standard HTTP headers MUST be specified by the headers property.\n        API's may include the the placeholder token {?} in a header name to indicate that any number of headers that conform to the specified format can be sent in responses. This is particularly useful for APIs that allow HTTP headers that conform to some naming convention to send arbitrary, custom data.\n\nIn the following example, the header x-metadata-{?} is used to send metadata that has been saved with the media."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "body",
							"type": {
								"base": {
									"typeName": "BodyLike",
									"nameSpace": "",
									"basicName": "BodyLike",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\bodies.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Body"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Each response MAY contain a body property, which conforms to the same structure as request body properties (see Body). Responses that can return more than one response code MAY therefore have multiple bodies defined.\nFor APIs without a priori knowledge of the response types for their responses, \"*/*\" MAY be used to indicate that responses that do not matching other defined data types MUST be accepted. Processing applications MUST match the most descriptive media type first if \"*/*\" is used."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\bodies.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\raml-labs\\src\\raml1\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\systemTypes.ts",
				"Params": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\parameters.ts",
				"Common": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\common.ts"
			},
			"name": "c:\\GIT-repos\\raml-labs\\src\\raml1\\spec-0.8\\bodies.ts"
		}
	]

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = null

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var parser = (function () {
	    "use strict";
	    /*
	     * Generated by PEG.js 0.9.0.
	     *
	     * http://pegjs.org/
	     */
	    function peg$subclass(child, parent) {
	        function ctor() {
	            this.constructor = child;
	        }
	        ctor.prototype = parent.prototype;
	        child.prototype = new ctor();
	    }
	    function peg$SyntaxError(message, expected, found, location) {
	        this.message = message;
	        this.expected = expected;
	        this.found = found;
	        this.location = location;
	        this.name = "SyntaxError";
	        if (typeof Error.captureStackTrace === "function") {
	            Error.captureStackTrace(this, peg$SyntaxError);
	        }
	    }
	    peg$subclass(peg$SyntaxError, Error);
	    function peg$parse(input) {
	        var options = arguments.length > 1 ? arguments[1] : {}, parser = this, peg$FAILED = {}, peg$startRuleFunctions = { Signature: peg$parseSignature }, peg$startRuleFunction = peg$parseSignature, peg$c0 = "(", peg$c1 = { type: "literal", value: "(", description: "\"(\"" }, peg$c2 = ")", peg$c3 = { type: "literal", value: ")", description: "\")\"" }, peg$c4 = "=>", peg$c5 = { type: "literal", value: "=>", description: "\"=>\"" }, peg$c6 = function (args, returnType) {
	            return { "args": args, "returnType": returnType ? returnType[1] : null };
	        }, peg$c7 = function (farg, other) {
	            return [farg].concat(other);
	        }, peg$c8 = ",", peg$c9 = { type: "literal", value: ",", description: "\",\"" }, peg$c10 = function (r) {
	            return r;
	        }, peg$c11 = "?", peg$c12 = { type: "literal", value: "?", description: "\"?\"" }, peg$c13 = ":", peg$c14 = { type: "literal", value: ":", description: "\":\"" }, peg$c15 = function (lit, opt, t) {
	            return { "name": lit.join(''), "type": t, "opt": opt ? true : false };
	        }, peg$c16 = "{", peg$c17 = { type: "literal", value: "{", description: "\"{\"" }, peg$c18 = "}", peg$c19 = { type: "literal", value: "}", description: "\"}\"" }, peg$c20 = function (r, other) {
	            return { "type": "responses", "codes": [r].concat(other) };
	        }, peg$c21 = function (v) {
	            return v;
	        }, peg$c22 = function (c0, c1, c2, t) {
	            return { "type": "codeAndType", "expr": t, "code": c0 + c1 + c2 };
	        }, peg$c23 = "|", peg$c24 = { type: "literal", value: "|", description: "\"|\"" }, peg$c25 = function (first, rest) {
	            return rest ? { "type": "union", "first": first, "rest": rest[3] } : first;
	        }, peg$c26 = "[]", peg$c27 = { type: "literal", value: "[]", description: "\"[]\"" }, peg$c28 = function (expr, arr) {
	            return { "type": "parens", "expr": expr, "arr": arr.length };
	        }, peg$c29 = "<", peg$c30 = { type: "literal", value: "<", description: "\"<\"" }, peg$c31 = ">", peg$c32 = { type: "literal", value: ">", description: "\">\"" }, peg$c33 = function (first, other) {
	            return [first].concat(other);
	        }, peg$c34 = { type: "other", description: "name" }, peg$c35 = function (r, tp, c) {
	            return { "type": "name", "params": tp, "value": r.join(""), "arr": (c.length) };
	        }, peg$c36 = { type: "other", description: "whitespace" }, peg$c37 = /^[ \t\n\r]/, peg$c38 = { type: "class", value: "[ \\t\\n\\r]", description: "[ \\t\\n\\r]" }, peg$c39 = /^[A-Z]/, peg$c40 = { type: "class", value: "[A-Z]", description: "[A-Z]" }, peg$c41 = "_", peg$c42 = { type: "literal", value: "_", description: "\"_\"" }, peg$c43 = "-", peg$c44 = { type: "literal", value: "-", description: "\"-\"" }, peg$c45 = ".", peg$c46 = { type: "literal", value: ".", description: "\".\"" }, peg$c47 = /^[a-z]/, peg$c48 = { type: "class", value: "[a-z]", description: "[a-z]" }, peg$c49 = /^[0-9]/, peg$c50 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{ line: 1, column: 1, seenCR: false }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
	        if ("startRule" in options) {
	            if (!(options.startRule in peg$startRuleFunctions)) {
	                throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	            }
	            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	        }
	        function text() {
	            return input.substring(peg$savedPos, peg$currPos);
	        }
	        function location() {
	            return peg$computeLocation(peg$savedPos, peg$currPos);
	        }
	        function expected(description) {
	            throw peg$buildException(null, [{ type: "other", description: description }], input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
	        }
	        function error(message) {
	            throw peg$buildException(message, null, input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
	        }
	        function peg$computePosDetails(pos) {
	            var details = peg$posDetailsCache[pos], p, ch;
	            if (details) {
	                return details;
	            }
	            else {
	                p = pos - 1;
	                while (!peg$posDetailsCache[p]) {
	                    p--;
	                }
	                details = peg$posDetailsCache[p];
	                details = {
	                    line: details.line,
	                    column: details.column,
	                    seenCR: details.seenCR
	                };
	                while (p < pos) {
	                    ch = input.charAt(p);
	                    if (ch === "\n") {
	                        if (!details.seenCR) {
	                            details.line++;
	                        }
	                        details.column = 1;
	                        details.seenCR = false;
	                    }
	                    else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
	                        details.line++;
	                        details.column = 1;
	                        details.seenCR = true;
	                    }
	                    else {
	                        details.column++;
	                        details.seenCR = false;
	                    }
	                    p++;
	                }
	                peg$posDetailsCache[pos] = details;
	                return details;
	            }
	        }
	        function peg$computeLocation(startPos, endPos) {
	            var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
	            return {
	                start: {
	                    offset: startPos,
	                    line: startPosDetails.line,
	                    column: startPosDetails.column
	                },
	                end: {
	                    offset: endPos,
	                    line: endPosDetails.line,
	                    column: endPosDetails.column
	                }
	            };
	        }
	        function peg$fail(expected) {
	            if (peg$currPos < peg$maxFailPos) {
	                return;
	            }
	            if (peg$currPos > peg$maxFailPos) {
	                peg$maxFailPos = peg$currPos;
	                peg$maxFailExpected = [];
	            }
	            peg$maxFailExpected.push(expected);
	        }
	        function peg$buildException(message, expected, found, location) {
	            function cleanupExpected(expected) {
	                var i = 1;
	                expected.sort(function (a, b) {
	                    if (a.description < b.description) {
	                        return -1;
	                    }
	                    else if (a.description > b.description) {
	                        return 1;
	                    }
	                    else {
	                        return 0;
	                    }
	                });
	                while (i < expected.length) {
	                    if (expected[i - 1] === expected[i]) {
	                        expected.splice(i, 1);
	                    }
	                    else {
	                        i++;
	                    }
	                }
	            }
	            function buildMessage(expected, found) {
	                function stringEscape(s) {
	                    function hex(ch) {
	                        return ch.charCodeAt(0).toString(16).toUpperCase();
	                    }
	                    return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (ch) {
	                        return '\\x0' + hex(ch);
	                    }).replace(/[\x10-\x1F\x80-\xFF]/g, function (ch) {
	                        return '\\x' + hex(ch);
	                    }).replace(/[\u0100-\u0FFF]/g, function (ch) {
	                        return '\\u0' + hex(ch);
	                    }).replace(/[\u1000-\uFFFF]/g, function (ch) {
	                        return '\\u' + hex(ch);
	                    });
	                }
	                var expectedDescs = new Array(expected.length), expectedDesc, foundDesc, i;
	                for (i = 0; i < expected.length; i++) {
	                    expectedDescs[i] = expected[i].description;
	                }
	                expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];
	                foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
	                return "Expected " + expectedDesc + " but " + foundDesc + " found.";
	            }
	            if (expected !== null) {
	                cleanupExpected(expected);
	            }
	            return new peg$SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, location);
	        }
	        function peg$parseSignature() {
	            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
	            s0 = peg$currPos;
	            s1 = peg$parse_();
	            if (s1 !== peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 40) {
	                    s2 = peg$c0;
	                    peg$currPos++;
	                }
	                else {
	                    s2 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c1);
	                    }
	                }
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$parseargs();
	                    if (s3 === peg$FAILED) {
	                        s3 = null;
	                    }
	                    if (s3 !== peg$FAILED) {
	                        s4 = peg$parse_();
	                        if (s4 !== peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 41) {
	                                s5 = peg$c2;
	                                peg$currPos++;
	                            }
	                            else {
	                                s5 = peg$FAILED;
	                                if (peg$silentFails === 0) {
	                                    peg$fail(peg$c3);
	                                }
	                            }
	                            if (s5 !== peg$FAILED) {
	                                s6 = peg$parse_();
	                                if (s6 !== peg$FAILED) {
	                                    s7 = peg$currPos;
	                                    if (input.substr(peg$currPos, 2) === peg$c4) {
	                                        s8 = peg$c4;
	                                        peg$currPos += 2;
	                                    }
	                                    else {
	                                        s8 = peg$FAILED;
	                                        if (peg$silentFails === 0) {
	                                            peg$fail(peg$c5);
	                                        }
	                                    }
	                                    if (s8 !== peg$FAILED) {
	                                        s9 = peg$parseReturn();
	                                        if (s9 !== peg$FAILED) {
	                                            s8 = [s8, s9];
	                                            s7 = s8;
	                                        }
	                                        else {
	                                            peg$currPos = s7;
	                                            s7 = peg$FAILED;
	                                        }
	                                    }
	                                    else {
	                                        peg$currPos = s7;
	                                        s7 = peg$FAILED;
	                                    }
	                                    if (s7 === peg$FAILED) {
	                                        s7 = null;
	                                    }
	                                    if (s7 !== peg$FAILED) {
	                                        s8 = peg$parse_();
	                                        if (s8 !== peg$FAILED) {
	                                            peg$savedPos = s0;
	                                            s1 = peg$c6(s3, s7);
	                                            s0 = s1;
	                                        }
	                                        else {
	                                            peg$currPos = s0;
	                                            s0 = peg$FAILED;
	                                        }
	                                    }
	                                    else {
	                                        peg$currPos = s0;
	                                        s0 = peg$FAILED;
	                                    }
	                                }
	                                else {
	                                    peg$currPos = s0;
	                                    s0 = peg$FAILED;
	                                }
	                            }
	                            else {
	                                peg$currPos = s0;
	                                s0 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseargs() {
	            var s0, s1, s2, s3;
	            s0 = peg$currPos;
	            s1 = peg$parsearg();
	            if (s1 !== peg$FAILED) {
	                s2 = [];
	                s3 = peg$parseextraArg();
	                while (s3 !== peg$FAILED) {
	                    s2.push(s3);
	                    s3 = peg$parseextraArg();
	                }
	                if (s2 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c7(s1, s2);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseextraArg() {
	            var s0, s1, s2, s3, s4;
	            s0 = peg$currPos;
	            s1 = peg$parse_();
	            if (s1 !== peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 44) {
	                    s2 = peg$c8;
	                    peg$currPos++;
	                }
	                else {
	                    s2 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c9);
	                    }
	                }
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$parse_();
	                    if (s3 !== peg$FAILED) {
	                        s4 = peg$parsearg();
	                        if (s4 !== peg$FAILED) {
	                            peg$savedPos = s0;
	                            s1 = peg$c10(s4);
	                            s0 = s1;
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parsearg() {
	            var s0, s1, s2, s3, s4;
	            s0 = peg$currPos;
	            s1 = [];
	            s2 = peg$parsechar();
	            while (s2 !== peg$FAILED) {
	                s1.push(s2);
	                s2 = peg$parsechar();
	            }
	            if (s1 !== peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 63) {
	                    s2 = peg$c11;
	                    peg$currPos++;
	                }
	                else {
	                    s2 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c12);
	                    }
	                }
	                if (s2 === peg$FAILED) {
	                    s2 = null;
	                }
	                if (s2 !== peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 58) {
	                        s3 = peg$c13;
	                        peg$currPos++;
	                    }
	                    else {
	                        s3 = peg$FAILED;
	                        if (peg$silentFails === 0) {
	                            peg$fail(peg$c14);
	                        }
	                    }
	                    if (s3 !== peg$FAILED) {
	                        s4 = peg$parseTerm();
	                        if (s4 !== peg$FAILED) {
	                            peg$savedPos = s0;
	                            s1 = peg$c15(s1, s2, s4);
	                            s0 = s1;
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseReturn() {
	            var s0;
	            s0 = peg$parseCode();
	            if (s0 === peg$FAILED) {
	                s0 = peg$parseTerm();
	            }
	            return s0;
	        }
	        function peg$parseCode() {
	            var s0, s1, s2, s3, s4, s5;
	            s0 = peg$currPos;
	            s1 = peg$parse_();
	            if (s1 !== peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 123) {
	                    s2 = peg$c16;
	                    peg$currPos++;
	                }
	                else {
	                    s2 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c17);
	                    }
	                }
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$parseResponseAndType();
	                    if (s3 !== peg$FAILED) {
	                        s4 = [];
	                        s5 = peg$parseCommaAndResponse();
	                        while (s5 !== peg$FAILED) {
	                            s4.push(s5);
	                            s5 = peg$parseCommaAndResponse();
	                        }
	                        if (s4 !== peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 125) {
	                                s5 = peg$c18;
	                                peg$currPos++;
	                            }
	                            else {
	                                s5 = peg$FAILED;
	                                if (peg$silentFails === 0) {
	                                    peg$fail(peg$c19);
	                                }
	                            }
	                            if (s5 !== peg$FAILED) {
	                                peg$savedPos = s0;
	                                s1 = peg$c20(s3, s4);
	                                s0 = s1;
	                            }
	                            else {
	                                peg$currPos = s0;
	                                s0 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseCommaAndResponse() {
	            var s0, s1, s2;
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 44) {
	                s1 = peg$c8;
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c9);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parseResponseAndType();
	                if (s2 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c21(s2);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseResponseAndType() {
	            var s0, s1, s2, s3, s4, s5;
	            s0 = peg$currPos;
	            s1 = peg$parsechar();
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parsechar();
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$parsechar();
	                    if (s3 !== peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 58) {
	                            s4 = peg$c13;
	                            peg$currPos++;
	                        }
	                        else {
	                            s4 = peg$FAILED;
	                            if (peg$silentFails === 0) {
	                                peg$fail(peg$c14);
	                            }
	                        }
	                        if (s4 !== peg$FAILED) {
	                            s5 = peg$parseTerm();
	                            if (s5 !== peg$FAILED) {
	                                peg$savedPos = s0;
	                                s1 = peg$c22(s1, s2, s3, s5);
	                                s0 = s1;
	                            }
	                            else {
	                                peg$currPos = s0;
	                                s0 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseTerm() {
	            var s0, s1, s2, s3, s4, s5, s6, s7;
	            s0 = peg$currPos;
	            s1 = peg$parse_();
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parseFactor();
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$currPos;
	                    s4 = peg$parse_();
	                    if (s4 !== peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 124) {
	                            s5 = peg$c23;
	                            peg$currPos++;
	                        }
	                        else {
	                            s5 = peg$FAILED;
	                            if (peg$silentFails === 0) {
	                                peg$fail(peg$c24);
	                            }
	                        }
	                        if (s5 !== peg$FAILED) {
	                            s6 = peg$parse_();
	                            if (s6 !== peg$FAILED) {
	                                s7 = peg$parseTerm();
	                                if (s7 !== peg$FAILED) {
	                                    s4 = [s4, s5, s6, s7];
	                                    s3 = s4;
	                                }
	                                else {
	                                    peg$currPos = s3;
	                                    s3 = peg$FAILED;
	                                }
	                            }
	                            else {
	                                peg$currPos = s3;
	                                s3 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s3;
	                            s3 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                    if (s3 === peg$FAILED) {
	                        s3 = null;
	                    }
	                    if (s3 !== peg$FAILED) {
	                        peg$savedPos = s0;
	                        s1 = peg$c25(s2, s3);
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseFactor() {
	            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 40) {
	                s1 = peg$c0;
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c1);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parse_();
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$parseTerm();
	                    if (s3 !== peg$FAILED) {
	                        s4 = peg$parse_();
	                        if (s4 !== peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 41) {
	                                s5 = peg$c2;
	                                peg$currPos++;
	                            }
	                            else {
	                                s5 = peg$FAILED;
	                                if (peg$silentFails === 0) {
	                                    peg$fail(peg$c3);
	                                }
	                            }
	                            if (s5 !== peg$FAILED) {
	                                s6 = [];
	                                s7 = peg$currPos;
	                                s8 = peg$parse_();
	                                if (s8 !== peg$FAILED) {
	                                    if (input.substr(peg$currPos, 2) === peg$c26) {
	                                        s9 = peg$c26;
	                                        peg$currPos += 2;
	                                    }
	                                    else {
	                                        s9 = peg$FAILED;
	                                        if (peg$silentFails === 0) {
	                                            peg$fail(peg$c27);
	                                        }
	                                    }
	                                    if (s9 !== peg$FAILED) {
	                                        s8 = [s8, s9];
	                                        s7 = s8;
	                                    }
	                                    else {
	                                        peg$currPos = s7;
	                                        s7 = peg$FAILED;
	                                    }
	                                }
	                                else {
	                                    peg$currPos = s7;
	                                    s7 = peg$FAILED;
	                                }
	                                while (s7 !== peg$FAILED) {
	                                    s6.push(s7);
	                                    s7 = peg$currPos;
	                                    s8 = peg$parse_();
	                                    if (s8 !== peg$FAILED) {
	                                        if (input.substr(peg$currPos, 2) === peg$c26) {
	                                            s9 = peg$c26;
	                                            peg$currPos += 2;
	                                        }
	                                        else {
	                                            s9 = peg$FAILED;
	                                            if (peg$silentFails === 0) {
	                                                peg$fail(peg$c27);
	                                            }
	                                        }
	                                        if (s9 !== peg$FAILED) {
	                                            s8 = [s8, s9];
	                                            s7 = s8;
	                                        }
	                                        else {
	                                            peg$currPos = s7;
	                                            s7 = peg$FAILED;
	                                        }
	                                    }
	                                    else {
	                                        peg$currPos = s7;
	                                        s7 = peg$FAILED;
	                                    }
	                                }
	                                if (s6 !== peg$FAILED) {
	                                    peg$savedPos = s0;
	                                    s1 = peg$c28(s3, s6);
	                                    s0 = s1;
	                                }
	                                else {
	                                    peg$currPos = s0;
	                                    s0 = peg$FAILED;
	                                }
	                            }
	                            else {
	                                peg$currPos = s0;
	                                s0 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            if (s0 === peg$FAILED) {
	                s0 = peg$parseLiteral();
	            }
	            return s0;
	        }
	        function peg$parseTypeParams() {
	            var s0, s1, s2, s3, s4;
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 60) {
	                s1 = peg$c29;
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c30);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parseTerm();
	                if (s2 !== peg$FAILED) {
	                    s3 = [];
	                    s4 = peg$parseExtraParam();
	                    while (s4 !== peg$FAILED) {
	                        s3.push(s4);
	                        s4 = peg$parseExtraParam();
	                    }
	                    if (s3 !== peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 62) {
	                            s4 = peg$c31;
	                            peg$currPos++;
	                        }
	                        else {
	                            s4 = peg$FAILED;
	                            if (peg$silentFails === 0) {
	                                peg$fail(peg$c32);
	                            }
	                        }
	                        if (s4 !== peg$FAILED) {
	                            peg$savedPos = s0;
	                            s1 = peg$c33(s2, s3);
	                            s0 = s1;
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseExtraParam() {
	            var s0, s1, s2;
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 44) {
	                s1 = peg$c8;
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c9);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parseTerm();
	                if (s2 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c10(s2);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseLiteral() {
	            var s0, s1, s2, s3, s4, s5, s6;
	            peg$silentFails++;
	            s0 = peg$currPos;
	            s1 = [];
	            s2 = peg$parsechar();
	            if (s2 !== peg$FAILED) {
	                while (s2 !== peg$FAILED) {
	                    s1.push(s2);
	                    s2 = peg$parsechar();
	                }
	            }
	            else {
	                s1 = peg$FAILED;
	            }
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parseTypeParams();
	                if (s2 === peg$FAILED) {
	                    s2 = null;
	                }
	                if (s2 !== peg$FAILED) {
	                    s3 = [];
	                    s4 = peg$currPos;
	                    s5 = peg$parse_();
	                    if (s5 !== peg$FAILED) {
	                        if (input.substr(peg$currPos, 2) === peg$c26) {
	                            s6 = peg$c26;
	                            peg$currPos += 2;
	                        }
	                        else {
	                            s6 = peg$FAILED;
	                            if (peg$silentFails === 0) {
	                                peg$fail(peg$c27);
	                            }
	                        }
	                        if (s6 !== peg$FAILED) {
	                            s5 = [s5, s6];
	                            s4 = s5;
	                        }
	                        else {
	                            peg$currPos = s4;
	                            s4 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s4;
	                        s4 = peg$FAILED;
	                    }
	                    while (s4 !== peg$FAILED) {
	                        s3.push(s4);
	                        s4 = peg$currPos;
	                        s5 = peg$parse_();
	                        if (s5 !== peg$FAILED) {
	                            if (input.substr(peg$currPos, 2) === peg$c26) {
	                                s6 = peg$c26;
	                                peg$currPos += 2;
	                            }
	                            else {
	                                s6 = peg$FAILED;
	                                if (peg$silentFails === 0) {
	                                    peg$fail(peg$c27);
	                                }
	                            }
	                            if (s6 !== peg$FAILED) {
	                                s5 = [s5, s6];
	                                s4 = s5;
	                            }
	                            else {
	                                peg$currPos = s4;
	                                s4 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s4;
	                            s4 = peg$FAILED;
	                        }
	                    }
	                    if (s3 !== peg$FAILED) {
	                        peg$savedPos = s0;
	                        s1 = peg$c35(s1, s2, s3);
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            peg$silentFails--;
	            if (s0 === peg$FAILED) {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c34);
	                }
	            }
	            return s0;
	        }
	        function peg$parse_() {
	            var s0, s1;
	            peg$silentFails++;
	            s0 = [];
	            if (peg$c37.test(input.charAt(peg$currPos))) {
	                s1 = input.charAt(peg$currPos);
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c38);
	                }
	            }
	            while (s1 !== peg$FAILED) {
	                s0.push(s1);
	                if (peg$c37.test(input.charAt(peg$currPos))) {
	                    s1 = input.charAt(peg$currPos);
	                    peg$currPos++;
	                }
	                else {
	                    s1 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c38);
	                    }
	                }
	            }
	            peg$silentFails--;
	            if (s0 === peg$FAILED) {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c36);
	                }
	            }
	            return s0;
	        }
	        function peg$parsechar() {
	            var s0;
	            if (peg$c39.test(input.charAt(peg$currPos))) {
	                s0 = input.charAt(peg$currPos);
	                peg$currPos++;
	            }
	            else {
	                s0 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c40);
	                }
	            }
	            if (s0 === peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 95) {
	                    s0 = peg$c41;
	                    peg$currPos++;
	                }
	                else {
	                    s0 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c42);
	                    }
	                }
	                if (s0 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 45) {
	                        s0 = peg$c43;
	                        peg$currPos++;
	                    }
	                    else {
	                        s0 = peg$FAILED;
	                        if (peg$silentFails === 0) {
	                            peg$fail(peg$c44);
	                        }
	                    }
	                    if (s0 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 46) {
	                            s0 = peg$c45;
	                            peg$currPos++;
	                        }
	                        else {
	                            s0 = peg$FAILED;
	                            if (peg$silentFails === 0) {
	                                peg$fail(peg$c46);
	                            }
	                        }
	                        if (s0 === peg$FAILED) {
	                            if (peg$c47.test(input.charAt(peg$currPos))) {
	                                s0 = input.charAt(peg$currPos);
	                                peg$currPos++;
	                            }
	                            else {
	                                s0 = peg$FAILED;
	                                if (peg$silentFails === 0) {
	                                    peg$fail(peg$c48);
	                                }
	                            }
	                            if (s0 === peg$FAILED) {
	                                if (peg$c49.test(input.charAt(peg$currPos))) {
	                                    s0 = input.charAt(peg$currPos);
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s0 = peg$FAILED;
	                                    if (peg$silentFails === 0) {
	                                        peg$fail(peg$c50);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            return s0;
	        }
	        peg$result = peg$startRuleFunction();
	        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	            return peg$result;
	        }
	        else {
	            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
	                peg$fail({ type: "end", description: "end of input" });
	            }
	            throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
	        }
	    }
	    return {
	        SyntaxError: peg$SyntaxError,
	        parse: peg$parse
	    };
	})();
	module.exports = parser;
	//# sourceMappingURL=ramlSignatureParser.js.map

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	var ramlSanitize = __webpack_require__(82);
	var ramlValidate = __webpack_require__(83);
	var REGEXP_MATCH = {
	    number: '[-+]?\\d+(?:\\.\\d+)?',
	    integer: '[-+]?\\d+',
	    date: '(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d{2} (?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d{4} (?:[0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d GMT',
	    boolean: '(?:true|false)'
	};
	var ESCAPE_CHARACTERS = /([.*+?=^!:${}()|[\]\/\\])/g;
	var REGEXP_REPLACE = new RegExp([
	    '([.\\/])?\\{([^}]+)\\}',
	    ESCAPE_CHARACTERS.source
	].join('|'), 'g');
	function toRegExp(path, parameters, keys, options) {
	    var end = options.end !== false;
	    var strict = options.strict;
	    var flags = '';
	    if (!options.sensitive) {
	        flags += 'i';
	    }
	    var route = path.replace(REGEXP_REPLACE, function (match, prefix, key, escape) {
	        if (escape) {
	            return '\\' + escape;
	        }
	        // Push the current key into the keys array.
	        keys.push({
	            name: key,
	            prefix: prefix || '/'
	        });
	        prefix = prefix ? '\\' + prefix : '';
	        // TODO: Support an array of parameters.
	        var param = parameters[key];
	        var capture = param && REGEXP_MATCH[param.type] || '[^' + (prefix || '\\/') + ']+';
	        var optional = param && param.required === false;
	        if (Array.isArray(param.enum) && param.enum.length) {
	            capture = '(?:' + param.enum.map(function (value) {
	                return String(value).replace(ESCAPE_CHARACTERS, '\\$1');
	            }).join('|') + ')';
	        }
	        return prefix + '(' + capture + ')' + (optional ? '?' : '');
	    });
	    var endsWithSlash = path.charAt(path.length - 1) === '/';
	    // In non-strict mode we allow a slash at the end of match. If the path to
	    // match already ends with a slash, we remove it for consistency. The slash
	    // is valid at the end of a path match, not in the middle. This is important
	    // in non-ending mode, where "/test/" shouldn't match "/test//route".
	    if (!strict) {
	        route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
	    }
	    if (end) {
	        route += '$';
	    }
	    else {
	        // In non-ending mode, we need the capturing groups to match as much as
	        // possible by using a positive lookahead to the end or next path segment.
	        route += strict && endsWithSlash ? '' : '(?=\\/|$)';
	    }
	    return new RegExp('^' + route + (end ? '$' : ''), flags);
	}
	function decodeParam(param) {
	    try {
	        return decodeURIComponent(param);
	    }
	    catch (_) {
	        var err = new Error('Failed to decode param "' + param + '"');
	        err.status = 400;
	        throw err;
	    }
	}
	function ramlPathMatch(path, parameters, options) {
	    options = options || {};
	    if (path === '/' && options.end === false) {
	        return truth;
	    }
	    parameters = parameters || {};
	    var keys = [];
	    var re = toRegExp(path, parameters, keys, options);
	    var sanitize = ramlSanitize()(parameters);
	    var validate = ramlValidate()(parameters);
	    return function (pathname) {
	        var m = re.exec(pathname);
	        if (!m) {
	            return false;
	        }
	        if (parameters['mediaTypeExtension']) {
	            if (m.length > 1 && !m[m.length - 1]) {
	                var beforeLast = m[m.length - 2];
	                var ind = beforeLast.lastIndexOf('.');
	                if (ind >= 0) {
	                    m[m.length - 2] = beforeLast.substring(0, ind);
	                    m[m.length - 1] = beforeLast.substring(ind);
	                }
	            }
	        }
	        var path = m[0];
	        var params = {};
	        for (var i = 1; i < m.length; i++) {
	            var key = keys[i - 1];
	            var param = m[i];
	            params[key.name] = param == null ? param : decodeParam(param);
	        }
	        params = sanitize(params);
	        if (!validate(params).valid) {
	            return false;
	        }
	        return {
	            path: path,
	            params: params
	        };
	    };
	}
	function truth(path) {
	    return { path: '', params: {} };
	}
	module.exports = ramlPathMatch;
	//# sourceMappingURL=raml-path-match.js.map

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	var xmlutil = __webpack_require__(70);
	var lru = __webpack_require__(79);
	var ZSchema = __webpack_require__(78);
	var ValidationResult = (function () {
	    function ValidationResult() {
	    }
	    return ValidationResult;
	})();
	exports.ValidationResult = ValidationResult;
	var globalCache = lru(400);
	var useLint = true;
	var JSONSchemaObject = (function () {
	    function JSONSchemaObject(schema) {
	        this.schema = schema;
	        if (!schema || schema.trim().length == 0 || schema.trim().charAt(0) != '{') {
	            throw new Error("Invalid JSON schema content");
	        }
	        var jsonSchemaObject;
	        try {
	            var jsonSchemaObject = JSON.parse(schema);
	        }
	        catch (err) {
	            throw new Error("It is not JSON schema");
	        }
	        if (!jsonSchemaObject) {
	            return;
	        }
	        try {
	            var api = __webpack_require__(104);
	            jsonSchemaObject = api.v4(jsonSchemaObject);
	        }
	        catch (e) {
	            throw new Error('Can not parse schema' + schema);
	        }
	        delete jsonSchemaObject['$schema'];
	        delete jsonSchemaObject['required'];
	        this.jsonSchema = jsonSchemaObject;
	    }
	    JSONSchemaObject.prototype.getType = function () {
	        return "source.json";
	    };
	    JSONSchemaObject.prototype.validateObject = function (object) {
	        //TODO Validation of objects
	        //xmlutil(content);
	        this.validate(JSON.stringify(object));
	    };
	    JSONSchemaObject.prototype.validate = function (content) {
	        var key = content + this.schema;
	        var c = globalCache.get(key);
	        if (c) {
	            if (c instanceof Error) {
	                throw c;
	            }
	            return;
	        }
	        var validator = new ZSchema();
	        var valid = validator.validate(JSON.parse(content), this.jsonSchema);
	        var errors = validator.getLastErrors();
	        if (errors && errors.length > 0) {
	            var res = new Error("Content is not valid according to schema:" + errors.map(function (x) { return x.message + " " + x.params; }).join(", "));
	            res.errors = errors;
	            globalCache.set(key, res);
	            throw res;
	        }
	        globalCache.set(key, 1);
	    };
	    return JSONSchemaObject;
	})();
	exports.JSONSchemaObject = JSONSchemaObject;
	var XMLSchemaObject = (function () {
	    function XMLSchemaObject(schema) {
	        this.schema = schema;
	        if (schema.charAt(0) != '<') {
	            throw new Error("Invalid JSON schema");
	        }
	        xmlutil(schema);
	    }
	    XMLSchemaObject.prototype.getType = function () {
	        return "text.xml";
	    };
	    XMLSchemaObject.prototype.validate = function (content) {
	        xmlutil(content);
	    };
	    XMLSchemaObject.prototype.validateObject = function (object) {
	        //TODO Validation of objects
	        //xmlutil(content);
	    };
	    return XMLSchemaObject;
	})();
	exports.XMLSchemaObject = XMLSchemaObject;
	function getJSONSchema(content) {
	    var rs = useLint ? globalCache.get(content) : false;
	    if (rs) {
	        return rs;
	    }
	    var res = new JSONSchemaObject(content);
	    globalCache.set(content, res);
	    return res;
	}
	exports.getJSONSchema = getJSONSchema;
	function getXMLSchema(content) {
	    var rs = useLint ? globalCache.get(content) : false;
	    if (rs) {
	        return rs;
	    }
	    var res = new XMLSchemaObject(content);
	    if (useLint) {
	        globalCache.set(content, res);
	    }
	}
	exports.getXMLSchema = getXMLSchema;
	function createSchema(content) {
	    var rs = useLint ? globalCache.get(content) : false;
	    if (rs) {
	        return rs;
	    }
	    try {
	        var res = new JSONSchemaObject(content);
	        if (useLint) {
	            globalCache.set(content, res);
	        }
	        return res;
	    }
	    catch (e) {
	        try {
	            var res = new XMLSchemaObject(content);
	            if (useLint) {
	                globalCache.set(content, res);
	            }
	            return res;
	        }
	        catch (e) {
	            if (useLint) {
	                globalCache.set(content, new Error("Can not parse schema"));
	            }
	            return null;
	        }
	    }
	}
	exports.createSchema = createSchema;
	//# sourceMappingURL=schemaUtil.js.map

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	var __extends = this.__extends || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var _ = __webpack_require__(47);
	var sel = __webpack_require__(85);
	var Selector = (function () {
	    function Selector() {
	    }
	    Selector.prototype.candidates = function (context) {
	        return context;
	    };
	    Selector.prototype.apply = function (h) {
	        return this.candidates([h]);
	    };
	    return Selector;
	})();
	exports.Selector = Selector;
	var OrMatch = (function (_super) {
	    __extends(OrMatch, _super);
	    function OrMatch(left, right) {
	        _super.call(this);
	        this.left = left;
	        this.right = right;
	    }
	    OrMatch.prototype.candidates = function (context) {
	        var l = this.left.candidates(context);
	        l = l.concat(this.right.candidates(context));
	        return _.unique(l);
	    };
	    return OrMatch;
	})(Selector);
	exports.OrMatch = OrMatch;
	var DotMatch = (function (_super) {
	    __extends(DotMatch, _super);
	    function DotMatch(left, right) {
	        _super.call(this);
	        this.left = left;
	        this.right = right;
	    }
	    DotMatch.prototype.candidates = function (context) {
	        var l = this.left.candidates(context);
	        if (this.left instanceof AnyParentMatch) {
	            l = this.right.candidates(new AnyChildMatch().candidates(l));
	            return _.unique(l);
	        }
	        if (this.left instanceof ParentMatch) {
	            l = this.right.candidates(new AnyChildMatch().candidates(l));
	            return _.unique(l);
	        }
	        l = this.right.candidates(l);
	        return _.unique(l);
	    };
	    return DotMatch;
	})(Selector);
	exports.DotMatch = DotMatch;
	function resolveSelector(s, n) {
	    if (s.type == "or") {
	        var b = s;
	        var l = resolveSelector(b.left, n);
	        var r = resolveSelector(b.right, n);
	        return new OrMatch(l, r);
	    }
	    if (s.type == "dot") {
	        var b = s;
	        var l = resolveSelector(b.left, n);
	        var r = resolveSelector(b.right, n);
	        return new DotMatch(l, r);
	    }
	    if (s.type == 'classLiteral') {
	        var literal = s;
	        var tp = n.definition().universe().getType(literal.name);
	        if (tp == null || tp.isValueType()) {
	            throw new Error("Referencing unknown type:" + literal.name);
	        }
	        return new IdMatch(literal.name);
	    }
	    if (s.type == 'parent') {
	        return new ParentMatch();
	    }
	    if (s.type == 'ancestor') {
	        return new AnyParentMatch();
	    }
	    if (s.type == 'descendant') {
	        return new AnyChildMatch();
	    }
	    if (s.type == 'child') {
	        return new ChildMatch();
	    }
	}
	exports.resolveSelector = resolveSelector;
	var IdMatch = (function (_super) {
	    __extends(IdMatch, _super);
	    function IdMatch(name) {
	        _super.call(this);
	        this.name = name;
	    }
	    IdMatch.prototype.candidates = function (context) {
	        var _this = this;
	        return context.filter(function (x) {
	            if (!x) {
	                return false;
	            }
	            if (x.definition().name() == _this.name) {
	                return true;
	            }
	            var superTypes = x.definition().allSuperTypes();
	            if (_.find(superTypes, function (x) { return x.name() == _this.name; })) {
	                return true;
	            }
	            return false;
	        });
	    };
	    return IdMatch;
	})(Selector);
	exports.IdMatch = IdMatch;
	var AnyParentMatch = (function (_super) {
	    __extends(AnyParentMatch, _super);
	    function AnyParentMatch() {
	        _super.apply(this, arguments);
	    }
	    AnyParentMatch.prototype.candidates = function (context) {
	        var res = [];
	        context.forEach(function (x) {
	            if (x) {
	                var z = x.parent();
	                while (z) {
	                    res.push(z);
	                    z = z.parent();
	                }
	            }
	        });
	        return _.unique(res);
	    };
	    return AnyParentMatch;
	})(Selector);
	exports.AnyParentMatch = AnyParentMatch;
	function addChildren(x, r) {
	    r.push(x);
	    x.elements().forEach(function (y) { return addChildren(y, r); });
	}
	var AnyChildMatch = (function (_super) {
	    __extends(AnyChildMatch, _super);
	    function AnyChildMatch() {
	        _super.apply(this, arguments);
	    }
	    AnyChildMatch.prototype.candidates = function (context) {
	        var res = [];
	        context.forEach(function (x) {
	            if (x) {
	                addChildren(x, res);
	            }
	        });
	        return _.unique(res);
	    };
	    return AnyChildMatch;
	})(Selector);
	exports.AnyChildMatch = AnyChildMatch;
	var ParentMatch = (function (_super) {
	    __extends(ParentMatch, _super);
	    function ParentMatch() {
	        _super.apply(this, arguments);
	    }
	    ParentMatch.prototype.candidates = function (context) {
	        return context.map(function (x) { return x.parent(); });
	    };
	    return ParentMatch;
	})(Selector);
	exports.ParentMatch = ParentMatch;
	var ChildMatch = (function (_super) {
	    __extends(ChildMatch, _super);
	    function ChildMatch() {
	        _super.apply(this, arguments);
	    }
	    ChildMatch.prototype.candidates = function (context) {
	        var res = [];
	        context.forEach(function (x) {
	            if (x) {
	                res = res.concat(x.elements());
	            }
	        });
	        return res;
	    };
	    return ChildMatch;
	})(Selector);
	exports.ChildMatch = ChildMatch;
	function parse(h, path) {
	    return resolveSelector(sel.parse(path), h);
	}
	exports.parse = parse;
	//# sourceMappingURL=selectorMatch.js.map

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	var ramlExpression = __webpack_require__(84);
	var search = __webpack_require__(35);
	function validate(str, node) {
	    var result = ramlExpression.parse(str);
	    validateNode(result, node);
	}
	exports.validate = validate;
	function validateNode(r, node) {
	    if (r.type == "unary") {
	        var u = r;
	        validateNode(u.exp, node);
	    }
	    else if (r.type == 'paren') {
	        var ex = r;
	        validateNode(ex.exp, node);
	    }
	    else if (r.type == 'string' || r.type == 'number') {
	    }
	    else if (r.type == 'ident') {
	        var ident = r;
	        var p = search.resolveRamlPointer(node, ident.value);
	        if (!p) {
	            throw new Error("Unable to resolve " + ident.value);
	        }
	    }
	    else {
	        var be = r;
	        validateNode(be.l, node);
	        validateNode(be.r, node);
	    }
	}
	//# sourceMappingURL=ramlExpressions.js.map

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../typings/tsd.d.ts" />
	'use strict';
	function isNothing(subject) {
	    return (typeof subject === 'undefined') || (null === subject);
	}
	exports.isNothing = isNothing;
	function isObject(subject) {
	    return (typeof subject === 'object') && (null !== subject);
	}
	exports.isObject = isObject;
	function toArray(sequence) {
	    if (Array.isArray(sequence)) {
	        return sequence;
	    }
	    else if (isNothing(sequence)) {
	        return [];
	    }
	    return [sequence];
	}
	exports.toArray = toArray;
	function extend(target, source) {
	    var index, length, key, sourceKeys;
	    if (source) {
	        sourceKeys = Object.keys(source);
	        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
	            key = sourceKeys[index];
	            target[key] = source[key];
	        }
	    }
	    return target;
	}
	exports.extend = extend;
	function repeat(string, count) {
	    var result = '', cycle;
	    for (cycle = 0; cycle < count; cycle += 1) {
	        result += string;
	    }
	    return result;
	}
	exports.repeat = repeat;
	function isNegativeZero(number) {
	    return (0 === number) && (Number.NEGATIVE_INFINITY === 1 / number);
	}
	exports.isNegativeZero = isNegativeZero;
	//# sourceMappingURL=common.js.map

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	// JS-YAML's default schema for `load` function.
	// It is not described in the YAML specification.
	//
	// This schema is based on JS-YAML's default safe schema and includes
	// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
	//
	// Also this schema is used as default base schema at `Schema.create` function.
	'use strict';
	var Schema = __webpack_require__(62);
	var schema = new Schema({
	    include: [
	        __webpack_require__(59)
	    ],
	    explicit: [
	        __webpack_require__(86),
	        __webpack_require__(87),
	        __webpack_require__(88)
	    ]
	});
	Schema.DEFAULT = schema;
	module.exports = schema;
	//# sourceMappingURL=default_full.js.map

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	// JS-YAML's default schema for `safeLoad` function.
	// It is not described in the YAML specification.
	//
	// This schema is based on standard YAML's Core schema and includes most of
	// extra types described at YAML tag repository. (http://yaml.org/type/)
	'use strict';
	var Schema = __webpack_require__(62);
	var schema = new Schema({
	    include: [
	        __webpack_require__(65)
	    ],
	    implicit: [
	        __webpack_require__(89),
	        __webpack_require__(90)
	    ],
	    explicit: [
	        __webpack_require__(91),
	        __webpack_require__(92),
	        __webpack_require__(93),
	        __webpack_require__(94)
	    ]
	});
	module.exports = schema;
	//# sourceMappingURL=default_safe.js.map

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../typings/tsd.d.ts" />
	var ast = __webpack_require__(19);
	'use strict';
	/*eslint-disable max-len,no-use-before-define*/
	var common = __webpack_require__(57);
	var YAMLException = __webpack_require__(28);
	var Mark = __webpack_require__(102);
	var DEFAULT_SAFE_SCHEMA = __webpack_require__(59);
	var DEFAULT_FULL_SCHEMA = __webpack_require__(58);
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	var CONTEXT_FLOW_IN = 1;
	var CONTEXT_FLOW_OUT = 2;
	var CONTEXT_BLOCK_IN = 3;
	var CONTEXT_BLOCK_OUT = 4;
	var CHOMPING_CLIP = 1;
	var CHOMPING_STRIP = 2;
	var CHOMPING_KEEP = 3;
	var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uD800-\uDFFF\uFFFE\uFFFF]/;
	var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
	var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
	var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
	var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
	function is_EOL(c) {
	    return (c === 0x0A) || (c === 0x0D);
	}
	function is_WHITE_SPACE(c) {
	    return (c === 0x09) || (c === 0x20);
	}
	function is_WS_OR_EOL(c) {
	    return (c === 0x09) || (c === 0x20) || (c === 0x0A) || (c === 0x0D);
	}
	function is_FLOW_INDICATOR(c) {
	    return 0x2C === c || 0x5B === c || 0x5D === c || 0x7B === c || 0x7D === c;
	}
	function fromHexCode(c) {
	    var lc;
	    if ((0x30 <= c) && (c <= 0x39)) {
	        return c - 0x30;
	    }
	    /*eslint-disable no-bitwise*/
	    lc = c | 0x20;
	    if ((0x61 <= lc) && (lc <= 0x66)) {
	        return lc - 0x61 + 10;
	    }
	    return -1;
	}
	function escapedHexLen(c) {
	    if (c === 0x78) {
	        return 2;
	    }
	    if (c === 0x75) {
	        return 4;
	    }
	    if (c === 0x55) {
	        return 8;
	    }
	    return 0;
	}
	function fromDecimalCode(c) {
	    if ((0x30 <= c) && (c <= 0x39)) {
	        return c - 0x30;
	    }
	    return -1;
	}
	function simpleEscapeSequence(c) {
	    return (c === 0x30) ? '\x00' : (c === 0x61) ? '\x07' : (c === 0x62) ? '\x08' : (c === 0x74) ? '\x09' : (c === 0x09) ? '\x09' : (c === 0x6E) ? '\x0A' : (c === 0x76) ? '\x0B' : (c === 0x66) ? '\x0C' : (c === 0x72) ? '\x0D' : (c === 0x65) ? '\x1B' : (c === 0x20) ? ' ' : (c === 0x22) ? '\x22' : (c === 0x2F) ? '/' : (c === 0x5C) ? '\x5C' : (c === 0x4E) ? '\x85' : (c === 0x5F) ? '\xA0' : (c === 0x4C) ? '\u2028' : (c === 0x50) ? '\u2029' : '';
	}
	function charFromCodepoint(c) {
	    if (c <= 0xFFFF) {
	        return String.fromCharCode(c);
	    }
	    // Encode UTF-16 surrogate pair
	    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
	    return String.fromCharCode(((c - 0x010000) >> 10) + 0xD800, ((c - 0x010000) & 0x03FF) + 0xDC00);
	}
	var simpleEscapeCheck = new Array(256); // integer, for fast access
	var simpleEscapeMap = new Array(256);
	for (var i = 0; i < 256; i++) {
	    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
	    simpleEscapeMap[i] = simpleEscapeSequence(i);
	}
	var State = (function () {
	    function State(input, options) {
	        this.errorMap = {};
	        this.errors = [];
	        this.input = input;
	        this.filename = options['filename'] || null;
	        this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
	        this.onWarning = options['onWarning'] || null;
	        this.legacy = options['legacy'] || false;
	        this.implicitTypes = this.schema.compiledImplicit;
	        this.typeMap = this.schema.compiledTypeMap;
	        this.length = input.length;
	        this.position = 0;
	        this.line = 0;
	        this.lineStart = 0;
	        this.lineIndent = 0;
	        this.documents = [];
	    }
	    return State;
	})();
	function generateError(state, message) {
	    return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line - 1, (state.position - state.lineStart)));
	}
	function throwError(state, message) {
	    //FIXME
	    var error = generateError(state, message);
	    var hash = error.message + error.mark.position;
	    if (!state.errorMap[hash]) {
	        state.errors.push(error);
	        state.errorMap[hash] = 1;
	    }
	    var or = state.position;
	    while (true) {
	        if (state.position >= state.input.length - 1) {
	            return;
	        }
	        var c = state.input.charAt(state.position);
	        if (c == '\n') {
	            state.position--;
	            if (state.position == or) {
	                state.position += 1;
	            }
	            return;
	        }
	        if (c == '\r') {
	            state.position--;
	            if (state.position == or) {
	                state.position += 1;
	            }
	            return;
	        }
	        state.position++;
	    }
	    //throw generateError(state, message);
	}
	function throwWarning(state, message) {
	    var error = generateError(state, message);
	    if (state.onWarning) {
	        state.onWarning.call(null, error);
	    }
	    else {
	    }
	}
	var directiveHandlers = {
	    YAML: function handleYamlDirective(state, name, args) {
	        var match, major, minor;
	        if (null !== state.version) {
	            throwError(state, 'duplication of %YAML directive');
	        }
	        if (1 !== args.length) {
	            throwError(state, 'YAML directive accepts exactly one argument');
	        }
	        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
	        if (null === match) {
	            throwError(state, 'ill-formed argument of the YAML directive');
	        }
	        major = parseInt(match[1], 10);
	        minor = parseInt(match[2], 10);
	        if (1 !== major) {
	            throwError(state, 'unacceptable YAML version of the document');
	        }
	        state.version = args[0];
	        state.checkLineBreaks = (minor < 2);
	        if (1 !== minor && 2 !== minor) {
	            throwWarning(state, 'unsupported YAML version of the document');
	        }
	    },
	    TAG: function handleTagDirective(state, name, args) {
	        var handle, prefix;
	        if (2 !== args.length) {
	            throwError(state, 'TAG directive accepts exactly two arguments');
	        }
	        handle = args[0];
	        prefix = args[1];
	        if (!PATTERN_TAG_HANDLE.test(handle)) {
	            throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
	        }
	        if (_hasOwnProperty.call(state.tagMap, handle)) {
	            throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
	        }
	        if (!PATTERN_TAG_URI.test(prefix)) {
	            throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
	        }
	        state.tagMap[handle] = prefix;
	    }
	};
	function captureSegment(state, start, end, checkJson) {
	    var _position, _length, _character, _result;
	    var scalar = state.result;
	    if (scalar.startPosition == -1) {
	        scalar.startPosition = start;
	    }
	    if (start < end) {
	        _result = state.input.slice(start, end);
	        if (checkJson) {
	            for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
	                _character = _result.charCodeAt(_position);
	                if (!(0x09 === _character || 0x20 <= _character && _character <= 0x10FFFF)) {
	                    throwError(state, 'expected valid JSON character');
	                }
	            }
	        }
	        scalar.value += _result;
	        scalar.endPosition = end;
	    }
	}
	function mergeMappings(state, destination, source) {
	    var sourceKeys, key, index, quantity;
	    if (!common.isObject(source)) {
	        throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
	    }
	    sourceKeys = Object.keys(source);
	    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
	        key = sourceKeys[index];
	        if (!_hasOwnProperty.call(destination, key)) {
	            destination[key] = source[key];
	        }
	    }
	}
	function storeMappingPair(state, _result, keyTag, keyNode, valueNode) {
	    var index, quantity;
	    if (keyNode == null) {
	        return;
	    }
	    //keyNode = String(keyNode);
	    if (null === _result) {
	        _result = {
	            startPosition: keyNode.startPosition,
	            endPosition: valueNode.endPosition,
	            parent: null,
	            errors: [],
	            mappings: [],
	            kind: 2 /* MAP */
	        };
	    }
	    if ('tag:yaml.org,2002:merge' === keyTag) {
	        throw new Error("Should not happen");
	    }
	    else {
	        var mapping = ast.newMapping(keyNode, valueNode);
	        mapping.parent = _result;
	        keyNode.parent = mapping;
	        if (valueNode != null) {
	            valueNode.parent = mapping;
	        }
	        _result.mappings.push(mapping);
	        _result.endPosition = valueNode ? valueNode.endPosition : keyNode.endPosition + 1; //FIXME.workaround should be position of ':' indeed
	    }
	    return _result;
	}
	function readLineBreak(state) {
	    var ch;
	    ch = state.input.charCodeAt(state.position);
	    if (0x0A === ch) {
	        state.position++;
	    }
	    else if (0x0D === ch) {
	        state.position++;
	        if (0x0A === state.input.charCodeAt(state.position)) {
	            state.position++;
	        }
	    }
	    else {
	        throwError(state, 'a line break is expected');
	    }
	    state.line += 1;
	    state.lineStart = state.position;
	}
	function skipSeparationSpace(state, allowComments, checkIndent) {
	    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
	    while (0 !== ch) {
	        while (is_WHITE_SPACE(ch)) {
	            ch = state.input.charCodeAt(++state.position);
	        }
	        if (allowComments && 0x23 === ch) {
	            do {
	                ch = state.input.charCodeAt(++state.position);
	            } while (ch !== 0x0A && ch !== 0x0D && 0 !== ch);
	        }
	        if (is_EOL(ch)) {
	            readLineBreak(state);
	            ch = state.input.charCodeAt(state.position);
	            lineBreaks++;
	            state.lineIndent = 0;
	            while (0x20 === ch) {
	                state.lineIndent++;
	                ch = state.input.charCodeAt(++state.position);
	            }
	        }
	        else {
	            break;
	        }
	    }
	    if (-1 !== checkIndent && 0 !== lineBreaks && state.lineIndent < checkIndent) {
	        throwWarning(state, 'deficient indentation');
	    }
	    return lineBreaks;
	}
	function testDocumentSeparator(state) {
	    var _position = state.position, ch;
	    ch = state.input.charCodeAt(_position);
	    // Condition state.position === state.lineStart is tested
	    // in parent on each call, for efficiency. No needs to test here again.
	    if ((0x2D === ch || 0x2E === ch) && state.input.charCodeAt(_position + 1) === ch && state.input.charCodeAt(_position + 2) === ch) {
	        _position += 3;
	        ch = state.input.charCodeAt(_position);
	        if (ch === 0 || is_WS_OR_EOL(ch)) {
	            return true;
	        }
	    }
	    return false;
	}
	function writeFoldedLines(state, scalar, count) {
	    if (1 === count) {
	        scalar.value += ' ';
	    }
	    else if (count > 1) {
	        scalar.value += common.repeat('\n', count - 1);
	    }
	}
	function readPlainScalar(state, nodeIndent, withinFlowCollection) {
	    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
	    var state_result = ast.newScalar();
	    state.result = state_result;
	    ch = state.input.charCodeAt(state.position);
	    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || 0x23 === ch || 0x26 === ch || 0x2A === ch || 0x21 === ch || 0x7C === ch || 0x3E === ch || 0x27 === ch || 0x22 === ch || 0x25 === ch || 0x40 === ch || 0x60 === ch) {
	        return false;
	    }
	    if (0x3F === ch || 0x2D === ch) {
	        following = state.input.charCodeAt(state.position + 1);
	        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
	            return false;
	        }
	    }
	    state.kind = 'scalar';
	    //state.result = '';
	    captureStart = captureEnd = state.position;
	    hasPendingContent = false;
	    while (0 !== ch) {
	        if (0x3A === ch) {
	            following = state.input.charCodeAt(state.position + 1);
	            if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
	                break;
	            }
	        }
	        else if (0x23 === ch) {
	            preceding = state.input.charCodeAt(state.position - 1);
	            if (is_WS_OR_EOL(preceding)) {
	                break;
	            }
	        }
	        else if ((state.position === state.lineStart && testDocumentSeparator(state)) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
	            break;
	        }
	        else if (is_EOL(ch)) {
	            _line = state.line;
	            _lineStart = state.lineStart;
	            _lineIndent = state.lineIndent;
	            skipSeparationSpace(state, false, -1);
	            if (state.lineIndent >= nodeIndent) {
	                hasPendingContent = true;
	                ch = state.input.charCodeAt(state.position);
	                continue;
	            }
	            else {
	                state.position = captureEnd;
	                state.line = _line;
	                state.lineStart = _lineStart;
	                state.lineIndent = _lineIndent;
	                break;
	            }
	        }
	        if (hasPendingContent) {
	            captureSegment(state, captureStart, captureEnd, false);
	            writeFoldedLines(state, state_result, state.line - _line);
	            captureStart = captureEnd = state.position;
	            hasPendingContent = false;
	        }
	        if (!is_WHITE_SPACE(ch)) {
	            captureEnd = state.position + 1;
	        }
	        ch = state.input.charCodeAt(++state.position);
	        if (state.position >= state.input.length) {
	            return false;
	        }
	    }
	    captureSegment(state, captureStart, captureEnd, false);
	    if (state.result.startPosition != -1) {
	        return true;
	    }
	    state.kind = _kind;
	    state.result = _result;
	    return false;
	}
	function readSingleQuotedScalar(state, nodeIndent) {
	    var ch, captureStart, captureEnd;
	    ch = state.input.charCodeAt(state.position);
	    if (0x27 !== ch) {
	        return false;
	    }
	    var scalar = ast.newScalar();
	    state.kind = 'scalar';
	    state.result = scalar;
	    scalar.startPosition = state.position;
	    state.position++;
	    captureStart = captureEnd = state.position;
	    while (0 !== (ch = state.input.charCodeAt(state.position))) {
	        //console.log('ch: <' + String.fromCharCode(ch) + '>');
	        if (0x27 === ch) {
	            captureSegment(state, captureStart, state.position, true);
	            ch = state.input.charCodeAt(++state.position);
	            //console.log('next: <' + String.fromCharCode(ch) + '>');
	            scalar.endPosition = state.position;
	            if (0x27 === ch) {
	                captureStart = captureEnd = state.position;
	                state.position++;
	            }
	            else {
	                return true;
	            }
	        }
	        else if (is_EOL(ch)) {
	            captureSegment(state, captureStart, captureEnd, true);
	            writeFoldedLines(state, scalar, skipSeparationSpace(state, false, nodeIndent));
	            captureStart = captureEnd = state.position;
	        }
	        else if (state.position === state.lineStart && testDocumentSeparator(state)) {
	            throwError(state, 'unexpected end of the document within a single quoted scalar');
	        }
	        else {
	            state.position++;
	            captureEnd = state.position;
	            scalar.endPosition = state.position;
	        }
	    }
	    throwError(state, 'unexpected end of the stream within a single quoted scalar');
	}
	function readDoubleQuotedScalar(state, nodeIndent) {
	    var captureStart, captureEnd, hexLength, hexResult, tmp, tmpEsc, ch;
	    ch = state.input.charCodeAt(state.position);
	    if (0x22 !== ch) {
	        return false;
	    }
	    state.kind = 'scalar';
	    var scalar = ast.newScalar();
	    scalar.doubleQuoted = true;
	    state.result = scalar;
	    scalar.startPosition = state.position;
	    state.position++;
	    captureStart = captureEnd = state.position;
	    while (0 !== (ch = state.input.charCodeAt(state.position))) {
	        if (0x22 === ch) {
	            captureSegment(state, captureStart, state.position, true);
	            state.position++;
	            scalar.endPosition = state.position;
	            return true;
	        }
	        else if (0x5C === ch) {
	            captureSegment(state, captureStart, state.position, true);
	            ch = state.input.charCodeAt(++state.position);
	            if (is_EOL(ch)) {
	                skipSeparationSpace(state, false, nodeIndent);
	            }
	            else if (ch < 256 && simpleEscapeCheck[ch]) {
	                scalar.value += simpleEscapeMap[ch];
	                state.position++;
	            }
	            else if ((tmp = escapedHexLen(ch)) > 0) {
	                hexLength = tmp;
	                hexResult = 0;
	                for (; hexLength > 0; hexLength--) {
	                    ch = state.input.charCodeAt(++state.position);
	                    if ((tmp = fromHexCode(ch)) >= 0) {
	                        hexResult = (hexResult << 4) + tmp;
	                    }
	                    else {
	                        throwError(state, 'expected hexadecimal character');
	                    }
	                }
	                scalar.value += charFromCodepoint(hexResult);
	                state.position++;
	            }
	            else {
	                throwError(state, 'unknown escape sequence');
	            }
	            captureStart = captureEnd = state.position;
	        }
	        else if (is_EOL(ch)) {
	            captureSegment(state, captureStart, captureEnd, true);
	            writeFoldedLines(state, scalar, skipSeparationSpace(state, false, nodeIndent));
	            captureStart = captureEnd = state.position;
	        }
	        else if (state.position === state.lineStart && testDocumentSeparator(state)) {
	            throwError(state, 'unexpected end of the document within a double quoted scalar');
	        }
	        else {
	            state.position++;
	            captureEnd = state.position;
	        }
	    }
	    throwError(state, 'unexpected end of the stream within a double quoted scalar');
	}
	function readFlowCollection(state, nodeIndent) {
	    var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, keyNode, keyTag, valueNode, ch;
	    ch = state.input.charCodeAt(state.position);
	    if (ch === 0x5B) {
	        terminator = 0x5D; /* ] */
	        isMapping = false;
	        _result = ast.newItems();
	        _result.startPosition = state.position;
	    }
	    else if (ch === 0x7B) {
	        terminator = 0x7D; /* } */
	        isMapping = true;
	        _result = ast.newMap();
	        _result.startPosition = state.position;
	    }
	    else {
	        return false;
	    }
	    if (null !== state.anchor) {
	        _result.anchorId = state.anchor;
	        state.anchorMap[state.anchor] = _result;
	    }
	    ch = state.input.charCodeAt(++state.position);
	    while (0 !== ch) {
	        skipSeparationSpace(state, true, nodeIndent);
	        ch = state.input.charCodeAt(state.position);
	        if (ch === terminator) {
	            state.position++;
	            state.tag = _tag;
	            state.anchor = _anchor;
	            state.kind = isMapping ? 'mapping' : 'sequence';
	            state.result = _result;
	            _result.endPosition = state.position;
	            return true;
	        }
	        else if (!readNext) {
	            var p = state.position;
	            throwError(state, 'missed comma between flow collection entries');
	            state.position = p + 1;
	        }
	        keyTag = keyNode = valueNode = null;
	        isPair = isExplicitPair = false;
	        if (0x3F === ch) {
	            following = state.input.charCodeAt(state.position + 1);
	            if (is_WS_OR_EOL(following)) {
	                isPair = isExplicitPair = true;
	                state.position++;
	                skipSeparationSpace(state, true, nodeIndent);
	            }
	        }
	        _line = state.line;
	        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
	        keyTag = state.tag;
	        keyNode = state.result;
	        skipSeparationSpace(state, true, nodeIndent);
	        ch = state.input.charCodeAt(state.position);
	        if ((isExplicitPair || state.line === _line) && 0x3A === ch) {
	            isPair = true;
	            ch = state.input.charCodeAt(++state.position);
	            skipSeparationSpace(state, true, nodeIndent);
	            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
	            valueNode = state.result;
	        }
	        if (isMapping) {
	            storeMappingPair(state, _result, keyTag, keyNode, valueNode);
	        }
	        else if (isPair) {
	            var mp = storeMappingPair(state, null, keyTag, keyNode, valueNode);
	            mp.parent = _result;
	            _result.items.push(mp);
	        }
	        else {
	            keyNode.parent = _result;
	            _result.items.push(keyNode);
	        }
	        _result.endPosition = state.position + 1;
	        skipSeparationSpace(state, true, nodeIndent);
	        ch = state.input.charCodeAt(state.position);
	        if (0x2C === ch) {
	            readNext = true;
	            ch = state.input.charCodeAt(++state.position);
	        }
	        else {
	            readNext = false;
	        }
	    }
	    throwError(state, 'unexpected end of the stream within a flow collection');
	}
	function readBlockScalar(state, nodeIndent) {
	    var captureStart, folding, chomping = CHOMPING_CLIP, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
	    ch = state.input.charCodeAt(state.position);
	    if (ch === 0x7C) {
	        folding = false;
	    }
	    else if (ch === 0x3E) {
	        folding = true;
	    }
	    else {
	        return false;
	    }
	    var sc = ast.newScalar();
	    state.kind = 'scalar';
	    state.result = sc;
	    sc.startPosition = state.position;
	    while (0 !== ch) {
	        ch = state.input.charCodeAt(++state.position);
	        if (0x2B === ch || 0x2D === ch) {
	            if (CHOMPING_CLIP === chomping) {
	                chomping = (0x2B === ch) ? CHOMPING_KEEP : CHOMPING_STRIP;
	            }
	            else {
	                throwError(state, 'repeat of a chomping mode identifier');
	            }
	        }
	        else if ((tmp = fromDecimalCode(ch)) >= 0) {
	            if (tmp === 0) {
	                throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
	            }
	            else if (!detectedIndent) {
	                textIndent = nodeIndent + tmp - 1;
	                detectedIndent = true;
	            }
	            else {
	                throwError(state, 'repeat of an indentation width identifier');
	            }
	        }
	        else {
	            break;
	        }
	    }
	    if (is_WHITE_SPACE(ch)) {
	        do {
	            ch = state.input.charCodeAt(++state.position);
	        } while (is_WHITE_SPACE(ch));
	        if (0x23 === ch) {
	            do {
	                ch = state.input.charCodeAt(++state.position);
	            } while (!is_EOL(ch) && (0 !== ch));
	        }
	    }
	    while (0 !== ch) {
	        readLineBreak(state);
	        state.lineIndent = 0;
	        ch = state.input.charCodeAt(state.position);
	        while ((!detectedIndent || state.lineIndent < textIndent) && (0x20 === ch)) {
	            state.lineIndent++;
	            ch = state.input.charCodeAt(++state.position);
	        }
	        if (!detectedIndent && state.lineIndent > textIndent) {
	            textIndent = state.lineIndent;
	        }
	        if (is_EOL(ch)) {
	            emptyLines++;
	            continue;
	        }
	        // End of the scalar.
	        if (state.lineIndent < textIndent) {
	            // Perform the chomping.
	            if (chomping === CHOMPING_KEEP) {
	                sc.value += common.repeat('\n', emptyLines);
	            }
	            else if (chomping === CHOMPING_CLIP) {
	                if (detectedIndent) {
	                    sc.value += '\n';
	                }
	            }
	            break;
	        }
	        // Folded style: use fancy rules to handle line breaks.
	        if (folding) {
	            // Lines starting with white space characters (more-indented lines) are not folded.
	            if (is_WHITE_SPACE(ch)) {
	                atMoreIndented = true;
	                sc.value += common.repeat('\n', emptyLines + 1);
	            }
	            else if (atMoreIndented) {
	                atMoreIndented = false;
	                sc.value += common.repeat('\n', emptyLines + 1);
	            }
	            else if (0 === emptyLines) {
	                if (detectedIndent) {
	                    sc.value += ' ';
	                }
	            }
	            else {
	                sc.value += common.repeat('\n', emptyLines);
	            }
	        }
	        else if (detectedIndent) {
	            // If current line isn't the first one - count line break from the last content line.
	            sc.value += common.repeat('\n', emptyLines + 1);
	        }
	        else {
	        }
	        detectedIndent = true;
	        emptyLines = 0;
	        captureStart = state.position;
	        while (!is_EOL(ch) && (0 !== ch)) {
	            ch = state.input.charCodeAt(++state.position);
	        }
	        captureSegment(state, captureStart, state.position, false);
	    }
	    sc.endPosition = state.position;
	    var i = state.position - 1;
	    var needMinus = false;
	    while (true) {
	        var c = state.input[i];
	        if (c == '\r' || c == '\n') {
	            if (needMinus) {
	                i--;
	            }
	            break;
	        }
	        if (c != ' ' && c != '\t') {
	            break;
	        }
	        i--;
	    }
	    sc.endPosition = i;
	    return true;
	}
	function readBlockSequence(state, nodeIndent) {
	    var _line, _tag = state.tag, _anchor = state.anchor, _result = ast.newItems(), following, detected = false, ch;
	    if (null !== state.anchor) {
	        _result.anchorId = state.anchor;
	        state.anchorMap[state.anchor] = _result;
	    }
	    _result.startPosition = state.position;
	    ch = state.input.charCodeAt(state.position);
	    while (0 !== ch) {
	        if (0x2D !== ch) {
	            break;
	        }
	        following = state.input.charCodeAt(state.position + 1);
	        if (!is_WS_OR_EOL(following)) {
	            break;
	        }
	        detected = true;
	        state.position++;
	        if (skipSeparationSpace(state, true, -1)) {
	            if (state.lineIndent <= nodeIndent) {
	                _result.items.push(null);
	                ch = state.input.charCodeAt(state.position);
	                continue;
	            }
	        }
	        _line = state.line;
	        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
	        state.result.parent = _result;
	        _result.items.push(state.result);
	        skipSeparationSpace(state, true, -1);
	        ch = state.input.charCodeAt(state.position);
	        if ((state.line === _line || state.lineIndent > nodeIndent) && (0 !== ch)) {
	            throwError(state, 'bad indentation of a sequence entry');
	        }
	        else if (state.lineIndent < nodeIndent) {
	            break;
	        }
	    }
	    _result.endPosition = state.position;
	    if (detected) {
	        state.tag = _tag;
	        state.anchor = _anchor;
	        state.kind = 'sequence';
	        state.result = _result;
	        _result.endPosition = state.position;
	        return true;
	    }
	    return false;
	}
	function readBlockMapping(state, nodeIndent, flowIndent) {
	    var following, allowCompact, _line, _tag = state.tag, _anchor = state.anchor, _result = ast.newMap(), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
	    _result.startPosition = state.position;
	    if (null !== state.anchor) {
	        _result.anchorId = state.anchor;
	        state.anchorMap[state.anchor] = _result;
	    }
	    ch = state.input.charCodeAt(state.position);
	    while (0 !== ch) {
	        following = state.input.charCodeAt(state.position + 1);
	        _line = state.line; // Save the current line.
	        //
	        // Explicit notation case. There are two separate blocks:
	        // first for the key (denoted by "?") and second for the value (denoted by ":")
	        //
	        if ((0x3F === ch || 0x3A === ch) && is_WS_OR_EOL(following)) {
	            if (0x3F === ch) {
	                if (atExplicitKey) {
	                    storeMappingPair(state, _result, keyTag, keyNode, null);
	                    keyTag = keyNode = valueNode = null;
	                }
	                detected = true;
	                atExplicitKey = true;
	                allowCompact = true;
	            }
	            else if (atExplicitKey) {
	                // i.e. 0x3A/* : */ === character after the explicit key.
	                atExplicitKey = false;
	                allowCompact = true;
	            }
	            else {
	                throwError(state, 'incomplete explicit mapping pair; a key node is missed');
	            }
	            state.position += 1;
	            ch = following;
	        }
	        else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
	            if (state.line === _line) {
	                ch = state.input.charCodeAt(state.position);
	                while (is_WHITE_SPACE(ch)) {
	                    ch = state.input.charCodeAt(++state.position);
	                }
	                if (0x3A === ch) {
	                    ch = state.input.charCodeAt(++state.position);
	                    if (!is_WS_OR_EOL(ch)) {
	                        throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
	                    }
	                    if (atExplicitKey) {
	                        storeMappingPair(state, _result, keyTag, keyNode, null);
	                        keyTag = keyNode = valueNode = null;
	                    }
	                    detected = true;
	                    atExplicitKey = false;
	                    allowCompact = false;
	                    keyTag = state.tag;
	                    keyNode = state.result;
	                }
	                else if (detected) {
	                    throwError(state, 'can not read an implicit mapping pair; a colon is missed');
	                }
	                else {
	                    state.tag = _tag;
	                    state.anchor = _anchor;
	                    return true; // Keep the result of `composeNode`.
	                }
	            }
	            else if (detected) {
	                throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
	                while (state.position > 0) {
	                    ch = state.input.charCodeAt(--state.position);
	                    if (is_EOL(ch)) {
	                        state.position++;
	                        break;
	                    }
	                }
	            }
	            else {
	                state.tag = _tag;
	                state.anchor = _anchor;
	                return true; // Keep the result of `composeNode`.
	            }
	        }
	        else {
	            break;
	        }
	        //
	        // Common reading code for both explicit and implicit notations.
	        //
	        if (state.line === _line || state.lineIndent > nodeIndent) {
	            if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
	                if (atExplicitKey) {
	                    keyNode = state.result;
	                }
	                else {
	                    valueNode = state.result;
	                }
	            }
	            if (!atExplicitKey) {
	                storeMappingPair(state, _result, keyTag, keyNode, valueNode);
	                keyTag = keyNode = valueNode = null;
	            }
	            skipSeparationSpace(state, true, -1);
	            ch = state.input.charCodeAt(state.position);
	        }
	        if (state.lineIndent > nodeIndent && (0 !== ch)) {
	            throwError(state, 'bad indentation of a mapping entry');
	        }
	        else if (state.lineIndent < nodeIndent) {
	            break;
	        }
	    }
	    //
	    // Epilogue.
	    //
	    // Special case: last mapping's node contains only the key in explicit notation.
	    if (atExplicitKey) {
	        storeMappingPair(state, _result, keyTag, keyNode, null);
	    }
	    // Expose the resulting mapping.
	    if (detected) {
	        state.tag = _tag;
	        state.anchor = _anchor;
	        state.kind = 'mapping';
	        state.result = _result;
	    }
	    return detected;
	}
	function readTagProperty(state) {
	    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
	    ch = state.input.charCodeAt(state.position);
	    if (0x21 !== ch) {
	        return false;
	    }
	    if (null !== state.tag) {
	        throwError(state, 'duplication of a tag property');
	    }
	    ch = state.input.charCodeAt(++state.position);
	    if (0x3C === ch) {
	        isVerbatim = true;
	        ch = state.input.charCodeAt(++state.position);
	    }
	    else if (0x21 === ch) {
	        isNamed = true;
	        tagHandle = '!!';
	        ch = state.input.charCodeAt(++state.position);
	    }
	    else {
	        tagHandle = '!';
	    }
	    _position = state.position;
	    if (isVerbatim) {
	        do {
	            ch = state.input.charCodeAt(++state.position);
	        } while (0 !== ch && 0x3E !== ch);
	        if (state.position < state.length) {
	            tagName = state.input.slice(_position, state.position);
	            ch = state.input.charCodeAt(++state.position);
	        }
	        else {
	            throwError(state, 'unexpected end of the stream within a verbatim tag');
	        }
	    }
	    else {
	        while (0 !== ch && !is_WS_OR_EOL(ch)) {
	            if (0x21 === ch) {
	                if (!isNamed) {
	                    tagHandle = state.input.slice(_position - 1, state.position + 1);
	                    if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
	                        throwError(state, 'named tag handle cannot contain such characters');
	                    }
	                    isNamed = true;
	                    _position = state.position + 1;
	                }
	                else {
	                    throwError(state, 'tag suffix cannot contain exclamation marks');
	                }
	            }
	            ch = state.input.charCodeAt(++state.position);
	        }
	        tagName = state.input.slice(_position, state.position);
	        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
	            throwError(state, 'tag suffix cannot contain flow indicator characters');
	        }
	    }
	    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
	        throwError(state, 'tag name cannot contain such characters: ' + tagName);
	    }
	    if (isVerbatim) {
	        state.tag = tagName;
	    }
	    else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
	        state.tag = state.tagMap[tagHandle] + tagName;
	    }
	    else if ('!' === tagHandle) {
	        state.tag = '!' + tagName;
	    }
	    else if ('!!' === tagHandle) {
	        state.tag = 'tag:yaml.org,2002:' + tagName;
	    }
	    else {
	        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
	    }
	    return true;
	}
	function readAnchorProperty(state) {
	    var _position, ch;
	    ch = state.input.charCodeAt(state.position);
	    if (0x26 !== ch) {
	        return false;
	    }
	    if (null !== state.anchor) {
	        throwError(state, 'duplication of an anchor property');
	    }
	    ch = state.input.charCodeAt(++state.position);
	    _position = state.position;
	    while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
	        ch = state.input.charCodeAt(++state.position);
	    }
	    if (state.position === _position) {
	        throwError(state, 'name of an anchor node must contain at least one character');
	    }
	    state.anchor = state.input.slice(_position, state.position);
	    return true;
	}
	function readAlias(state) {
	    var _position, alias, len = state.length, input = state.input, ch;
	    ch = state.input.charCodeAt(state.position);
	    if (0x2A !== ch) {
	        return false;
	    }
	    ch = state.input.charCodeAt(++state.position);
	    _position = state.position;
	    while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
	        ch = state.input.charCodeAt(++state.position);
	    }
	    if (state.position <= _position) {
	        throwError(state, 'name of an alias node must contain at least one character');
	        state.position = _position + 1;
	    }
	    alias = state.input.slice(_position, state.position);
	    if (!state.anchorMap.hasOwnProperty(alias)) {
	        throwError(state, 'unidentified alias "' + alias + '"');
	        if (state.position <= _position) {
	            state.position = _position + 1;
	        }
	    }
	    state.result = ast.newAnchorRef(alias, _position, state.position, state.anchorMap[alias]);
	    skipSeparationSpace(state, true, -1);
	    return true;
	}
	function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
	    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent, _result;
	    state.tag = null;
	    state.anchor = null;
	    state.kind = null;
	    state.result = null;
	    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
	    if (allowToSeek) {
	        if (skipSeparationSpace(state, true, -1)) {
	            atNewLine = true;
	            if (state.lineIndent > parentIndent) {
	                indentStatus = 1;
	            }
	            else if (state.lineIndent === parentIndent) {
	                indentStatus = 0;
	            }
	            else if (state.lineIndent < parentIndent) {
	                indentStatus = -1;
	            }
	        }
	    }
	    if (1 === indentStatus) {
	        while (readTagProperty(state) || readAnchorProperty(state)) {
	            if (skipSeparationSpace(state, true, -1)) {
	                atNewLine = true;
	                allowBlockCollections = allowBlockStyles;
	                if (state.lineIndent > parentIndent) {
	                    indentStatus = 1;
	                }
	                else if (state.lineIndent === parentIndent) {
	                    indentStatus = 0;
	                }
	                else if (state.lineIndent < parentIndent) {
	                    indentStatus = -1;
	                }
	            }
	            else {
	                allowBlockCollections = false;
	            }
	        }
	    }
	    if (allowBlockCollections) {
	        allowBlockCollections = atNewLine || allowCompact;
	    }
	    if (1 === indentStatus || CONTEXT_BLOCK_OUT === nodeContext) {
	        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
	            flowIndent = parentIndent;
	        }
	        else {
	            flowIndent = parentIndent + 1;
	        }
	        blockIndent = state.position - state.lineStart;
	        if (1 === indentStatus) {
	            if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
	                hasContent = true;
	            }
	            else {
	                if ((allowBlockScalars && readBlockScalar(state, flowIndent)) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
	                    hasContent = true;
	                }
	                else if (readAlias(state)) {
	                    hasContent = true;
	                    if (null !== state.tag || null !== state.anchor) {
	                        throwError(state, 'alias node should not have any properties');
	                    }
	                }
	                else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
	                    hasContent = true;
	                    if (null === state.tag) {
	                        state.tag = '?';
	                    }
	                }
	                if (null !== state.anchor) {
	                    state.anchorMap[state.anchor] = state.result;
	                    state.result.anchorId = state.anchor;
	                }
	            }
	        }
	        else if (0 === indentStatus) {
	            // Special case: block sequences are allowed to have same indentation level as the parent.
	            // http://www.yaml.org/spec/1.2/spec.html#id2799784
	            hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
	        }
	    }
	    if (null !== state.tag && '!' !== state.tag) {
	        if (state.tag == "!include") {
	            if (!state.result) {
	                state.result = ast.newScalar();
	                state.result.startPosition = state.position;
	                state.result.endPosition = state.position;
	                throwError(state, "!include without value");
	            }
	            state.result.kind = 5 /* INCLUDE_REF */;
	        }
	        else if ('?' === state.tag) {
	            for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
	                type = state.implicitTypes[typeIndex];
	                // Implicit resolving is not allowed for non-scalar types, and '?'
	                // non-specific tag is only assigned to plain scalars. So, it isn't
	                // needed to check for 'kind' conformity.
	                var vl = state.result['value'];
	                if (type.resolve(vl)) {
	                    state.result.valueObject = type.construct(state.result['value']);
	                    state.tag = type.tag;
	                    if (null !== state.anchor) {
	                        state.result.anchorId = state.anchor;
	                        state.anchorMap[state.anchor] = state.result;
	                    }
	                    break;
	                }
	            }
	        }
	        else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
	            type = state.typeMap[state.tag];
	            if (null !== state.result && type.kind !== state.kind) {
	                throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
	            }
	            if (!type.resolve(state.result)) {
	                throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
	            }
	            else {
	                state.result = type.construct(state.result);
	                if (null !== state.anchor) {
	                    state.result.anchorId = state.anchor;
	                    state.anchorMap[state.anchor] = state.result;
	                }
	            }
	        }
	        else {
	            throwWarning(state, 'unknown tag !<' + state.tag + '>');
	        }
	    }
	    return null !== state.tag || null !== state.anchor || hasContent;
	}
	function readDocument(state) {
	    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
	    state.version = null;
	    state.checkLineBreaks = state.legacy;
	    state.tagMap = {};
	    state.anchorMap = {};
	    while (0 !== (ch = state.input.charCodeAt(state.position))) {
	        skipSeparationSpace(state, true, -1);
	        ch = state.input.charCodeAt(state.position);
	        if (state.lineIndent > 0 || 0x25 !== ch) {
	            break;
	        }
	        hasDirectives = true;
	        ch = state.input.charCodeAt(++state.position);
	        _position = state.position;
	        while (0 !== ch && !is_WS_OR_EOL(ch)) {
	            ch = state.input.charCodeAt(++state.position);
	        }
	        directiveName = state.input.slice(_position, state.position);
	        directiveArgs = [];
	        if (directiveName.length < 1) {
	            throwError(state, 'directive name must not be less than one character in length');
	        }
	        while (0 !== ch) {
	            while (is_WHITE_SPACE(ch)) {
	                ch = state.input.charCodeAt(++state.position);
	            }
	            if (0x23 === ch) {
	                do {
	                    ch = state.input.charCodeAt(++state.position);
	                } while (0 !== ch && !is_EOL(ch));
	                break;
	            }
	            if (is_EOL(ch)) {
	                break;
	            }
	            _position = state.position;
	            while (0 !== ch && !is_WS_OR_EOL(ch)) {
	                ch = state.input.charCodeAt(++state.position);
	            }
	            directiveArgs.push(state.input.slice(_position, state.position));
	        }
	        if (0 !== ch) {
	            readLineBreak(state);
	        }
	        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
	            directiveHandlers[directiveName](state, directiveName, directiveArgs);
	        }
	        else {
	            throwWarning(state, 'unknown document directive "' + directiveName + '"');
	            state.position++;
	        }
	    }
	    skipSeparationSpace(state, true, -1);
	    if (0 === state.lineIndent && 0x2D === state.input.charCodeAt(state.position) && 0x2D === state.input.charCodeAt(state.position + 1) && 0x2D === state.input.charCodeAt(state.position + 2)) {
	        state.position += 3;
	        skipSeparationSpace(state, true, -1);
	    }
	    else if (hasDirectives) {
	        throwError(state, 'directives end mark is expected');
	    }
	    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
	    skipSeparationSpace(state, true, -1);
	    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
	        throwWarning(state, 'non-ASCII line breaks are interpreted as content');
	    }
	    state.documents.push(state.result);
	    if (state.position === state.lineStart && testDocumentSeparator(state)) {
	        if (0x2E === state.input.charCodeAt(state.position)) {
	            state.position += 3;
	            skipSeparationSpace(state, true, -1);
	        }
	        return;
	    }
	    if (state.position < (state.length - 1)) {
	        throwError(state, 'end of the stream or a document separator is expected');
	    }
	    else {
	        return;
	    }
	}
	function loadDocuments(input, options) {
	    input = String(input);
	    options = options || {};
	    if (input.length !== 0) {
	        // Add tailing `\n` if not exists
	        if (0x0A !== input.charCodeAt(input.length - 1) && 0x0D !== input.charCodeAt(input.length - 1)) {
	            input += '\n';
	        }
	        // Strip BOM
	        if (input.charCodeAt(0) === 0xFEFF) {
	            input = input.slice(1);
	        }
	    }
	    var state = new State(input, options);
	    if (PATTERN_NON_PRINTABLE.test(state.input)) {
	        throwError(state, 'the stream contains non-printable characters');
	    }
	    // Use 0 as string terminator. That significantly simplifies bounds check.
	    state.input += '\0';
	    while (0x20 === state.input.charCodeAt(state.position)) {
	        state.lineIndent += 1;
	        state.position += 1;
	    }
	    while (state.position < (state.length - 1)) {
	        var q = state.position;
	        readDocument(state);
	        if (state.position <= q) {
	            for (; state.position < state.length - 1; state.position++) {
	                var c = state.input.charAt(state.position);
	                if (c == '\n') {
	                    break;
	                }
	            }
	        }
	    }
	    state.documents.forEach(function (x) { return x.errors = state.errors; });
	    return state.documents;
	}
	function loadAll(input, iterator, options) {
	    var documents = loadDocuments(input, options), index, length;
	    for (index = 0, length = documents.length; index < length; index += 1) {
	        iterator(documents[index]);
	    }
	}
	exports.loadAll = loadAll;
	function load(input, options) {
	    var documents = loadDocuments(input, options), index, length;
	    if (0 === documents.length) {
	        /*eslint-disable no-undefined*/
	        return undefined;
	    }
	    else if (1 === documents.length) {
	        //root node always takes whole file
	        documents[0].endPosition = input.length;
	        return documents[0];
	    }
	    var e = new YAMLException('expected a single document in the stream, but found more');
	    e.mark = new Mark("", "", 0, 0, 0);
	    e.mark.position = documents[0].endPosition;
	    documents[0].errors.push(e);
	    //it is an artifact which is caused by the fact that we are checking next char before stopping parse
	    return documents[0];
	}
	exports.load = load;
	function safeLoadAll(input, output, options) {
	    loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}
	exports.safeLoadAll = safeLoadAll;
	function safeLoad(input, options) {
	    return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}
	exports.safeLoad = safeLoad;
	module.exports.loadAll = loadAll;
	module.exports.load = load;
	module.exports.safeLoadAll = safeLoadAll;
	module.exports.safeLoad = safeLoad;
	//# sourceMappingURL=loader.js.map

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var YAMLException = __webpack_require__(28);
	var TYPE_CONSTRUCTOR_OPTIONS = [
	    'kind',
	    'resolve',
	    'construct',
	    'instanceOf',
	    'predicate',
	    'represent',
	    'defaultStyle',
	    'styleAliases'
	];
	var YAML_NODE_KINDS = [
	    'scalar',
	    'sequence',
	    'mapping'
	];
	function compileStyleAliases(map) {
	    var result = {};
	    if (null !== map) {
	        Object.keys(map).forEach(function (style) {
	            map[style].forEach(function (alias) {
	                result[String(alias)] = style;
	            });
	        });
	    }
	    return result;
	}
	function Type(tag, options) {
	    options = options || {};
	    Object.keys(options).forEach(function (name) {
	        if (-1 === TYPE_CONSTRUCTOR_OPTIONS.indexOf(name)) {
	            throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
	        }
	    });
	    // TODO: Add tag format check.
	    this.tag = tag;
	    this.kind = options['kind'] || null;
	    this.resolve = options['resolve'] || function () {
	        return true;
	    };
	    this.construct = options['construct'] || function (data) {
	        return data;
	    };
	    this.instanceOf = options['instanceOf'] || null;
	    this.predicate = options['predicate'] || null;
	    this.represent = options['represent'] || null;
	    this.defaultStyle = options['defaultStyle'] || null;
	    this.styleAliases = compileStyleAliases(options['styleAliases'] || null);
	    if (-1 === YAML_NODE_KINDS.indexOf(this.kind)) {
	        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
	    }
	}
	module.exports = Type;
	//# sourceMappingURL=type.js.map

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../typings/tsd.d.ts" />
	'use strict';
	/*eslint-disable max-len*/
	var common = __webpack_require__(57);
	var YAMLException = __webpack_require__(28);
	var Type = __webpack_require__(61);
	function compileList(schema, name, result) {
	    var exclude = [];
	    schema.include.forEach(function (includedSchema) {
	        result = compileList(includedSchema, name, result);
	    });
	    schema[name].forEach(function (currentType) {
	        result.forEach(function (previousType, previousIndex) {
	            if (previousType.tag === currentType.tag) {
	                exclude.push(previousIndex);
	            }
	        });
	        result.push(currentType);
	    });
	    return result.filter(function (type, index) {
	        return -1 === exclude.indexOf(index);
	    });
	}
	function compileMap() {
	    var result = {}, index, length;
	    function collectType(type) {
	        result[type.tag] = type;
	    }
	    for (index = 0, length = arguments.length; index < length; index += 1) {
	        arguments[index].forEach(collectType);
	    }
	    return result;
	}
	var Schema = (function () {
	    function Schema(definition) {
	        this.include = definition.include || [];
	        this.implicit = definition.implicit || [];
	        this.explicit = definition.explicit || [];
	        this.implicit.forEach(function (type) {
	            if (type.loadKind && 'scalar' !== type.loadKind) {
	                throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
	            }
	        });
	        this.compiledImplicit = compileList(this, 'implicit', []);
	        this.compiledExplicit = compileList(this, 'explicit', []);
	        this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
	    }
	    Schema.DEFAULT = null;
	    Schema.create = function createSchema() {
	        var schemas, types;
	        switch (arguments.length) {
	            case 1:
	                schemas = Schema.DEFAULT;
	                types = arguments[0];
	                break;
	            case 2:
	                schemas = arguments[0];
	                types = arguments[1];
	                break;
	            default:
	                throw new YAMLException('Wrong number of arguments for Schema.create function');
	        }
	        schemas = common.toArray(schemas);
	        types = common.toArray(types);
	        if (!schemas.every(function (schema) {
	            return schema instanceof Schema;
	        })) {
	            throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
	        }
	        if (!types.every(function (type) {
	            return type instanceof Type;
	        })) {
	            throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
	        }
	        return new Schema({
	            include: schemas,
	            explicit: types
	        });
	    };
	    return Schema;
	})();
	module.exports = Schema;
	//# sourceMappingURL=schema.js.map

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	// Standard YAML's Failsafe schema.
	// http://www.yaml.org/spec/1.2/spec.html#id2802346
	'use strict';
	var Schema = __webpack_require__(62);
	module.exports = new Schema({
	    explicit: [
	        __webpack_require__(95),
	        __webpack_require__(96),
	        __webpack_require__(97)
	    ]
	});
	//# sourceMappingURL=failsafe.js.map

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	// Standard YAML's JSON schema.
	// http://www.yaml.org/spec/1.2/spec.html#id2803231
	//
	// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
	// So, this schema is not such strict as defined in the YAML specification.
	// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.
	'use strict';
	var Schema = __webpack_require__(62);
	module.exports = new Schema({
	    include: [
	        __webpack_require__(63)
	    ],
	    implicit: [
	        __webpack_require__(98),
	        __webpack_require__(99),
	        __webpack_require__(100),
	        __webpack_require__(101)
	    ]
	});
	//# sourceMappingURL=json.js.map

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	// Standard YAML's Core schema.
	// http://www.yaml.org/spec/1.2/spec.html#id2804923
	//
	// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
	// So, Core schema has no distinctions from JSON schema is JS-YAML.
	'use strict';
	var Schema = __webpack_require__(62);
	module.exports = new Schema({
	    include: [
	        __webpack_require__(64)
	    ]
	});
	//# sourceMappingURL=core.js.map

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/// <reference path="../../../typings/tsd.d.ts" />
	'use strict';
	var concat = __webpack_require__(76);
	var request = __webpack_require__(80);
	function respond(data) {
	    process.stdout.write(JSON.stringify(data), function () {
	        process.exit(0);
	    });
	}
	process.stdin.pipe(concat(function (stdin) {
	    var req = JSON.parse(stdin.toString());
	    request(req.method, req.url, req.options).done(function (response) {
	        respond({ success: true, response: response });
	    }, function (err) {
	        respond({ success: false, error: { message: err.message } });
	    });
	}));
	//# sourceMappingURL=worker.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(72)))

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var parser = (function () {
	    "use strict";
	    /*
	     * Generated by PEG.js 0.9.0.
	     *
	     * http://pegjs.org/
	     */
	    function peg$subclass(child, parent) {
	        function ctor() {
	            this.constructor = child;
	        }
	        ctor.prototype = parent.prototype;
	        child.prototype = new ctor();
	    }
	    function peg$SyntaxError(message, expected, found, location) {
	        this.message = message;
	        this.expected = expected;
	        this.found = found;
	        this.location = location;
	        this.name = "SyntaxError";
	        if (typeof Error.captureStackTrace === "function") {
	            Error.captureStackTrace(this, peg$SyntaxError);
	        }
	    }
	    peg$subclass(peg$SyntaxError, Error);
	    function peg$parse(input) {
	        var options = arguments.length > 1 ? arguments[1] : {}, parser = this, peg$FAILED = {}, peg$startRuleFunctions = { Term: peg$parseTerm }, peg$startRuleFunction = peg$parseTerm, peg$c0 = "|", peg$c1 = { type: "literal", value: "|", description: "\"|\"" }, peg$c2 = function (first, rest) {
	            return rest ? { "type": "union", "first": first, "rest": rest[3] } : first;
	        }, peg$c3 = "(", peg$c4 = { type: "literal", value: "(", description: "\"(\"" }, peg$c5 = ")", peg$c6 = { type: "literal", value: ")", description: "\")\"" }, peg$c7 = "[]", peg$c8 = { type: "literal", value: "[]", description: "\"[]\"" }, peg$c9 = function (expr, arr) {
	            return { "type": "parens", "expr": expr, "arr": arr.length };
	        }, peg$c10 = "<", peg$c11 = { type: "literal", value: "<", description: "\"<\"" }, peg$c12 = ">", peg$c13 = { type: "literal", value: ">", description: "\">\"" }, peg$c14 = function (first, other) {
	            return [first].concat(other);
	        }, peg$c15 = ",", peg$c16 = { type: "literal", value: ",", description: "\",\"" }, peg$c17 = function (r) {
	            return r;
	        }, peg$c18 = { type: "other", description: "name" }, peg$c19 = function (r, tp, c) {
	            return { "type": "name", "params": tp, "value": r.join(""), "arr": (c.length) };
	        }, peg$c20 = { type: "other", description: "whitespace" }, peg$c21 = /^[ \t\n\r]/, peg$c22 = { type: "class", value: "[ \\t\\n\\r]", description: "[ \\t\\n\\r]" }, peg$c23 = /^[A-Z]/, peg$c24 = { type: "class", value: "[A-Z]", description: "[A-Z]" }, peg$c25 = "_", peg$c26 = { type: "literal", value: "_", description: "\"_\"" }, peg$c27 = "-", peg$c28 = { type: "literal", value: "-", description: "\"-\"" }, peg$c29 = ".", peg$c30 = { type: "literal", value: ".", description: "\".\"" }, peg$c31 = /^[a-z]/, peg$c32 = { type: "class", value: "[a-z]", description: "[a-z]" }, peg$c33 = /^[0-9]/, peg$c34 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{ line: 1, column: 1, seenCR: false }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
	        if ("startRule" in options) {
	            if (!(options.startRule in peg$startRuleFunctions)) {
	                throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	            }
	            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	        }
	        function text() {
	            return input.substring(peg$savedPos, peg$currPos);
	        }
	        function location() {
	            return peg$computeLocation(peg$savedPos, peg$currPos);
	        }
	        function expected(description) {
	            throw peg$buildException(null, [{ type: "other", description: description }], input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
	        }
	        function error(message) {
	            throw peg$buildException(message, null, input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
	        }
	        function peg$computePosDetails(pos) {
	            var details = peg$posDetailsCache[pos], p, ch;
	            if (details) {
	                return details;
	            }
	            else {
	                p = pos - 1;
	                while (!peg$posDetailsCache[p]) {
	                    p--;
	                }
	                details = peg$posDetailsCache[p];
	                details = {
	                    line: details.line,
	                    column: details.column,
	                    seenCR: details.seenCR
	                };
	                while (p < pos) {
	                    ch = input.charAt(p);
	                    if (ch === "\n") {
	                        if (!details.seenCR) {
	                            details.line++;
	                        }
	                        details.column = 1;
	                        details.seenCR = false;
	                    }
	                    else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
	                        details.line++;
	                        details.column = 1;
	                        details.seenCR = true;
	                    }
	                    else {
	                        details.column++;
	                        details.seenCR = false;
	                    }
	                    p++;
	                }
	                peg$posDetailsCache[pos] = details;
	                return details;
	            }
	        }
	        function peg$computeLocation(startPos, endPos) {
	            var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
	            return {
	                start: {
	                    offset: startPos,
	                    line: startPosDetails.line,
	                    column: startPosDetails.column
	                },
	                end: {
	                    offset: endPos,
	                    line: endPosDetails.line,
	                    column: endPosDetails.column
	                }
	            };
	        }
	        function peg$fail(expected) {
	            if (peg$currPos < peg$maxFailPos) {
	                return;
	            }
	            if (peg$currPos > peg$maxFailPos) {
	                peg$maxFailPos = peg$currPos;
	                peg$maxFailExpected = [];
	            }
	            peg$maxFailExpected.push(expected);
	        }
	        function peg$buildException(message, expected, found, location) {
	            function cleanupExpected(expected) {
	                var i = 1;
	                expected.sort(function (a, b) {
	                    if (a.description < b.description) {
	                        return -1;
	                    }
	                    else if (a.description > b.description) {
	                        return 1;
	                    }
	                    else {
	                        return 0;
	                    }
	                });
	                while (i < expected.length) {
	                    if (expected[i - 1] === expected[i]) {
	                        expected.splice(i, 1);
	                    }
	                    else {
	                        i++;
	                    }
	                }
	            }
	            function buildMessage(expected, found) {
	                function stringEscape(s) {
	                    function hex(ch) {
	                        return ch.charCodeAt(0).toString(16).toUpperCase();
	                    }
	                    return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (ch) {
	                        return '\\x0' + hex(ch);
	                    }).replace(/[\x10-\x1F\x80-\xFF]/g, function (ch) {
	                        return '\\x' + hex(ch);
	                    }).replace(/[\u0100-\u0FFF]/g, function (ch) {
	                        return '\\u0' + hex(ch);
	                    }).replace(/[\u1000-\uFFFF]/g, function (ch) {
	                        return '\\u' + hex(ch);
	                    });
	                }
	                var expectedDescs = new Array(expected.length), expectedDesc, foundDesc, i;
	                for (i = 0; i < expected.length; i++) {
	                    expectedDescs[i] = expected[i].description;
	                }
	                expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];
	                foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
	                return "Expected " + expectedDesc + " but " + foundDesc + " found.";
	            }
	            if (expected !== null) {
	                cleanupExpected(expected);
	            }
	            return new peg$SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, location);
	        }
	        function peg$parseTerm() {
	            var s0, s1, s2, s3, s4, s5, s6, s7;
	            s0 = peg$currPos;
	            s1 = peg$parse_();
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parseFactor();
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$currPos;
	                    s4 = peg$parse_();
	                    if (s4 !== peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 124) {
	                            s5 = peg$c0;
	                            peg$currPos++;
	                        }
	                        else {
	                            s5 = peg$FAILED;
	                            if (peg$silentFails === 0) {
	                                peg$fail(peg$c1);
	                            }
	                        }
	                        if (s5 !== peg$FAILED) {
	                            s6 = peg$parse_();
	                            if (s6 !== peg$FAILED) {
	                                s7 = peg$parseTerm();
	                                if (s7 !== peg$FAILED) {
	                                    s4 = [s4, s5, s6, s7];
	                                    s3 = s4;
	                                }
	                                else {
	                                    peg$currPos = s3;
	                                    s3 = peg$FAILED;
	                                }
	                            }
	                            else {
	                                peg$currPos = s3;
	                                s3 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s3;
	                            s3 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                    if (s3 === peg$FAILED) {
	                        s3 = null;
	                    }
	                    if (s3 !== peg$FAILED) {
	                        peg$savedPos = s0;
	                        s1 = peg$c2(s2, s3);
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseFactor() {
	            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 40) {
	                s1 = peg$c3;
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c4);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parse_();
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$parseTerm();
	                    if (s3 !== peg$FAILED) {
	                        s4 = peg$parse_();
	                        if (s4 !== peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 41) {
	                                s5 = peg$c5;
	                                peg$currPos++;
	                            }
	                            else {
	                                s5 = peg$FAILED;
	                                if (peg$silentFails === 0) {
	                                    peg$fail(peg$c6);
	                                }
	                            }
	                            if (s5 !== peg$FAILED) {
	                                s6 = [];
	                                s7 = peg$currPos;
	                                s8 = peg$parse_();
	                                if (s8 !== peg$FAILED) {
	                                    if (input.substr(peg$currPos, 2) === peg$c7) {
	                                        s9 = peg$c7;
	                                        peg$currPos += 2;
	                                    }
	                                    else {
	                                        s9 = peg$FAILED;
	                                        if (peg$silentFails === 0) {
	                                            peg$fail(peg$c8);
	                                        }
	                                    }
	                                    if (s9 !== peg$FAILED) {
	                                        s8 = [s8, s9];
	                                        s7 = s8;
	                                    }
	                                    else {
	                                        peg$currPos = s7;
	                                        s7 = peg$FAILED;
	                                    }
	                                }
	                                else {
	                                    peg$currPos = s7;
	                                    s7 = peg$FAILED;
	                                }
	                                while (s7 !== peg$FAILED) {
	                                    s6.push(s7);
	                                    s7 = peg$currPos;
	                                    s8 = peg$parse_();
	                                    if (s8 !== peg$FAILED) {
	                                        if (input.substr(peg$currPos, 2) === peg$c7) {
	                                            s9 = peg$c7;
	                                            peg$currPos += 2;
	                                        }
	                                        else {
	                                            s9 = peg$FAILED;
	                                            if (peg$silentFails === 0) {
	                                                peg$fail(peg$c8);
	                                            }
	                                        }
	                                        if (s9 !== peg$FAILED) {
	                                            s8 = [s8, s9];
	                                            s7 = s8;
	                                        }
	                                        else {
	                                            peg$currPos = s7;
	                                            s7 = peg$FAILED;
	                                        }
	                                    }
	                                    else {
	                                        peg$currPos = s7;
	                                        s7 = peg$FAILED;
	                                    }
	                                }
	                                if (s6 !== peg$FAILED) {
	                                    peg$savedPos = s0;
	                                    s1 = peg$c9(s3, s6);
	                                    s0 = s1;
	                                }
	                                else {
	                                    peg$currPos = s0;
	                                    s0 = peg$FAILED;
	                                }
	                            }
	                            else {
	                                peg$currPos = s0;
	                                s0 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            if (s0 === peg$FAILED) {
	                s0 = peg$parseLiteral();
	            }
	            return s0;
	        }
	        function peg$parseTypeParams() {
	            var s0, s1, s2, s3, s4;
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 60) {
	                s1 = peg$c10;
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c11);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parseTerm();
	                if (s2 !== peg$FAILED) {
	                    s3 = [];
	                    s4 = peg$parseExtraParam();
	                    while (s4 !== peg$FAILED) {
	                        s3.push(s4);
	                        s4 = peg$parseExtraParam();
	                    }
	                    if (s3 !== peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 62) {
	                            s4 = peg$c12;
	                            peg$currPos++;
	                        }
	                        else {
	                            s4 = peg$FAILED;
	                            if (peg$silentFails === 0) {
	                                peg$fail(peg$c13);
	                            }
	                        }
	                        if (s4 !== peg$FAILED) {
	                            peg$savedPos = s0;
	                            s1 = peg$c14(s2, s3);
	                            s0 = s1;
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseExtraParam() {
	            var s0, s1, s2;
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 44) {
	                s1 = peg$c15;
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c16);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parseTerm();
	                if (s2 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c17(s2);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseLiteral() {
	            var s0, s1, s2, s3, s4, s5, s6;
	            peg$silentFails++;
	            s0 = peg$currPos;
	            s1 = [];
	            s2 = peg$parsechar();
	            if (s2 !== peg$FAILED) {
	                while (s2 !== peg$FAILED) {
	                    s1.push(s2);
	                    s2 = peg$parsechar();
	                }
	            }
	            else {
	                s1 = peg$FAILED;
	            }
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parseTypeParams();
	                if (s2 === peg$FAILED) {
	                    s2 = null;
	                }
	                if (s2 !== peg$FAILED) {
	                    s3 = [];
	                    s4 = peg$currPos;
	                    s5 = peg$parse_();
	                    if (s5 !== peg$FAILED) {
	                        if (input.substr(peg$currPos, 2) === peg$c7) {
	                            s6 = peg$c7;
	                            peg$currPos += 2;
	                        }
	                        else {
	                            s6 = peg$FAILED;
	                            if (peg$silentFails === 0) {
	                                peg$fail(peg$c8);
	                            }
	                        }
	                        if (s6 !== peg$FAILED) {
	                            s5 = [s5, s6];
	                            s4 = s5;
	                        }
	                        else {
	                            peg$currPos = s4;
	                            s4 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s4;
	                        s4 = peg$FAILED;
	                    }
	                    while (s4 !== peg$FAILED) {
	                        s3.push(s4);
	                        s4 = peg$currPos;
	                        s5 = peg$parse_();
	                        if (s5 !== peg$FAILED) {
	                            if (input.substr(peg$currPos, 2) === peg$c7) {
	                                s6 = peg$c7;
	                                peg$currPos += 2;
	                            }
	                            else {
	                                s6 = peg$FAILED;
	                                if (peg$silentFails === 0) {
	                                    peg$fail(peg$c8);
	                                }
	                            }
	                            if (s6 !== peg$FAILED) {
	                                s5 = [s5, s6];
	                                s4 = s5;
	                            }
	                            else {
	                                peg$currPos = s4;
	                                s4 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s4;
	                            s4 = peg$FAILED;
	                        }
	                    }
	                    if (s3 !== peg$FAILED) {
	                        peg$savedPos = s0;
	                        s1 = peg$c19(s1, s2, s3);
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            peg$silentFails--;
	            if (s0 === peg$FAILED) {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c18);
	                }
	            }
	            return s0;
	        }
	        function peg$parse_() {
	            var s0, s1;
	            peg$silentFails++;
	            s0 = [];
	            if (peg$c21.test(input.charAt(peg$currPos))) {
	                s1 = input.charAt(peg$currPos);
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c22);
	                }
	            }
	            while (s1 !== peg$FAILED) {
	                s0.push(s1);
	                if (peg$c21.test(input.charAt(peg$currPos))) {
	                    s1 = input.charAt(peg$currPos);
	                    peg$currPos++;
	                }
	                else {
	                    s1 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c22);
	                    }
	                }
	            }
	            peg$silentFails--;
	            if (s0 === peg$FAILED) {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c20);
	                }
	            }
	            return s0;
	        }
	        function peg$parsechar() {
	            var s0;
	            if (peg$c23.test(input.charAt(peg$currPos))) {
	                s0 = input.charAt(peg$currPos);
	                peg$currPos++;
	            }
	            else {
	                s0 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c24);
	                }
	            }
	            if (s0 === peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 95) {
	                    s0 = peg$c25;
	                    peg$currPos++;
	                }
	                else {
	                    s0 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c26);
	                    }
	                }
	                if (s0 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 45) {
	                        s0 = peg$c27;
	                        peg$currPos++;
	                    }
	                    else {
	                        s0 = peg$FAILED;
	                        if (peg$silentFails === 0) {
	                            peg$fail(peg$c28);
	                        }
	                    }
	                    if (s0 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 46) {
	                            s0 = peg$c29;
	                            peg$currPos++;
	                        }
	                        else {
	                            s0 = peg$FAILED;
	                            if (peg$silentFails === 0) {
	                                peg$fail(peg$c30);
	                            }
	                        }
	                        if (s0 === peg$FAILED) {
	                            if (peg$c31.test(input.charAt(peg$currPos))) {
	                                s0 = input.charAt(peg$currPos);
	                                peg$currPos++;
	                            }
	                            else {
	                                s0 = peg$FAILED;
	                                if (peg$silentFails === 0) {
	                                    peg$fail(peg$c32);
	                                }
	                            }
	                            if (s0 === peg$FAILED) {
	                                if (peg$c33.test(input.charAt(peg$currPos))) {
	                                    s0 = input.charAt(peg$currPos);
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s0 = peg$FAILED;
	                                    if (peg$silentFails === 0) {
	                                        peg$fail(peg$c34);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            return s0;
	        }
	        peg$result = peg$startRuleFunction();
	        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	            return peg$result;
	        }
	        else {
	            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
	                peg$fail({ type: "end", description: "end of input" });
	            }
	            throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
	        }
	    }
	    return {
	        SyntaxError: peg$SyntaxError,
	        parse: peg$parse
	    };
	})();
	module.exports = parser;
	//# sourceMappingURL=typeExpressionParser.js.map

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var RamlWrapper = __webpack_require__(3);
	function buildWrapperNode(node) {
	    var nodeClassName = node.definition().name();
	    var wrapperConstructor = classMap[nodeClassName];
	    if (!wrapperConstructor) {
	        var m = node.definition().allSuperTypes();
	        var wr = null;
	        for (var i = 0; i < m.length; i++) {
	            var nm = m[i].name();
	            wrapperConstructor = classMap[nm];
	            if (nm == "DataElement") {
	                wr = nm;
	                continue;
	            }
	            if (nm == "RAMLLanguageElement") {
	                continue;
	            }
	            if (wrapperConstructor) {
	                break;
	            }
	        }
	        if (!wrapperConstructor) {
	            wr = nm;
	        }
	    }
	    if (!wrapperConstructor) {
	        wrapperConstructor = classMap["RAMLLanguageElement"];
	    }
	    return wrapperConstructor(node);
	}
	exports.buildWrapperNode = buildWrapperNode;
	var classMap = {
	    "AnnotationRef": function (x) {
	        return new RamlWrapper.AnnotationRefImpl(x);
	    },
	    "AnnotationTarget": function (x) {
	        return new RamlWrapper.AnnotationTargetImpl(x);
	    },
	    "AnnotationType": function (x) {
	        return new RamlWrapper.AnnotationTypeImpl(x);
	    },
	    "Api": function (x) {
	        return new RamlWrapper.ApiImpl(x);
	    },
	    "ApiDescription": function (x) {
	        return new RamlWrapper.ApiDescriptionImpl(x);
	    },
	    "ArrayField": function (x) {
	        return new RamlWrapper.ArrayFieldImpl(x);
	    },
	    "Basic": function (x) {
	        return new RamlWrapper.BasicImpl(x);
	    },
	    "BooleanElement": function (x) {
	        return new RamlWrapper.BooleanElementImpl(x);
	    },
	    "BooleanType": function (x) {
	        return new RamlWrapper.BooleanTypeImpl(x);
	    },
	    "CallbackAPIDescription": function (x) {
	        return new RamlWrapper.CallbackAPIDescriptionImpl(x);
	    },
	    "ContentType": function (x) {
	        return new RamlWrapper.ContentTypeImpl(x);
	    },
	    "Custom": function (x) {
	        return new RamlWrapper.CustomImpl(x);
	    },
	    "DataElement": function (x) {
	        return new RamlWrapper.DataElementImpl(x);
	    },
	    "DataElementRef": function (x) {
	        return new RamlWrapper.DataElementRefImpl(x);
	    },
	    "DateElement": function (x) {
	        return new RamlWrapper.DateElementImpl(x);
	    },
	    "DateFormatSpec": function (x) {
	        return new RamlWrapper.DateFormatSpecImpl(x);
	    },
	    "Digest": function (x) {
	        return new RamlWrapper.DigestImpl(x);
	    },
	    "DocumentationItem": function (x) {
	        return new RamlWrapper.DocumentationItemImpl(x);
	    },
	    "ExampleSpec": function (x) {
	        return new RamlWrapper.ExampleSpecImpl(x);
	    },
	    "ExampleString": function (x) {
	        return new RamlWrapper.ExampleStringImpl(x);
	    },
	    "Extension": function (x) {
	        return new RamlWrapper.ExtensionImpl(x);
	    },
	    "FileParameter": function (x) {
	        return new RamlWrapper.FileParameterImpl(x);
	    },
	    "FixedUri": function (x) {
	        return new RamlWrapper.FixedUriImpl(x);
	    },
	    "FullUriTemplate": function (x) {
	        return new RamlWrapper.FullUriTemplateImpl(x);
	    },
	    "FunctionalInterface": function (x) {
	        return new RamlWrapper.FunctionalInterfaceImpl(x);
	    },
	    "GlobalSchema": function (x) {
	        return new RamlWrapper.GlobalSchemaImpl(x);
	    },
	    "HasNormalParameters": function (x) {
	        return new RamlWrapper.HasNormalParametersImpl(x);
	    },
	    "ImportDeclaration": function (x) {
	        return new RamlWrapper.ImportDeclarationImpl(x);
	    },
	    "IntegerElement": function (x) {
	        return new RamlWrapper.IntegerElementImpl(x);
	    },
	    "JSonSchemaString": function (x) {
	        return new RamlWrapper.JSonSchemaStringImpl(x);
	    },
	    "Library": function (x) {
	        return new RamlWrapper.LibraryImpl(x);
	    },
	    "LocationKind": function (x) {
	        return new RamlWrapper.LocationKindImpl(x);
	    },
	    "MarkdownString": function (x) {
	        return new RamlWrapper.MarkdownStringImpl(x);
	    },
	    "Method": function (x) {
	        return new RamlWrapper.MethodImpl(x);
	    },
	    "MethodBase": function (x) {
	        return new RamlWrapper.MethodBaseImpl(x);
	    },
	    "MimeType": function (x) {
	        return new RamlWrapper.MimeTypeImpl(x);
	    },
	    "ModelLocation": function (x) {
	        return new RamlWrapper.ModelLocationImpl(x);
	    },
	    "NumberElement": function (x) {
	        return new RamlWrapper.NumberElementImpl(x);
	    },
	    "NumberType": function (x) {
	        return new RamlWrapper.NumberTypeImpl(x);
	    },
	    "OAuth1SecuritySchemeSettings": function (x) {
	        return new RamlWrapper.OAuth1SecuritySchemeSettingsImpl(x);
	    },
	    "OAuth2SecuritySchemeSettings": function (x) {
	        return new RamlWrapper.OAuth2SecuritySchemeSettingsImpl(x);
	    },
	    "OLibrary": function (x) {
	        return new RamlWrapper.OLibraryImpl(x);
	    },
	    "Oath1": function (x) {
	        return new RamlWrapper.Oath1Impl(x);
	    },
	    "Oath2": function (x) {
	        return new RamlWrapper.Oath2Impl(x);
	    },
	    "ObjectField": function (x) {
	        return new RamlWrapper.ObjectFieldImpl(x);
	    },
	    "Overlay": function (x) {
	        return new RamlWrapper.OverlayImpl(x);
	    },
	    "PassThrough": function (x) {
	        return new RamlWrapper.PassThroughImpl(x);
	    },
	    "PassThroughSettings": function (x) {
	        return new RamlWrapper.PassThroughSettingsImpl(x);
	    },
	    "RAMLExpression": function (x) {
	        return new RamlWrapper.RAMLExpressionImpl(x);
	    },
	    "RAMLLanguageElement": function (x) {
	        return new RamlWrapper.RAMLLanguageElementImpl(x);
	    },
	    "RAMLPointer": function (x) {
	        return new RamlWrapper.RAMLPointerImpl(x);
	    },
	    "RAMLPointerElement": function (x) {
	        return new RamlWrapper.RAMLPointerElementImpl(x);
	    },
	    "RAMLProject": function (x) {
	        return new RamlWrapper.RAMLProjectImpl(x);
	    },
	    "RAMLSelector": function (x) {
	        return new RamlWrapper.RAMLSelectorImpl(x);
	    },
	    "RAMLSimpleElement": function (x) {
	        return new RamlWrapper.RAMLSimpleElementImpl(x);
	    },
	    "Reference": function (x) {
	        return new RamlWrapper.ReferenceImpl(x);
	    },
	    "RelativeUri": function (x) {
	        return new RamlWrapper.RelativeUriImpl(x);
	    },
	    "Resource": function (x) {
	        return new RamlWrapper.ResourceImpl(x);
	    },
	    "ResourceBase": function (x) {
	        return new RamlWrapper.ResourceBaseImpl(x);
	    },
	    "ResourceType": function (x) {
	        return new RamlWrapper.ResourceTypeImpl(x);
	    },
	    "ResourceTypeRef": function (x) {
	        return new RamlWrapper.ResourceTypeRefImpl(x);
	    },
	    "Response": function (x) {
	        return new RamlWrapper.ResponseImpl(x);
	    },
	    "SchemaElement": function (x) {
	        return new RamlWrapper.SchemaElementImpl(x);
	    },
	    "SchemaString": function (x) {
	        return new RamlWrapper.SchemaStringImpl(x);
	    },
	    "ScriptHookElement": function (x) {
	        return new RamlWrapper.ScriptHookElementImpl(x);
	    },
	    "ScriptSpec": function (x) {
	        return new RamlWrapper.ScriptSpecImpl(x);
	    },
	    "ScriptingHook": function (x) {
	        return new RamlWrapper.ScriptingHookImpl(x);
	    },
	    "SecuritySchema": function (x) {
	        return new RamlWrapper.SecuritySchemaImpl(x);
	    },
	    "SecuritySchemaHookScript": function (x) {
	        return new RamlWrapper.SecuritySchemaHookScriptImpl(x);
	    },
	    "SecuritySchemaPart": function (x) {
	        return new RamlWrapper.SecuritySchemaPartImpl(x);
	    },
	    "SecuritySchemaRef": function (x) {
	        return new RamlWrapper.SecuritySchemaRefImpl(x);
	    },
	    "SecuritySchemaSettings": function (x) {
	        return new RamlWrapper.SecuritySchemaSettingsImpl(x);
	    },
	    "SecuritySchemaType": function (x) {
	        return new RamlWrapper.SecuritySchemaTypeImpl(x);
	    },
	    "StatusCode": function (x) {
	        return new RamlWrapper.StatusCodeImpl(x);
	    },
	    "StrElement": function (x) {
	        return new RamlWrapper.StrElementImpl(x);
	    },
	    "StringType": function (x) {
	        return new RamlWrapper.StringTypeImpl(x);
	    },
	    "Trait": function (x) {
	        return new RamlWrapper.TraitImpl(x);
	    },
	    "TraitRef": function (x) {
	        return new RamlWrapper.TraitRefImpl(x);
	    },
	    "UnionField": function (x) {
	        return new RamlWrapper.UnionFieldImpl(x);
	    },
	    "UriTemplate": function (x) {
	        return new RamlWrapper.UriTemplateImpl(x);
	    },
	    "ValidityExpression": function (x) {
	        return new RamlWrapper.ValidityExpressionImpl(x);
	    },
	    "ValueElement": function (x) {
	        return new RamlWrapper.ValueElementImpl(x);
	    },
	    "ValueType": function (x) {
	        return new RamlWrapper.ValueTypeImpl(x);
	    },
	    "XMLInfo": function (x) {
	        return new RamlWrapper.XMLInfoImpl(x);
	    },
	    "XMLSchemaString": function (x) {
	        return new RamlWrapper.XMLSchemaStringImpl(x);
	    },
	    "pointer": function (x) {
	        return new RamlWrapper.pointerImpl(x);
	    },
	    "ramlexpression": function (x) {
	        return new RamlWrapper.ramlexpressionImpl(x);
	    }
	};
	//# sourceMappingURL=raml003factory.js.map

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var RamlWrapper = __webpack_require__(14);
	function buildWrapperNode(node) {
	    var nodeClassName = node.definition().name();
	    var wrapperConstructor = classMap[nodeClassName];
	    if (!wrapperConstructor) {
	        var m = node.definition().allSuperTypes();
	        var wr = null;
	        for (var i = 0; i < m.length; i++) {
	            var nm = m[i].name();
	            wrapperConstructor = classMap[nm];
	            if (nm == "DataElement") {
	                wr = nm;
	                continue;
	            }
	            if (nm == "RAMLLanguageElement") {
	                continue;
	            }
	            if (wrapperConstructor) {
	                break;
	            }
	        }
	        if (!wrapperConstructor) {
	            wr = nm;
	        }
	    }
	    if (!wrapperConstructor) {
	        wrapperConstructor = classMap["RAMLLanguageElement"];
	    }
	    return wrapperConstructor(node);
	}
	exports.buildWrapperNode = buildWrapperNode;
	var classMap = {
	    "Api": function (x) {
	        return new RamlWrapper.ApiImpl(x);
	    },
	    "BodyLike": function (x) {
	        return new RamlWrapper.BodyLikeImpl(x);
	    },
	    "BooleanElement": function (x) {
	        return new RamlWrapper.BooleanElementImpl(x);
	    },
	    "BooleanType": function (x) {
	        return new RamlWrapper.BooleanTypeImpl(x);
	    },
	    "DateElement": function (x) {
	        return new RamlWrapper.DateElementImpl(x);
	    },
	    "DocumentationItem": function (x) {
	        return new RamlWrapper.DocumentationItemImpl(x);
	    },
	    "ExampleString": function (x) {
	        return new RamlWrapper.ExampleStringImpl(x);
	    },
	    "FileElement": function (x) {
	        return new RamlWrapper.FileElementImpl(x);
	    },
	    "FixedUri": function (x) {
	        return new RamlWrapper.FixedUriImpl(x);
	    },
	    "FullUriTemplate": function (x) {
	        return new RamlWrapper.FullUriTemplateImpl(x);
	    },
	    "GlobalSchema": function (x) {
	        return new RamlWrapper.GlobalSchemaImpl(x);
	    },
	    "HasNormalParameters": function (x) {
	        return new RamlWrapper.HasNormalParametersImpl(x);
	    },
	    "IntegerElement": function (x) {
	        return new RamlWrapper.IntegerElementImpl(x);
	    },
	    "JSONBody": function (x) {
	        return new RamlWrapper.JSONBodyImpl(x);
	    },
	    "JSONExample": function (x) {
	        return new RamlWrapper.JSONExampleImpl(x);
	    },
	    "JSonSchemaString": function (x) {
	        return new RamlWrapper.JSonSchemaStringImpl(x);
	    },
	    "MarkdownString": function (x) {
	        return new RamlWrapper.MarkdownStringImpl(x);
	    },
	    "Method": function (x) {
	        return new RamlWrapper.MethodImpl(x);
	    },
	    "MethodBase": function (x) {
	        return new RamlWrapper.MethodBaseImpl(x);
	    },
	    "MimeType": function (x) {
	        return new RamlWrapper.MimeTypeImpl(x);
	    },
	    "NumberElement": function (x) {
	        return new RamlWrapper.NumberElementImpl(x);
	    },
	    "NumberType": function (x) {
	        return new RamlWrapper.NumberTypeImpl(x);
	    },
	    "OAuth1SecuritySchemeSettings": function (x) {
	        return new RamlWrapper.OAuth1SecuritySchemeSettingsImpl(x);
	    },
	    "OAuth2SecuritySchemeSettings": function (x) {
	        return new RamlWrapper.OAuth2SecuritySchemeSettingsImpl(x);
	    },
	    "Parameter": function (x) {
	        return new RamlWrapper.ParameterImpl(x);
	    },
	    "ParameterLocation": function (x) {
	        return new RamlWrapper.ParameterLocationImpl(x);
	    },
	    "RAMLLanguageElement": function (x) {
	        return new RamlWrapper.RAMLLanguageElementImpl(x);
	    },
	    "RAMLSimpleElement": function (x) {
	        return new RamlWrapper.RAMLSimpleElementImpl(x);
	    },
	    "Reference": function (x) {
	        return new RamlWrapper.ReferenceImpl(x);
	    },
	    "RelativeUri": function (x) {
	        return new RamlWrapper.RelativeUriImpl(x);
	    },
	    "Resource": function (x) {
	        return new RamlWrapper.ResourceImpl(x);
	    },
	    "ResourceType": function (x) {
	        return new RamlWrapper.ResourceTypeImpl(x);
	    },
	    "ResourceTypeRef": function (x) {
	        return new RamlWrapper.ResourceTypeRefImpl(x);
	    },
	    "Response": function (x) {
	        return new RamlWrapper.ResponseImpl(x);
	    },
	    "SchemaString": function (x) {
	        return new RamlWrapper.SchemaStringImpl(x);
	    },
	    "SecuritySchema": function (x) {
	        return new RamlWrapper.SecuritySchemaImpl(x);
	    },
	    "SecuritySchemaPart": function (x) {
	        return new RamlWrapper.SecuritySchemaPartImpl(x);
	    },
	    "SecuritySchemaRef": function (x) {
	        return new RamlWrapper.SecuritySchemaRefImpl(x);
	    },
	    "SecuritySchemaSettings": function (x) {
	        return new RamlWrapper.SecuritySchemaSettingsImpl(x);
	    },
	    "StatusCode": function (x) {
	        return new RamlWrapper.StatusCodeImpl(x);
	    },
	    "StrElement": function (x) {
	        return new RamlWrapper.StrElementImpl(x);
	    },
	    "StringType": function (x) {
	        return new RamlWrapper.StringTypeImpl(x);
	    },
	    "Trait": function (x) {
	        return new RamlWrapper.TraitImpl(x);
	    },
	    "TraitRef": function (x) {
	        return new RamlWrapper.TraitRefImpl(x);
	    },
	    "UriTemplate": function (x) {
	        return new RamlWrapper.UriTemplateImpl(x);
	    },
	    "ValueType": function (x) {
	        return new RamlWrapper.ValueTypeImpl(x);
	    },
	    "XMLBody": function (x) {
	        return new RamlWrapper.XMLBodyImpl(x);
	    },
	    "XMLExample": function (x) {
	        return new RamlWrapper.XMLExampleImpl(x);
	    },
	    "XMLSchemaString": function (x) {
	        return new RamlWrapper.XMLSchemaStringImpl(x);
	    }
	};
	//# sourceMappingURL=raml08factory.js.map

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	var DomParser = __webpack_require__(106);
	function xmlToJson(xml) {
	    // Create the return object
	    var obj = {};
	    if (xml.nodeType == 1) {
	        // do attributes
	        if (xml.attributes.length > 0) {
	            for (var j = 0; j < xml.attributes.length; j++) {
	                var attribute = xml.attributes.item(j);
	                obj["@" + attribute.nodeName] = attribute.nodeValue;
	            }
	        }
	    }
	    else if (xml.nodeType == 3) {
	        obj = xml.nodeValue;
	    }
	    // do children
	    if (xml.hasChildNodes()) {
	        for (var i = 0; i < xml.childNodes.length; i++) {
	            var item = xml.childNodes.item(i);
	            var nodeName = item.nodeName;
	            if (nodeName == undefined) {
	                continue;
	            }
	            if (typeof (obj[nodeName]) == "undefined") {
	                obj[nodeName] = xmlToJson(item);
	            }
	            else {
	                if (typeof (obj[nodeName].push) == "undefined") {
	                    var old = obj[nodeName];
	                    obj[nodeName] = [];
	                    obj[nodeName].push(old);
	                }
	                obj[nodeName].push(xmlToJson(item));
	            }
	        }
	    }
	    return obj;
	}
	;
	function cleanupText(j) {
	    for (var p in j) {
	        if (typeof (j[p]) == "object") {
	            for (var k in j[p]) {
	                if (k == '#text') {
	                    var txt = j[p]['#text'];
	                    if (typeof (txt) != 'string') {
	                        txt = txt.join("");
	                    }
	                    txt = txt.trim();
	                    if (txt.length == 0) {
	                        delete j[p]['#text'];
	                    }
	                }
	            }
	            cleanupText(j[p]);
	        }
	    }
	    return j;
	}
	function cleanupJson(j) {
	    for (var p in j) {
	        if (typeof (j[p]) == "object") {
	            var keys = Object.keys(j[p]);
	            if (keys.length == 1) {
	                if (keys[0] == '#text') {
	                    j[p] = j[p]['#text'];
	                }
	            }
	            cleanupJson(j[p]);
	        }
	    }
	    return j;
	}
	function parseXML(value) {
	    var v = new DomParser.DOMParser();
	    var parsed = v.parseFromString(value);
	    return cleanupJson(cleanupText(xmlToJson(parsed)));
	}
	module.exports = parseXML;
	//# sourceMappingURL=xmlutil.js.map

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = this.__extends || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	/// <reference path="../../typings/tsd.d.ts" />
	var ts = __webpack_require__(42);
	/***
	 * This module is designed to match simple patterns on Typescript AST Tree
	 * it functionality mirrors jsASTMatchers which allows you to match on jsAST
	 */
	//TODO RENAME TO MATCHERS
	var Matching;
	(function (Matching) {
	    /**
	     * do match checks the node type and if node type is ok
	     * calls match function otherwise it returns null
	     */
	    var BasicMatcher = (function () {
	        function BasicMatcher() {
	        }
	        BasicMatcher.prototype.match = function (node) {
	            throw new Error();
	        };
	        BasicMatcher.prototype.nodeType = function () {
	            throw new Error();
	        };
	        BasicMatcher.prototype.doMatch = function (n) {
	            if (!n) {
	                return null;
	            }
	            if (this.nodeType() == n.kind) {
	                return this.match(n);
	            }
	        };
	        return BasicMatcher;
	    })();
	    var ClassDeclarationMatcher = (function (_super) {
	        __extends(ClassDeclarationMatcher, _super);
	        function ClassDeclarationMatcher() {
	            _super.call(this);
	        }
	        ClassDeclarationMatcher.prototype.match = function (node) {
	            return node;
	        };
	        ClassDeclarationMatcher.prototype.nodeType = function () {
	            return 185 /* ClassDeclaration */;
	        };
	        return ClassDeclarationMatcher;
	    })(BasicMatcher);
	    var FieldMatcher = (function (_super) {
	        __extends(FieldMatcher, _super);
	        function FieldMatcher() {
	            _super.apply(this, arguments);
	        }
	        FieldMatcher.prototype.match = function (node) {
	            return node;
	        };
	        FieldMatcher.prototype.nodeType = function () {
	            return 124 /* Property */;
	        };
	        return FieldMatcher;
	    })(BasicMatcher);
	    var AssignmentExpressionMatcher = (function (_super) {
	        __extends(AssignmentExpressionMatcher, _super);
	        function AssignmentExpressionMatcher(left, right, tr) {
	            _super.call(this);
	            this.left = left;
	            this.right = right;
	            this.tr = tr;
	        }
	        AssignmentExpressionMatcher.prototype.match = function (node) {
	            if (node.operator == 51 /* EqualsToken */) {
	                if (this.left.doMatch(node.left) && this.right.doMatch(node.right)) {
	                    return this.tr(node);
	                }
	            }
	            return null;
	        };
	        AssignmentExpressionMatcher.prototype.nodeType = function () {
	            return 157 /* BinaryExpression */;
	        };
	        return AssignmentExpressionMatcher;
	    })(BasicMatcher);
	    var VariableDeclarationMatcher = (function (_super) {
	        __extends(VariableDeclarationMatcher, _super);
	        function VariableDeclarationMatcher(left, right, tr) {
	            _super.call(this);
	            this.left = left;
	            this.right = right;
	            this.tr = tr;
	        }
	        VariableDeclarationMatcher.prototype.match = function (node) {
	            if (this.left.doMatch(node.name) && this.right.doMatch(node.initializer)) {
	                return this.tr(node);
	            }
	        };
	        VariableDeclarationMatcher.prototype.nodeType = function () {
	            return 183 /* VariableDeclaration */;
	        };
	        return VariableDeclarationMatcher;
	    })(BasicMatcher);
	    var ExpressionStatementMatcher = (function (_super) {
	        __extends(ExpressionStatementMatcher, _super);
	        function ExpressionStatementMatcher(expression, tr) {
	            _super.call(this);
	            this.expression = expression;
	            this.tr = tr;
	        }
	        ExpressionStatementMatcher.prototype.match = function (node) {
	            var exp = this.expression.doMatch(node.expression);
	            if (exp) {
	                var v = this.tr(node.expression);
	                if (v == true) {
	                    return exp;
	                }
	                return v;
	            }
	            return null;
	        };
	        ExpressionStatementMatcher.prototype.nodeType = function () {
	            return 166 /* ExpressionStatement */;
	        };
	        return ExpressionStatementMatcher;
	    })(BasicMatcher);
	    var SimpleIdentMatcher = (function (_super) {
	        __extends(SimpleIdentMatcher, _super);
	        function SimpleIdentMatcher(val) {
	            _super.call(this);
	            this.val = val;
	        }
	        SimpleIdentMatcher.prototype.match = function (node) {
	            if (node.text == this.val) {
	                return true;
	            }
	            return null;
	        };
	        SimpleIdentMatcher.prototype.nodeType = function () {
	            return 63 /* Identifier */;
	        };
	        return SimpleIdentMatcher;
	    })(BasicMatcher);
	    var TrueMatcher = (function () {
	        function TrueMatcher() {
	        }
	        TrueMatcher.prototype.doMatch = function (node) {
	            return true;
	        };
	        TrueMatcher.prototype.nodeType = function () {
	            return null;
	        };
	        return TrueMatcher;
	    })();
	    var CallExpressionMatcher = (function (_super) {
	        __extends(CallExpressionMatcher, _super);
	        function CallExpressionMatcher(calleeMatcher, tr) {
	            _super.call(this);
	            this.calleeMatcher = calleeMatcher;
	            this.tr = tr;
	        }
	        CallExpressionMatcher.prototype.match = function (node) {
	            if (this.calleeMatcher.doMatch(node.expression)) {
	                return this.tr(node);
	            }
	            return null;
	        };
	        CallExpressionMatcher.prototype.nodeType = function () {
	            return 145 /* CallExpression */;
	        };
	        return CallExpressionMatcher;
	    })(BasicMatcher);
	    Matching.SKIP = {};
	    function visit(n, cb) {
	        var r0 = cb(n);
	        if (r0) {
	            if (r0 == Matching.SKIP) {
	                return null;
	            }
	            return r0;
	        }
	        var r = ts.forEachChild(n, function (x) {
	            var r = visit(x, cb);
	            if (r) {
	                return r;
	            }
	        });
	        return r;
	    }
	    Matching.visit = visit;
	    var PathNode = (function () {
	        function PathNode(name, _base) {
	            this._base = _base;
	            this.arguments = null;
	            this.name = name;
	        }
	        return PathNode;
	    })();
	    var CallPath = (function () {
	        function CallPath(base, _baseNode) {
	            this._baseNode = _baseNode;
	            this.path = [];
	            this.base = base;
	        }
	        CallPath.prototype.start = function () {
	            return this._baseNode.pos;
	        };
	        CallPath.prototype.startLocation = function () {
	            return this._baseNode.getSourceFile().getLineAndCharacterFromPosition(this.start());
	        };
	        CallPath.prototype.endLocation = function () {
	            return this._baseNode.getSourceFile().getLineAndCharacterFromPosition(this.end());
	        };
	        CallPath.prototype.end = function () {
	            var ce = this.path[this.path.length - 1]._callExpression;
	            if (ce) {
	                return ce.end;
	            }
	            return this.start();
	        };
	        CallPath.prototype.toString = function () {
	            return this.path.map(function (x) { return x.name; }).join(".");
	        };
	        return CallPath;
	    })();
	    Matching.CallPath = CallPath;
	    var MemberExpressionMatcher = (function (_super) {
	        __extends(MemberExpressionMatcher, _super);
	        function MemberExpressionMatcher(objectMatcher, propertyMatcher, tr) {
	            _super.call(this);
	            this.objectMatcher = objectMatcher;
	            this.propertyMatcher = propertyMatcher;
	            this.tr = tr;
	        }
	        MemberExpressionMatcher.prototype.match = function (node) {
	            if (this.objectMatcher.doMatch(node.expression) && this.propertyMatcher.doMatch(node.name)) {
	                return this.tr(node);
	            }
	            return null;
	        };
	        MemberExpressionMatcher.prototype.nodeType = function () {
	            return 143 /* PropertyAccessExpression */;
	        };
	        return MemberExpressionMatcher;
	    })(BasicMatcher);
	    function memberFromExp(objMatcher, tr) {
	        if (tr === void 0) { tr = function (x) { return true; }; }
	        var array = objMatcher.split(".");
	        var result = null;
	        for (var a = 0; a < array.length; a++) {
	            var arg = array[a];
	            var ci = arg.indexOf("(*)");
	            var isCall = false;
	            if (ci != -1) {
	                arg = arg.substr(0, ci);
	                isCall = true;
	            }
	            if (result == null) {
	                result = arg == '*' ? anyNode() : ident(arg);
	            }
	            else {
	                result = new MemberExpressionMatcher(result, arg == '*' ? anyNode() : ident(arg), tr);
	            }
	            if (isCall) {
	                result = new CallExpressionMatcher(result, tr);
	            }
	        }
	        //console.log(result)
	        return result;
	    }
	    Matching.memberFromExp = memberFromExp;
	    var CallBaseMatcher = (function () {
	        function CallBaseMatcher(rootMatcher) {
	            this.rootMatcher = rootMatcher;
	        }
	        CallBaseMatcher.prototype.doMatch = function (node) {
	            var original = node;
	            if (node.kind == 145 /* CallExpression */) {
	                var call = node;
	                var res = this.doMatch(call.expression);
	                if (res) {
	                    if (res.path.length > 0 && res.path[res.path.length - 1].arguments == null) {
	                        res.path[res.path.length - 1].arguments = call.arguments;
	                        res.path[res.path.length - 1]._callExpression = call;
	                        return res;
	                    }
	                    //This case should not exist in type script clients now
	                    //but leaving it here for possible future use at the moment;
	                    //if (res.path.length==0&&call.arguments.length==1){
	                    //    //this is not resource based call!!!
	                    //    if (call.arguments[0].kind==ts.SyntaxKind.StringLiteral){
	                    //        var l:ts.LiteralExpression=<ts.LiteralExpression>call.arguments[0];
	                    //        var url=l.text;
	                    //        var uriPath=url.toString().split("/");
	                    //        uriPath.forEach(x=>res.path.push(
	                    //            new PathNode(x)
	                    //        ))
	                    //        return res;
	                    //    }
	                    //}
	                    return null;
	                }
	            }
	            else if (node.kind == 143 /* PropertyAccessExpression */) {
	                var me = node;
	                var v = this.doMatch(me.expression);
	                if (v) {
	                    if (me.name.kind == 63 /* Identifier */) {
	                        v.path.push(new PathNode(me.name.text, me.name));
	                        return v;
	                    }
	                    return null;
	                }
	            }
	            else if (node.kind == 63 /* Identifier */) {
	                var id = node;
	                if (this.rootMatcher.doMatch(id)) {
	                    return new CallPath(id.text, id);
	                }
	            }
	            return null;
	        };
	        CallBaseMatcher.prototype.nodeType = function () {
	            return null;
	        };
	        return CallBaseMatcher;
	    })();
	    Matching.CallBaseMatcher = CallBaseMatcher;
	    function ident(name) {
	        return new SimpleIdentMatcher(name);
	    }
	    Matching.ident = ident;
	    function anyNode() {
	        return new TrueMatcher();
	    }
	    Matching.anyNode = anyNode;
	    function call(calleeMatcher, tr) {
	        if (tr === void 0) { tr = function (x) { return true; }; }
	        return new CallExpressionMatcher(calleeMatcher, tr);
	    }
	    Matching.call = call;
	    function exprStmt(eM, tr) {
	        if (tr === void 0) { tr = function (x) { return true; }; }
	        return new ExpressionStatementMatcher(eM, tr);
	    }
	    Matching.exprStmt = exprStmt;
	    function assign(left, right, tr) {
	        if (tr === void 0) { tr = function (x) { return true; }; }
	        return new AssignmentExpressionMatcher(left, right, tr);
	    }
	    Matching.assign = assign;
	    function varDecl(left, right, tr) {
	        if (tr === void 0) { tr = function (x) { return true; }; }
	        return new VariableDeclarationMatcher(left, right, tr);
	    }
	    Matching.varDecl = varDecl;
	    function field() {
	        return new FieldMatcher();
	    }
	    Matching.field = field;
	    function classDeclaration() {
	        return new ClassDeclarationMatcher();
	    }
	    Matching.classDeclaration = classDeclaration;
	})(Matching = exports.Matching || (exports.Matching = {}));
	//# sourceMappingURL=tsASTMatchers.js.map

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    draining = true;
	    var currentQueue;
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        var i = -1;
	        while (++i < len) {
	            currentQueue[i]();
	        }
	        len = queue.length;
	    }
	    draining = false;
	}
	process.nextTick = function (fun) {
	    queue.push(fun);
	    if (!draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var json = typeof JSON !== 'undefined' ? JSON : __webpack_require__(108);

	module.exports = function (obj, opts) {
	    if (!opts) opts = {};
	    if (typeof opts === 'function') opts = { cmp: opts };
	    var space = opts.space || '';
	    if (typeof space === 'number') space = Array(space+1).join(' ');
	    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
	    var replacer = opts.replacer || function(key, value) { return value; };

	    var cmp = opts.cmp && (function (f) {
	        return function (node) {
	            return function (a, b) {
	                var aobj = { key: a, value: node[a] };
	                var bobj = { key: b, value: node[b] };
	                return f(aobj, bobj);
	            };
	        };
	    })(opts.cmp);

	    var seen = [];
	    return (function stringify (parent, key, node, level) {
	        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
	        var colonSeparator = space ? ': ' : ':';

	        if (node && node.toJSON && typeof node.toJSON === 'function') {
	            node = node.toJSON();
	        }

	        node = replacer.call(parent, key, node);

	        if (node === undefined) {
	            return;
	        }
	        if (typeof node !== 'object' || node === null) {
	            return json.stringify(node);
	        }
	        if (isArray(node)) {
	            var out = [];
	            for (var i = 0; i < node.length; i++) {
	                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
	                out.push(indent + space + item);
	            }
	            return '[' + out.join(',') + indent + ']';
	        }
	        else {
	            if (seen.indexOf(node) !== -1) {
	                if (cycles) return json.stringify('__cycle__');
	                throw new TypeError('Converting circular structure to JSON');
	            }
	            else seen.push(node);

	            var keys = objectKeys(node).sort(cmp && cmp(node));
	            var out = [];
	            for (var i = 0; i < keys.length; i++) {
	                var key = keys[i];
	                var value = stringify(node, key, node[key], level+1);

	                if(!value) continue;

	                var keyValue = json.stringify(key)
	                    + colonSeparator
	                    + value;
	                ;
	                out.push(indent + space + keyValue);
	            }
	            return '{' + out.join(',') + indent + '}';
	        }
	    })({ '': obj }, '', obj, 0);
	};

	var isArray = Array.isArray || function (x) {
	    return {}.toString.call(x) === '[object Array]';
	};

	var objectKeys = Object.keys || function (obj) {
	    var has = Object.prototype.hasOwnProperty || function () { return true };
	    var keys = [];
	    for (var key in obj) {
	        if (has.call(obj, key)) keys.push(key);
	    }
	    return keys;
	};


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	// when used in node, this will actually load the util module we depend on
	// versus loading the builtin util module as happens otherwise
	// this is a bug in node module loading as far as I am concerned
	var util = __webpack_require__(107);

	var pSlice = Array.prototype.slice;
	var hasOwn = Object.prototype.hasOwnProperty;

	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.

	var assert = module.exports = ok;

	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })

	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;

	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  }
	  else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;

	      // try to strip useless frames
	      var fn_name = stackStartFunction.name;
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }

	      this.stack = out;
	    }
	  }
	};

	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);

	function replacer(key, value) {
	  if (util.isUndefined(value)) {
	    return '' + value;
	  }
	  if (util.isNumber(value) && !isFinite(value)) {
	    return value.toString();
	  }
	  if (util.isFunction(value) || util.isRegExp(value)) {
	    return value.toString();
	  }
	  return value;
	}

	function truncate(s, n) {
	  if (util.isString(s)) {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}

	function getMessage(self) {
	  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(JSON.stringify(self.expected, replacer), 128);
	}

	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.

	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.

	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}

	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;

	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.

	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;

	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);

	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};

	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);

	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};

	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);

	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};

	function _deepEqual(actual, expected) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;

	  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
	    if (actual.length != expected.length) return false;

	    for (var i = 0; i < actual.length; i++) {
	      if (actual[i] !== expected[i]) return false;
	    }

	    return true;

	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();

	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;

	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!util.isObject(actual) && !util.isObject(expected)) {
	    return actual == expected;

	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected);
	  }
	}

	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}

	function objEquiv(a, b) {
	  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b)) {
	    return a === b;
	  }
	  var aIsArgs = isArguments(a),
	      bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b);
	  }
	  var ka = objectKeys(a),
	      kb = objectKeys(b),
	      key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key])) return false;
	  }
	  return true;
	}

	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);

	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};

	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);

	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};

	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};

	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }

	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  } else if (actual instanceof expected) {
	    return true;
	  } else if (expected.call({}, actual) === true) {
	    return true;
	  }

	  return false;
	}

	function _throws(shouldThrow, block, expected, message) {
	  var actual;

	  if (util.isString(expected)) {
	    message = expected;
	    expected = null;
	  }

	  try {
	    block();
	  } catch (e) {
	    actual = e;
	  }

	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');

	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }

	  if (!shouldThrow && expectedException(actual, expected)) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }

	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}

	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);

	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws.apply(this, [true].concat(pSlice.call(arguments)));
	};

	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/message) {
	  _throws.apply(this, [false].concat(pSlice.call(arguments)));
	};

	assert.ifError = function(err) { if (err) {throw err;}};

	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = Response;

	/**
	 * A response from a web request
	 *
	 * @param {Number} statusCode
	 * @param {Object} headers
	 * @param {Buffer} body
	 * @param {String} url
	 */
	function Response(statusCode, headers, body, url) {
	  if (typeof statusCode !== 'number') {
	    throw new TypeError('statusCode must be a number but was ' + (typeof statusCode));
	  }
	  if (headers === null) {
	    throw new TypeError('headers cannot be null');
	  }
	  if (typeof headers !== 'object') {
	    throw new TypeError('headers must be an object but was ' + (typeof headers));
	  }
	  this.statusCode = statusCode;
	  this.headers = {};
	  for (var key in headers) {
	    this.headers[key.toLowerCase()] = headers[key];
	  }
	  this.body = body;
	  this.url = url;
	}

	Response.prototype.getBody = function (encoding) {
	  if (this.statusCode >= 300) {
	    var err = new Error('Server responded with status code '
	                    + this.statusCode + ':\n' + this.body.toString());
	    err.statusCode = this.statusCode;
	    err.headers = this.headers;
	    err.body = this.body;
	    err.url = this.url;
	    throw err;
	  }
	  return encoding ? this.body.toString(encoding) : this.body;
	};


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var Writable = __webpack_require__(117).Writable
	var inherits = __webpack_require__(118)

	if (typeof Uint8Array === 'undefined') {
	  var U8 = __webpack_require__(109).Uint8Array
	} else {
	  var U8 = Uint8Array
	}

	function ConcatStream(opts, cb) {
	  if (!(this instanceof ConcatStream)) return new ConcatStream(opts, cb)

	  if (typeof opts === 'function') {
	    cb = opts
	    opts = {}
	  }
	  if (!opts) opts = {}

	  var encoding = opts.encoding
	  var shouldInferEncoding = false

	  if (!encoding) {
	    shouldInferEncoding = true
	  } else {
	    encoding =  String(encoding).toLowerCase()
	    if (encoding === 'u8' || encoding === 'uint8') {
	      encoding = 'uint8array'
	    }
	  }

	  Writable.call(this, { objectMode: true })

	  this.encoding = encoding
	  this.shouldInferEncoding = shouldInferEncoding

	  if (cb) this.on('finish', function () { cb(this.getBody()) })
	  this.body = []
	}

	module.exports = ConcatStream
	inherits(ConcatStream, Writable)

	ConcatStream.prototype._write = function(chunk, enc, next) {
	  this.body.push(chunk)
	  next()
	}

	ConcatStream.prototype.inferEncoding = function (buff) {
	  var firstBuffer = buff === undefined ? this.body[0] : buff;
	  if (Buffer.isBuffer(firstBuffer)) return 'buffer'
	  if (typeof Uint8Array !== 'undefined' && firstBuffer instanceof Uint8Array) return 'uint8array'
	  if (Array.isArray(firstBuffer)) return 'array'
	  if (typeof firstBuffer === 'string') return 'string'
	  if (Object.prototype.toString.call(firstBuffer) === "[object Object]") return 'object'
	  return 'buffer'
	}

	ConcatStream.prototype.getBody = function () {
	  if (!this.encoding && this.body.length === 0) return []
	  if (this.shouldInferEncoding) this.encoding = this.inferEncoding()
	  if (this.encoding === 'array') return arrayConcat(this.body)
	  if (this.encoding === 'string') return stringConcat(this.body)
	  if (this.encoding === 'buffer') return bufferConcat(this.body)
	  if (this.encoding === 'uint8array') return u8Concat(this.body)
	  return this.body
	}

	var isArray = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]'
	}

	function isArrayish (arr) {
	  return /Array\]$/.test(Object.prototype.toString.call(arr))
	}

	function stringConcat (parts) {
	  var strings = []
	  var needsToString = false
	  for (var i = 0; i < parts.length; i++) {
	    var p = parts[i]
	    if (typeof p === 'string') {
	      strings.push(p)
	    } else if (Buffer.isBuffer(p)) {
	      strings.push(p)
	    } else {
	      strings.push(Buffer(p))
	    }
	  }
	  if (Buffer.isBuffer(parts[0])) {
	    strings = Buffer.concat(strings)
	    strings = strings.toString('utf8')
	  } else {
	    strings = strings.join('')
	  }
	  return strings
	}

	function bufferConcat (parts) {
	  var bufs = []
	  for (var i = 0; i < parts.length; i++) {
	    var p = parts[i]
	    if (Buffer.isBuffer(p)) {
	      bufs.push(p)
	    } else if (typeof p === 'string' || isArrayish(p)
	    || (p && typeof p.subarray === 'function')) {
	      bufs.push(Buffer(p))
	    } else bufs.push(Buffer(String(p)))
	  }
	  return Buffer.concat(bufs)
	}

	function arrayConcat (parts) {
	  var res = []
	  for (var i = 0; i < parts.length; i++) {
	    res.push.apply(res, parts[i])
	  }
	  return res
	}

	function u8Concat (parts) {
	  var len = 0
	  for (var i = 0; i < parts.length; i++) {
	    if (typeof parts[i] === 'string') {
	      parts[i] = Buffer(parts[i])
	    }
	    len += parts[i].length
	  }
	  var u8 = new U8(len)
	  for (var i = 0, offset = 0; i < parts.length; i++) {
	    var part = parts[i]
	    for (var j = 0; j < part.length; j++) {
	      u8[offset++] = part[j]
	    }
	  }
	  return u8
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(77).Buffer))

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */

	var base64 = __webpack_require__(119)
	var ieee754 = __webpack_require__(115)
	var isArray = __webpack_require__(114)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation

	var kMaxLength = 0x3fffffff
	var rootParent = {}

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Note:
	 *
	 * - Implementation must support adding new properties to `Uint8Array` instances.
	 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
	 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *    incorrect length in some situations.
	 *
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
	 * get the Object implementation, which is slower but will work correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = (function () {
	  try {
	    var buf = new ArrayBuffer(0)
	    var arr = new Uint8Array(buf)
	    arr.foo = function () { return 42 }
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	})()

	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }

	  this.length = 0
	  this.parent = undefined

	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }

	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }

	  // Unusual.
	  return fromObject(this, arg)
	}

	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)

	  that.write(string, encoding)
	  return that
	}

	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

	  if (isArray(object)) return fromArray(that, object)

	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && object.buffer instanceof ArrayBuffer) {
	    return fromTypedArray(that, object)
	  }

	  if (object.length) return fromArrayLike(that, object)

	  return fromJsonObject(that, object)
	}

	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}

	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0

	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)

	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }

	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent

	  return that
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength.toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break

	    ++i
	  }

	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

	  if (list.length === 0) {
	    return new Buffer(0)
	  } else if (list.length === 1) {
	    return list[0]
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }

	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}

	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = String(string)

	  if (string.length === 0) return 0

	  switch (encoding || 'utf8') {
	    case 'ascii':
	    case 'binary':
	    case 'raw':
	      return string.length
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return string.length * 2
	    case 'hex':
	      return string.length >>> 1
	    case 'utf8':
	    case 'utf-8':
	      return utf8ToBytes(string).length
	    case 'base64':
	      return base64ToBytes(string).length
	    default:
	      return string.length
	  }
	}
	Buffer.byteLength = byteLength

	// pre-set for values that may exist in the future
	Buffer.prototype.length = undefined
	Buffer.prototype.parent = undefined

	// toString(encoding, start=0, end=buffer.length)
	Buffer.prototype.toString = function toString (encoding, start, end) {
	  var loweredCase = false

	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0

	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'binary':
	        return binarySlice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0

	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1

	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }

	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	// `get` will be removed in Node 0.13+
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}

	// `set` will be removed in Node 0.13+
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'binary':
	        return binaryWrite(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  var res = ''
	  var tmp = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    if (buf[i] <= 0x7F) {
	      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
	      tmp = ''
	    } else {
	      tmp += '%' + buf[i].toString(16)
	    }
	  }

	  return res + decodeUtf8Char(tmp)
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  if (newBuf.length) newBuf.parent = this.parent || this

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = value
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = value
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = value
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = value
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = value
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = value
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = value
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start

	  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }

	  return len
	}

	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length

	  if (end < start) throw new RangeError('end < start')

	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return

	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }

	  return this
	}

	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}

	// HELPER FUNCTIONS
	// ================

	var BP = Buffer.prototype

	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true

	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set

	  // deprecated, will be removed in node 0.13+
	  arr.get = BP.get
	  arr.set = BP.set

	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer

	  return arr
	}

	var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	  var i = 0

	  for (; i < length; i++) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (leadSurrogate) {
	        // 2 leads in a row
	        if (codePoint < 0xDC00) {
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          leadSurrogate = codePoint
	          continue
	        } else {
	          // valid surrogate pair
	          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
	          leadSurrogate = null
	        }
	      } else {
	        // no lead yet

	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else {
	          // valid lead
	          leadSurrogate = codePoint
	          continue
	        }
	      }
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	      leadSurrogate = null
	    }

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x200000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	function decodeUtf8Char (str) {
	  try {
	    return decodeURIComponent(str)
	  } catch (err) {
	    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(77).Buffer))

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = schema;

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// **Github:** https://github.com/zensh/lrucache
	//
	// **License:** MIT

	/* global module, define */
	;(function (root, factory) {
	  'use strict';

	  if (typeof module === 'object' && typeof module.exports === 'object') {
	    module.exports = factory();
	  } else if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else {
	    root.LRUCache = factory();
	  }
	}(typeof window === 'object' ? window : this, function () {
	  'use strict';

	  function CacheState(capacity) {
	    this.capacity = capacity > 0 ? +capacity : Number.MAX_VALUE;
	    this.data = Object.create ? Object.create(null) : {};
	    this.hash = Object.create ? Object.create(null) : {};
	    this.linkedList = {
	      length: 0,
	      head: null,
	      end: null
	    };
	  }

	  function LRUCache(capacity) {
	    if (!(this instanceof LRUCache)) return new LRUCache(capacity);
	    this._LRUCacheState = new CacheState(capacity);
	  }

	  var proto = LRUCache.prototype;

	  proto.get = function (key) {
	    var state = this._LRUCacheState;
	    var lruEntry = state.hash[key];
	    if (!lruEntry) return;
	    refresh(state.linkedList, lruEntry);
	    return state.data[key];
	  };

	  proto.set = function (key, value) {
	    var state = this._LRUCacheState;
	    var lruEntry = state.hash[key];
	    if (value === undefined) return this;
	    if (!lruEntry) {
	      state.hash[key] = {key: key};
	      state.linkedList.length += 1;
	      lruEntry = state.hash[key];
	    }
	    refresh(state.linkedList, lruEntry);
	    state.data[key] = value;
	    if (state.linkedList.length > state.capacity) this.remove(state.linkedList.end.key);
	    return this;
	  };

	  proto.update = function (key, parseFn) {
	    var state = this._LRUCacheState;
	    if (this.has(key)) {
	      var data = this.get(key);
	      this.set(key, parseFn(data));
	    }
	    return this;
	  };

	  proto.remove = function (key) {
	    var state = this._LRUCacheState;
	    var lruEntry = state.hash[key];
	    if (!lruEntry) return this;
	    if (lruEntry === state.linkedList.head) state.linkedList.head = lruEntry.p;
	    if (lruEntry === state.linkedList.end) state.linkedList.end = lruEntry.n;
	    link(lruEntry.n, lruEntry.p);
	    delete state.hash[key];
	    delete state.data[key];
	    state.linkedList.length -= 1;
	    return this;
	  };

	  proto.removeAll = function () {
	    this._LRUCacheState = new CacheState(this._LRUCacheState.capacity);
	    return this;
	  };

	  proto.info = function () {
	    var state = this._LRUCacheState;
	    return {
	      capacity: state.capacity,
	      length: state.linkedList.length
	    };
	  };

	  proto.keys = function () {
	    var state = this._LRUCacheState;
	    var keys = [], lruEntry = state.linkedList.head;
	    while (lruEntry) {
	      keys.push(lruEntry.key);
	      lruEntry = lruEntry.p;
	    }
	    return keys;
	  };

	  proto.has = function (key) {
	    return !!this._LRUCacheState.hash[key];
	  };

	  proto.staleKey = function () {
	    return this._LRUCacheState.linkedList.end && this._LRUCacheState.linkedList.end.key;
	  };

	  proto.popStale = function () {
	    var staleKey = this.staleKey();
	    if (!staleKey) return null;
	    var stale = [staleKey, this._LRUCacheState.data[staleKey]];
	    this.remove(staleKey);
	    return stale;
	  };

	  // 更新链表，把get或put方法操作的key提到链表head，即表示最新
	  function refresh(linkedList, entry) {
	    if (entry === linkedList.head) return;
	    if (!linkedList.end) {
	      linkedList.end = entry;
	    } else if (linkedList.end === entry) {
	      linkedList.end = entry.n;
	    }

	    link(entry.n, entry.p);
	    link(entry, linkedList.head);
	    linkedList.head = entry;
	    linkedList.head.n = null;
	  }

	  // 对两个链表对象建立链接，形成一条链
	  function link(nextEntry, prevEntry) {
	    if (nextEntry === prevEntry) return;
	    if (nextEntry) nextEntry.p = prevEntry;
	    if (prevEntry) prevEntry.n = nextEntry;
	  }

	  LRUCache.NAME = 'LRUCache';
	  LRUCache.VERSION = 'v0.2.0';
	  return LRUCache;
	}));


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(116);
	var Response = __webpack_require__(75);
	var handleQs = __webpack_require__(105);

	module.exports = doRequest;
	function doRequest(method, url, options, callback) {
	  var result = new Promise(function (resolve, reject) {
	    var xhr = new window.XMLHttpRequest();

	    // check types of arguments

	    if (typeof method !== 'string') {
	      throw new TypeError('The method must be a string.');
	    }
	    if (typeof url !== 'string') {
	      throw new TypeError('The URL/path must be a string.');
	    }
	    if (typeof options === 'function') {
	      callback = options;
	      options = {};
	    }
	    if (options === null || options === undefined) {
	      options = {};
	    }
	    if (typeof options !== 'object') {
	      throw new TypeError('Options must be an object (or null).');
	    }
	    if (typeof callback !== 'function') {
	      callback = undefined;
	    }

	    method = method.toUpperCase();
	    options.headers = options.headers || {};


	    function attempt(n) {
	      doRequest(method, url, {
	        qs: options.qs,
	        headers: options.headers,
	        timeout: options.timeout
	      }).nodeify(function (err, res) {
	        var retry = err || res.statusCode >= 400;
	        if (typeof options.retry === 'function') {
	          retry = options.retry(err, res, n + 1);
	        }
	        if (n >= (options.maxRetries | 5)) {
	          retry = false;
	        }
	        if (retry) {
	          var delay = options.retryDelay;
	          if (typeof options.retryDelay === 'function') {
	            delay = options.retryDelay(err, res, n + 1);
	          }
	          delay = delay || 200;
	          setTimeout(function () {
	            attempt(n + 1);
	          }, delay);
	        } else {
	          if (err) reject(err);
	          else resolve(res);
	        }
	      });
	    }
	    if (options.retry && method === 'GET') {
	      return attempt(0);
	    }

	    // handle cross domain

	    var match;
	    var crossDomain = !!((match = /^([\w-]+:)?\/\/([^\/]+)/.exec(options.uri)) && (match[2] != window.location.host));
	    if (!crossDomain) options.headers['X-Requested-With'] = 'XMLHttpRequest';

	    // handle query string
	    if (options.qs) {
	      url = handleQs(url, options.qs);
	    }

	    // handle json body
	    if (options.json) {
	      options.body = JSON.stringify(options.json);
	      options.headers['Content-Type'] = 'application/json';
	    }

	    if (options.timeout) {
	      xhr.timeout = options.timeout;
	      var start = Date.now();
	      xhr.ontimeout = function () {
	        var duration = Date.now() - start;
	        var err = new Error('Request timed out after ' + duration + 'ms');
	        err.timeout = true;
	        err.duration = duration;
	        reject(err);
	      };
	    }
	    xhr.onreadystatechange = function () {
	      if (xhr.readyState === 4) {
	        var headers = {};
	        xhr.getAllResponseHeaders().split('\r\n').forEach(function (header) {
	          var h = header.split(':');
	          if (h.length > 1) {
	            headers[h[0].toLowerCase()] = h.slice(1).join(':').trim();
	          }
	        });
	        var res = new Response(xhr.status, headers, xhr.responseText);
	        res.url = url;
	        resolve(res);
	      }
	    };

	    // method, url, async
	    xhr.open(method, url, true);

	    for (var name in options.headers) {
	      xhr.setRequestHeader(name, options.headers[name]);
	    }

	    // avoid sending empty string (#319)
	    xhr.send(options.body ? options.body : null);
	  });
	  result.getBody = function () {
	    return result.then(function (res) { return res.getBody(); });
	  };
	  return result.nodeify(callback);
	}


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*jshint node:true*/

	if (false) {
	    var define = require('amdefine')(module);
	}

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	    "use strict";

	    var statusCodes = __webpack_require__(110),
	        statusCodesToPhrases = {},
	        statusPhrasesToCodes = {},
	        methods = __webpack_require__(111),
	        headers = __webpack_require__(112),
	        relations = __webpack_require__(113);

	    statusCodes.forEach(function(item) {
	        var code = parseInt(item.code, 10),
	            phrase;

	        // Ignore codes for classes
	        if (code.toString() !== item.code) {
	            return;
	        }

	        phrase = item.phrase.toUpperCase().replace(/[^A-Z]/g, '_');

	        statusCodesToPhrases[code] = item.phrase;
	        statusPhrasesToCodes[phrase] = item.code;
	    });

	    return {
	        statusCodes: statusCodes,
	        statusCodesToPhrases: statusCodesToPhrases,
	        statusPhrasesToCodes: statusPhrasesToCodes,
	        methods: methods,
	        headers: headers,
	        relations: relations
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	function isEmpty(value) {
	    return value == null;
	}
	function toString(value) {
	    return isEmpty(value) ? '' : String(value);
	}
	function toBoolean(value) {
	    return [0, false, '', '0', 'false'].indexOf(value) === -1;
	}
	function toNumber(value) {
	    return isFinite(value) ? Number(value) : null;
	}
	function toInteger(value) {
	    return value % 1 === 0 ? Number(value) : null;
	}
	function toDate(value) {
	    return !isNaN(Date.parse(value)) ? new Date(value) : null;
	}
	function toSanitization(parameter, rules, types) {
	    var parameters = Array.isArray(parameter) ? parameter : [parameter];
	    var sanitizations = parameters.map(function (parameter) {
	        var fns = [];
	        var typeSanitization = types[parameter.type];
	        if (typeof typeSanitization === 'function') {
	            fns.push(typeSanitization);
	        }
	        Object.keys(parameter).filter(function (key) {
	            return key !== 'type' && key !== 'repeat' && key !== 'default';
	        }).forEach(function (key) {
	            var fn = rules[key];
	            if (typeof fn === 'function') {
	                fns.push(fn(parameter[key], key));
	            }
	        });
	        function sanitize(value, key, src) {
	            for (var i = 0; i < fns.length; i++) {
	                var fn = fns[i];
	                var value = fn(value, key, src);
	                if (value != null) {
	                    return value;
	                }
	            }
	            return null;
	        }
	        return function (value, key, src) {
	            if (isEmpty(value)) {
	                if (parameter.default != null) {
	                    return sanitize(parameter.default, key, src);
	                }
	                return parameter.repeat && !parameter.required ? [] : value;
	            }
	            if (parameter.repeat) {
	                var values = Array.isArray(value) ? value : [value];
	                values = values.map(function (value) {
	                    return sanitize(value, key, src);
	                });
	                return values.some(isEmpty) ? null : value;
	            }
	            if (Array.isArray(value)) {
	                if (value.length > 1) {
	                    return null;
	                }
	                value = value[0];
	            }
	            return sanitize(value, key, src);
	        };
	    });
	    return function (value, key, src) {
	        for (var i = 0; i < sanitizations.length; i++) {
	            var sanitization = sanitizations[i];
	            var result = sanitization(value, key, src);
	            if (result != null) {
	                return result;
	            }
	        }
	        return value;
	    };
	}
	function sanitize() {
	    var RULES = {};
	    var TYPES = {
	        string: toString,
	        number: toNumber,
	        integer: toInteger,
	        boolean: toBoolean,
	        date: toDate
	    };
	    function rule(parameter) {
	        return toSanitization(parameter, RULES, TYPES);
	    }
	    var sanitize = function (parameterMap) {
	        if (!parameterMap) {
	            return function () {
	                return {};
	            };
	        }
	        var sanitizations = {};
	        Object.keys(parameterMap).forEach(function (key) {
	            sanitizations[key] = sanitize.rule(parameterMap[key]);
	        });
	        return function (src) {
	            src = src || {};
	            var dest = {};
	            // Iterate the sanitized parameters to get a clean model.
	            Object.keys(sanitizations).forEach(function (key) {
	                var value = src[key];
	                var fn = sanitizations[key];
	                if (Object.prototype.hasOwnProperty.call(src, key)) {
	                    dest[key] = fn(value, key, src);
	                }
	            });
	            return dest;
	        };
	    };
	    var s;
	    s = sanitize;
	    s.rule = rule;
	    s.TYPES = TYPES;
	    s.RULES = RULES;
	    return s;
	}
	module.exports = sanitize;
	//# sourceMappingURL=raml-sanitize.js.map

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/// <reference path="../../typings/tsd.d.ts" />
	var _toString = Object.prototype.toString;
	function isDateType(check) {
	    return _toString.call(check) === '[object Date]' && !isNaN(check.getTime());
	}
	function isBooleanType(check) {
	    return typeof check === 'boolean';
	}
	function isStringType(check) {
	    return typeof check === 'string';
	}
	function isIntegerType(check) {
	    return typeof check === 'number' && check % 1 === 0;
	}
	function isNumberType(check) {
	    return typeof check === 'number' && isFinite(check);
	}
	function isMinimum(min) {
	    return function (check) {
	        return check >= min;
	    };
	}
	function isMaximum(max) {
	    return function (check) {
	        return check <= max;
	    };
	}
	function isMinimumLength(min) {
	    return function (check) {
	        return Buffer.byteLength(check) >= min;
	    };
	}
	function isMaximumLength(max) {
	    return function (check) {
	        return Buffer.byteLength(check) <= max;
	    };
	}
	function isEnum(values) {
	    if (values && values.length != 0) {
	        return function (check) {
	            return values.indexOf(check) > -1;
	        };
	    }
	    else {
	        return function (check) {
	            return true;
	        };
	    }
	}
	function isPattern(pattern) {
	    var regexp = (typeof pattern === 'string') ? new RegExp(pattern) : pattern;
	    return regexp.test.bind(regexp);
	}
	function toValidationResult(valid, key, value, rule, attr) {
	    return {
	        valid: valid,
	        rule: rule,
	        attr: attr,
	        value: value,
	        key: key
	    };
	}
	function toValidationFunction(parameter, rules) {
	    var validations = [];
	    Object.keys(parameter).forEach(function (name) {
	        var rule = rules[name];
	        if (!rule) {
	            return;
	        }
	        var value = parameter[name];
	        validations.push([name, rule(value, name), value]);
	    });
	    return function (value, key, src) {
	        for (var i = 0; i < validations.length; i++) {
	            var validation = validations[i];
	            var name = validation[0];
	            var fn = validation[1];
	            var attr = validation[2];
	            var valid = fn(value, key, src);
	            if (!valid) {
	                return toValidationResult(false, key, value, name, attr);
	            }
	        }
	        return toValidationResult(true, key, value);
	    };
	}
	function toValidation(parameter, rules, types) {
	    var parameters = Array.isArray(parameter) ? parameter : [parameter];
	    var isOptional = !parameters.length;
	    var simpleValidations = [];
	    var repeatValidations = [];
	    parameters.forEach(function (parameter) {
	        var validation = [parameter.type || 'string', toValidationFunction(parameter, rules)];
	        if (!parameter.required) {
	            isOptional = true;
	        }
	        if (parameter.repeat) {
	            repeatValidations.push(validation);
	        }
	        else {
	            simpleValidations.push(validation);
	        }
	    });
	    return function (value, key, src) {
	        if (value == null) {
	            return toValidationResult(isOptional, key, value, 'required', !isOptional);
	        }
	        var isArray = Array.isArray(value);
	        var values = isArray ? value : [value];
	        var validations = isArray ? repeatValidations : simpleValidations;
	        if (!validations.length) {
	            return toValidationResult(false, key, value, 'repeat', !isArray);
	        }
	        var response = null;
	        var originalValue = value;
	        validations.some(function (validation) {
	            var isValidType = values.every(function (value) {
	                var paramType = validation[0];
	                var isValidType = types[paramType] && types[paramType](value, key, src);
	                if (!isValidType) {
	                    response = toValidationResult(false, key, originalValue, 'type', paramType);
	                }
	                return isValidType;
	            });
	            if (!isValidType) {
	                return false;
	            }
	            values.every(function (value) {
	                var fn = validation[1];
	                response = fn(value, key);
	                return response.valid;
	            });
	            return true;
	        });
	        return response;
	    };
	}
	function validate() {
	    var TYPES = {
	        date: isDateType,
	        number: isNumberType,
	        integer: isIntegerType,
	        boolean: isBooleanType,
	        string: isStringType
	    };
	    var RULES = {
	        minimum: isMinimum,
	        maximum: isMaximum,
	        minLength: isMinimumLength,
	        maxLength: isMaximumLength,
	        'enum': isEnum,
	        pattern: isPattern
	    };
	    function rule(parameter) {
	        return toValidation(parameter, RULES, TYPES);
	    }
	    var v;
	    var validate = function (parameterMap) {
	        if (!parameterMap) {
	            return function (check) {
	                return { valid: true, errors: [] };
	            };
	        }
	        var validations = {};
	        Object.keys(parameterMap).forEach(function (key) {
	            validations[key] = rule(parameterMap[key]);
	        });
	        return function (src) {
	            src = src || {};
	            var errors = Object.keys(validations).map(function (param) {
	                var value = src[param];
	                var fn = validations[param];
	                return fn(value, param, src);
	            }).filter(function (result) {
	                return !result.valid;
	            });
	            return {
	                valid: errors.length === 0,
	                errors: errors
	            };
	        };
	    };
	    v = validate;
	    v.rule = rule;
	    v.TYPES = TYPES;
	    v.RULES = RULES;
	    return v;
	}
	module.exports = validate;
	//# sourceMappingURL=raml-validate.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(77).Buffer))

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var parser = (function () {
	    "use strict";
	    /*
	     * Generated by PEG.js 0.9.0.
	     *
	     * http://pegjs.org/
	     */
	    function peg$subclass(child, parent) {
	        function ctor() {
	            this.constructor = child;
	        }
	        ctor.prototype = parent.prototype;
	        child.prototype = new ctor();
	    }
	    function peg$SyntaxError(message, expected, found, location) {
	        this.message = message;
	        this.expected = expected;
	        this.found = found;
	        this.location = location;
	        this.name = "SyntaxError";
	        if (typeof Error.captureStackTrace === "function") {
	            Error.captureStackTrace(this, peg$SyntaxError);
	        }
	    }
	    peg$subclass(peg$SyntaxError, Error);
	    function peg$parse(input) {
	        var options = arguments.length > 1 ? arguments[1] : {}, parser = this, peg$FAILED = {}, peg$startRuleFunctions = { Expression: peg$parseExpression }, peg$startRuleFunction = peg$parseExpression, peg$c0 = function (c) {
	            return c;
	        }, peg$c1 = function (op, exp) {
	            return { 'type': 'unary', 'op': op, 'exp': exp };
	        }, peg$c2 = /^[*%\/]/, peg$c3 = { type: "class", value: "[*%/]", description: "[*%/]" }, peg$c4 = function (l, r) {
	            return r ? ({ "type": r[0], "l": l, "r": r[1] }) : l;
	        }, peg$c5 = /^[\-+]/, peg$c6 = { type: "class", value: "[-+]", description: "[-+]" }, peg$c7 = "<=", peg$c8 = { type: "literal", value: "<=", description: "\"<=\"" }, peg$c9 = ">=", peg$c10 = { type: "literal", value: ">=", description: "\">=\"" }, peg$c11 = "<", peg$c12 = { type: "literal", value: "<", description: "\"<\"" }, peg$c13 = ">", peg$c14 = { type: "literal", value: ">", description: "\">\"" }, peg$c15 = "==", peg$c16 = { type: "literal", value: "==", description: "\"==\"" }, peg$c17 = "!=", peg$c18 = { type: "literal", value: "!=", description: "\"!=\"" }, peg$c19 = "&", peg$c20 = { type: "literal", value: "&", description: "\"&\"" }, peg$c21 = "^", peg$c22 = { type: "literal", value: "^", description: "\"^\"" }, peg$c23 = "|", peg$c24 = { type: "literal", value: "|", description: "\"|\"" }, peg$c25 = "&&", peg$c26 = { type: "literal", value: "&&", description: "\"&&\"" }, peg$c27 = "||", peg$c28 = { type: "literal", value: "||", description: "\"||\"" }, peg$c29 = "?", peg$c30 = { type: "literal", value: "?", description: "\"?\"" }, peg$c31 = ":", peg$c32 = { type: "literal", value: ":", description: "\":\"" }, peg$c33 = function (p, e) {
	            return e ? null : p;
	        }, peg$c34 = "(", peg$c35 = { type: "literal", value: "(", description: "\"(\"" }, peg$c36 = ")", peg$c37 = { type: "literal", value: ")", description: "\")\"" }, peg$c38 = function (e) {
	            return { 'type': 'paren', 'exp': e };
	        }, peg$c39 = /^[\-&*~!]/, peg$c40 = { type: "class", value: "[-&*~!]", description: "[-&*~!]" }, peg$c41 = "$", peg$c42 = { type: "literal", value: "$", description: "\"$\"" }, peg$c43 = /^[a-zA-Z_]/, peg$c44 = { type: "class", value: "[a-zA-Z_]", description: "[a-zA-Z_]" }, peg$c45 = /^[a-zA-Z0-9_]/, peg$c46 = { type: "class", value: "[a-zA-Z0-9_]", description: "[a-zA-Z0-9_]" }, peg$c47 = ".", peg$c48 = { type: "literal", value: ".", description: "\".\"" }, peg$c49 = function (v0, v1) {
	            return { 'type': 'ident', value: [v0].concat(v1).join('') };
	        }, peg$c50 = function (m) {
	            m = m.map(function (x) {
	                return x[1];
	            });
	            return { 'type': 'string', 'value': m.join('') };
	        }, peg$c51 = "\"", peg$c52 = { type: "literal", value: "\"", description: "\"\\\"\"" }, peg$c53 = { type: "any", description: "any character" }, peg$c54 = /^[abfnrtv]/, peg$c55 = { type: "class", value: "[abfnrtv]", description: "[abfnrtv]" }, peg$c56 = "\\", peg$c57 = { type: "literal", value: "\\", description: "\"\\\\\"" }, peg$c58 = "'", peg$c59 = { type: "literal", value: "'", description: "\"'\"" }, peg$c60 = function (f) {
	            return f.join('');
	        }, peg$c61 = /^[0-9]/, peg$c62 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$c63 = function (v, f) {
	            if (!f)
	                f = [];
	            var val = [v].concat(f).join('');
	            return { 'type': 'number', 'value': val };
	        }, peg$c64 = "-", peg$c65 = { type: "literal", value: "-", description: "\"-\"" }, peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{ line: 1, column: 1, seenCR: false }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
	        if ("startRule" in options) {
	            if (!(options.startRule in peg$startRuleFunctions)) {
	                throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	            }
	            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	        }
	        function text() {
	            return input.substring(peg$savedPos, peg$currPos);
	        }
	        function location() {
	            return peg$computeLocation(peg$savedPos, peg$currPos);
	        }
	        function expected(description) {
	            throw peg$buildException(null, [{ type: "other", description: description }], input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
	        }
	        function error(message) {
	            throw peg$buildException(message, null, input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
	        }
	        function peg$computePosDetails(pos) {
	            var details = peg$posDetailsCache[pos], p, ch;
	            if (details) {
	                return details;
	            }
	            else {
	                p = pos - 1;
	                while (!peg$posDetailsCache[p]) {
	                    p--;
	                }
	                details = peg$posDetailsCache[p];
	                details = {
	                    line: details.line,
	                    column: details.column,
	                    seenCR: details.seenCR
	                };
	                while (p < pos) {
	                    ch = input.charAt(p);
	                    if (ch === "\n") {
	                        if (!details.seenCR) {
	                            details.line++;
	                        }
	                        details.column = 1;
	                        details.seenCR = false;
	                    }
	                    else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
	                        details.line++;
	                        details.column = 1;
	                        details.seenCR = true;
	                    }
	                    else {
	                        details.column++;
	                        details.seenCR = false;
	                    }
	                    p++;
	                }
	                peg$posDetailsCache[pos] = details;
	                return details;
	            }
	        }
	        function peg$computeLocation(startPos, endPos) {
	            var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
	            return {
	                start: {
	                    offset: startPos,
	                    line: startPosDetails.line,
	                    column: startPosDetails.column
	                },
	                end: {
	                    offset: endPos,
	                    line: endPosDetails.line,
	                    column: endPosDetails.column
	                }
	            };
	        }
	        function peg$fail(expected) {
	            if (peg$currPos < peg$maxFailPos) {
	                return;
	            }
	            if (peg$currPos > peg$maxFailPos) {
	                peg$maxFailPos = peg$currPos;
	                peg$maxFailExpected = [];
	            }
	            peg$maxFailExpected.push(expected);
	        }
	        function peg$buildException(message, expected, found, location) {
	            function cleanupExpected(expected) {
	                var i = 1;
	                expected.sort(function (a, b) {
	                    if (a.description < b.description) {
	                        return -1;
	                    }
	                    else if (a.description > b.description) {
	                        return 1;
	                    }
	                    else {
	                        return 0;
	                    }
	                });
	                while (i < expected.length) {
	                    if (expected[i - 1] === expected[i]) {
	                        expected.splice(i, 1);
	                    }
	                    else {
	                        i++;
	                    }
	                }
	            }
	            function buildMessage(expected, found) {
	                function stringEscape(s) {
	                    function hex(ch) {
	                        return ch.charCodeAt(0).toString(16).toUpperCase();
	                    }
	                    return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (ch) {
	                        return '\\x0' + hex(ch);
	                    }).replace(/[\x10-\x1F\x80-\xFF]/g, function (ch) {
	                        return '\\x' + hex(ch);
	                    }).replace(/[\u0100-\u0FFF]/g, function (ch) {
	                        return '\\u0' + hex(ch);
	                    }).replace(/[\u1000-\uFFFF]/g, function (ch) {
	                        return '\\u' + hex(ch);
	                    });
	                }
	                var expectedDescs = new Array(expected.length), expectedDesc, foundDesc, i;
	                for (i = 0; i < expected.length; i++) {
	                    expectedDescs[i] = expected[i].description;
	                }
	                expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];
	                foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
	                return "Expected " + expectedDesc + " but " + foundDesc + " found.";
	            }
	            if (expected !== null) {
	                cleanupExpected(expected);
	            }
	            return new peg$SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, location);
	        }
	        function peg$parseExpression() {
	            var s0, s1;
	            s0 = peg$currPos;
	            s1 = peg$parseConditionalExpression();
	            if (s1 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c0(s1);
	            }
	            s0 = s1;
	            return s0;
	        }
	        function peg$parseUnaryExpression() {
	            var s0, s1;
	            s0 = peg$currPos;
	            s1 = peg$parsePrimaryExpression();
	            if (s1 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c0(s1);
	            }
	            s0 = s1;
	            if (s0 === peg$FAILED) {
	                s0 = peg$parseUnop();
	            }
	            return s0;
	        }
	        function peg$parseUnop() {
	            var s0, s1, s2;
	            s0 = peg$currPos;
	            s1 = peg$parseUnaryOperator();
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parseUnaryExpression();
	                if (s2 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c1(s1, s2);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseMultiplicativeExpression() {
	            var s0, s1, s2, s3, s4;
	            s0 = peg$currPos;
	            s1 = peg$parseUnaryExpression();
	            if (s1 !== peg$FAILED) {
	                s2 = peg$currPos;
	                if (peg$c2.test(input.charAt(peg$currPos))) {
	                    s3 = input.charAt(peg$currPos);
	                    peg$currPos++;
	                }
	                else {
	                    s3 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c3);
	                    }
	                }
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parseMultiplicativeExpression();
	                    if (s4 !== peg$FAILED) {
	                        s3 = [s3, s4];
	                        s2 = s3;
	                    }
	                    else {
	                        peg$currPos = s2;
	                        s2 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	                if (s2 === peg$FAILED) {
	                    s2 = null;
	                }
	                if (s2 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c4(s1, s2);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseAdditiveExpression() {
	            var s0, s1, s2, s3, s4;
	            s0 = peg$currPos;
	            s1 = peg$parseMultiplicativeExpression();
	            if (s1 !== peg$FAILED) {
	                s2 = peg$currPos;
	                if (peg$c5.test(input.charAt(peg$currPos))) {
	                    s3 = input.charAt(peg$currPos);
	                    peg$currPos++;
	                }
	                else {
	                    s3 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c6);
	                    }
	                }
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parseAdditiveExpression();
	                    if (s4 !== peg$FAILED) {
	                        s3 = [s3, s4];
	                        s2 = s3;
	                    }
	                    else {
	                        peg$currPos = s2;
	                        s2 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	                if (s2 === peg$FAILED) {
	                    s2 = null;
	                }
	                if (s2 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c4(s1, s2);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseRelationalExpression() {
	            var s0, s1, s2, s3, s4;
	            s0 = peg$currPos;
	            s1 = peg$parseAdditiveExpression();
	            if (s1 !== peg$FAILED) {
	                s2 = peg$currPos;
	                if (input.substr(peg$currPos, 2) === peg$c7) {
	                    s3 = peg$c7;
	                    peg$currPos += 2;
	                }
	                else {
	                    s3 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c8);
	                    }
	                }
	                if (s3 === peg$FAILED) {
	                    if (input.substr(peg$currPos, 2) === peg$c9) {
	                        s3 = peg$c9;
	                        peg$currPos += 2;
	                    }
	                    else {
	                        s3 = peg$FAILED;
	                        if (peg$silentFails === 0) {
	                            peg$fail(peg$c10);
	                        }
	                    }
	                    if (s3 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 60) {
	                            s3 = peg$c11;
	                            peg$currPos++;
	                        }
	                        else {
	                            s3 = peg$FAILED;
	                            if (peg$silentFails === 0) {
	                                peg$fail(peg$c12);
	                            }
	                        }
	                        if (s3 === peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 62) {
	                                s3 = peg$c13;
	                                peg$currPos++;
	                            }
	                            else {
	                                s3 = peg$FAILED;
	                                if (peg$silentFails === 0) {
	                                    peg$fail(peg$c14);
	                                }
	                            }
	                        }
	                    }
	                }
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parseRelationalExpression();
	                    if (s4 !== peg$FAILED) {
	                        s3 = [s3, s4];
	                        s2 = s3;
	                    }
	                    else {
	                        peg$currPos = s2;
	                        s2 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	                if (s2 === peg$FAILED) {
	                    s2 = null;
	                }
	                if (s2 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c4(s1, s2);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseEqualityExpression() {
	            var s0, s1, s2, s3, s4;
	            s0 = peg$currPos;
	            s1 = peg$parseRelationalExpression();
	            if (s1 !== peg$FAILED) {
	                s2 = peg$currPos;
	                if (input.substr(peg$currPos, 2) === peg$c15) {
	                    s3 = peg$c15;
	                    peg$currPos += 2;
	                }
	                else {
	                    s3 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c16);
	                    }
	                }
	                if (s3 === peg$FAILED) {
	                    if (input.substr(peg$currPos, 2) === peg$c17) {
	                        s3 = peg$c17;
	                        peg$currPos += 2;
	                    }
	                    else {
	                        s3 = peg$FAILED;
	                        if (peg$silentFails === 0) {
	                            peg$fail(peg$c18);
	                        }
	                    }
	                }
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parseEqualityExpression();
	                    if (s4 !== peg$FAILED) {
	                        s3 = [s3, s4];
	                        s2 = s3;
	                    }
	                    else {
	                        peg$currPos = s2;
	                        s2 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	                if (s2 === peg$FAILED) {
	                    s2 = null;
	                }
	                if (s2 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c4(s1, s2);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseANDExpression() {
	            var s0, s1, s2, s3, s4;
	            s0 = peg$currPos;
	            s1 = peg$parseEqualityExpression();
	            if (s1 !== peg$FAILED) {
	                s2 = peg$currPos;
	                if (input.charCodeAt(peg$currPos) === 38) {
	                    s3 = peg$c19;
	                    peg$currPos++;
	                }
	                else {
	                    s3 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c20);
	                    }
	                }
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parseANDExpression();
	                    if (s4 !== peg$FAILED) {
	                        s3 = [s3, s4];
	                        s2 = s3;
	                    }
	                    else {
	                        peg$currPos = s2;
	                        s2 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	                if (s2 === peg$FAILED) {
	                    s2 = null;
	                }
	                if (s2 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c4(s1, s2);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseExclusiveORExpression() {
	            var s0, s1, s2, s3, s4;
	            s0 = peg$currPos;
	            s1 = peg$parseANDExpression();
	            if (s1 !== peg$FAILED) {
	                s2 = peg$currPos;
	                if (input.charCodeAt(peg$currPos) === 94) {
	                    s3 = peg$c21;
	                    peg$currPos++;
	                }
	                else {
	                    s3 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c22);
	                    }
	                }
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parseExclusiveORExpression();
	                    if (s4 !== peg$FAILED) {
	                        s3 = [s3, s4];
	                        s2 = s3;
	                    }
	                    else {
	                        peg$currPos = s2;
	                        s2 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	                if (s2 === peg$FAILED) {
	                    s2 = null;
	                }
	                if (s2 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c4(s1, s2);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseInclusiveORExpression() {
	            var s0, s1, s2, s3, s4;
	            s0 = peg$currPos;
	            s1 = peg$parseExclusiveORExpression();
	            if (s1 !== peg$FAILED) {
	                s2 = peg$currPos;
	                if (input.charCodeAt(peg$currPos) === 124) {
	                    s3 = peg$c23;
	                    peg$currPos++;
	                }
	                else {
	                    s3 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c24);
	                    }
	                }
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parseInclusiveORExpression();
	                    if (s4 !== peg$FAILED) {
	                        s3 = [s3, s4];
	                        s2 = s3;
	                    }
	                    else {
	                        peg$currPos = s2;
	                        s2 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	                if (s2 === peg$FAILED) {
	                    s2 = null;
	                }
	                if (s2 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c4(s1, s2);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseLogicalANDExpression() {
	            var s0, s1, s2, s3, s4;
	            s0 = peg$currPos;
	            s1 = peg$parseInclusiveORExpression();
	            if (s1 !== peg$FAILED) {
	                s2 = peg$currPos;
	                if (input.substr(peg$currPos, 2) === peg$c25) {
	                    s3 = peg$c25;
	                    peg$currPos += 2;
	                }
	                else {
	                    s3 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c26);
	                    }
	                }
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parseLogicalANDExpression();
	                    if (s4 !== peg$FAILED) {
	                        s3 = [s3, s4];
	                        s2 = s3;
	                    }
	                    else {
	                        peg$currPos = s2;
	                        s2 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	                if (s2 === peg$FAILED) {
	                    s2 = null;
	                }
	                if (s2 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c4(s1, s2);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseLogicalORExpression() {
	            var s0, s1, s2, s3, s4;
	            s0 = peg$currPos;
	            s1 = peg$parseLogicalANDExpression();
	            if (s1 !== peg$FAILED) {
	                s2 = peg$currPos;
	                if (input.substr(peg$currPos, 2) === peg$c27) {
	                    s3 = peg$c27;
	                    peg$currPos += 2;
	                }
	                else {
	                    s3 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c28);
	                    }
	                }
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parseLogicalORExpression();
	                    if (s4 !== peg$FAILED) {
	                        s3 = [s3, s4];
	                        s2 = s3;
	                    }
	                    else {
	                        peg$currPos = s2;
	                        s2 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	                if (s2 === peg$FAILED) {
	                    s2 = null;
	                }
	                if (s2 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c4(s1, s2);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseConditionalExpression() {
	            var s0, s1, s2, s3, s4, s5, s6;
	            s0 = peg$currPos;
	            s1 = peg$parseLogicalORExpression();
	            if (s1 !== peg$FAILED) {
	                s2 = peg$currPos;
	                if (input.charCodeAt(peg$currPos) === 63) {
	                    s3 = peg$c29;
	                    peg$currPos++;
	                }
	                else {
	                    s3 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c30);
	                    }
	                }
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parseExpression();
	                    if (s4 !== peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 58) {
	                            s5 = peg$c31;
	                            peg$currPos++;
	                        }
	                        else {
	                            s5 = peg$FAILED;
	                            if (peg$silentFails === 0) {
	                                peg$fail(peg$c32);
	                            }
	                        }
	                        if (s5 !== peg$FAILED) {
	                            s6 = peg$parseConditionalExpression();
	                            if (s6 !== peg$FAILED) {
	                                s3 = [s3, s4, s5, s6];
	                                s2 = s3;
	                            }
	                            else {
	                                peg$currPos = s2;
	                                s2 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s2;
	                            s2 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s2;
	                        s2 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	                if (s2 === peg$FAILED) {
	                    s2 = null;
	                }
	                if (s2 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c33(s1, s2);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parsePrimaryExpression() {
	            var s0;
	            s0 = peg$parseIdentifier();
	            if (s0 === peg$FAILED) {
	                s0 = peg$parseStringLiteral();
	                if (s0 === peg$FAILED) {
	                    s0 = peg$parseNumberLiteral();
	                    if (s0 === peg$FAILED) {
	                        s0 = peg$parseCharLiteral();
	                        if (s0 === peg$FAILED) {
	                            s0 = peg$parseParen();
	                        }
	                    }
	                }
	            }
	            return s0;
	        }
	        function peg$parseParen() {
	            var s0, s1, s2, s3;
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 40) {
	                s1 = peg$c34;
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c35);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parseExpression();
	                if (s2 !== peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 41) {
	                        s3 = peg$c36;
	                        peg$currPos++;
	                    }
	                    else {
	                        s3 = peg$FAILED;
	                        if (peg$silentFails === 0) {
	                            peg$fail(peg$c37);
	                        }
	                    }
	                    if (s3 !== peg$FAILED) {
	                        peg$savedPos = s0;
	                        s1 = peg$c38(s2);
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseUnaryOperator() {
	            var s0;
	            if (peg$c39.test(input.charAt(peg$currPos))) {
	                s0 = input.charAt(peg$currPos);
	                peg$currPos++;
	            }
	            else {
	                s0 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c40);
	                }
	            }
	            return s0;
	        }
	        function peg$parseIdentifier() {
	            var s0, s1, s2, s3;
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 36) {
	                s1 = peg$c41;
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c42);
	                }
	            }
	            if (s1 === peg$FAILED) {
	                if (peg$c43.test(input.charAt(peg$currPos))) {
	                    s1 = input.charAt(peg$currPos);
	                    peg$currPos++;
	                }
	                else {
	                    s1 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c44);
	                    }
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                s2 = [];
	                if (peg$c45.test(input.charAt(peg$currPos))) {
	                    s3 = input.charAt(peg$currPos);
	                    peg$currPos++;
	                }
	                else {
	                    s3 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c46);
	                    }
	                }
	                if (s3 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 46) {
	                        s3 = peg$c47;
	                        peg$currPos++;
	                    }
	                    else {
	                        s3 = peg$FAILED;
	                        if (peg$silentFails === 0) {
	                            peg$fail(peg$c48);
	                        }
	                    }
	                    if (s3 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 36) {
	                            s3 = peg$c41;
	                            peg$currPos++;
	                        }
	                        else {
	                            s3 = peg$FAILED;
	                            if (peg$silentFails === 0) {
	                                peg$fail(peg$c42);
	                            }
	                        }
	                    }
	                }
	                while (s3 !== peg$FAILED) {
	                    s2.push(s3);
	                    if (peg$c45.test(input.charAt(peg$currPos))) {
	                        s3 = input.charAt(peg$currPos);
	                        peg$currPos++;
	                    }
	                    else {
	                        s3 = peg$FAILED;
	                        if (peg$silentFails === 0) {
	                            peg$fail(peg$c46);
	                        }
	                    }
	                    if (s3 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 46) {
	                            s3 = peg$c47;
	                            peg$currPos++;
	                        }
	                        else {
	                            s3 = peg$FAILED;
	                            if (peg$silentFails === 0) {
	                                peg$fail(peg$c48);
	                            }
	                        }
	                        if (s3 === peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 36) {
	                                s3 = peg$c41;
	                                peg$currPos++;
	                            }
	                            else {
	                                s3 = peg$FAILED;
	                                if (peg$silentFails === 0) {
	                                    peg$fail(peg$c42);
	                                }
	                            }
	                        }
	                    }
	                }
	                if (s2 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c49(s1, s2);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseStringLiteral() {
	            var s0, s1, s2, s3;
	            s0 = peg$currPos;
	            s1 = peg$parsedoublequote();
	            if (s1 !== peg$FAILED) {
	                s2 = [];
	                s3 = peg$parseDQChar();
	                while (s3 !== peg$FAILED) {
	                    s2.push(s3);
	                    s3 = peg$parseDQChar();
	                }
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$parsedoublequote();
	                    if (s3 !== peg$FAILED) {
	                        peg$savedPos = s0;
	                        s1 = peg$c50(s2);
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parsedoublequote() {
	            var s0;
	            if (input.charCodeAt(peg$currPos) === 34) {
	                s0 = peg$c51;
	                peg$currPos++;
	            }
	            else {
	                s0 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c52);
	                }
	            }
	            return s0;
	        }
	        function peg$parseDQChar() {
	            var s0, s1, s2;
	            s0 = peg$parseEscapeSequence();
	            if (s0 === peg$FAILED) {
	                s0 = peg$currPos;
	                s1 = peg$currPos;
	                peg$silentFails++;
	                s2 = peg$parsedoublequote();
	                peg$silentFails--;
	                if (s2 === peg$FAILED) {
	                    s1 = void 0;
	                }
	                else {
	                    peg$currPos = s1;
	                    s1 = peg$FAILED;
	                }
	                if (s1 !== peg$FAILED) {
	                    if (input.length > peg$currPos) {
	                        s2 = input.charAt(peg$currPos);
	                        peg$currPos++;
	                    }
	                    else {
	                        s2 = peg$FAILED;
	                        if (peg$silentFails === 0) {
	                            peg$fail(peg$c53);
	                        }
	                    }
	                    if (s2 !== peg$FAILED) {
	                        s1 = [s1, s2];
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            return s0;
	        }
	        function peg$parseQChar() {
	            var s0, s1, s2;
	            s0 = peg$parseEscapeSequence();
	            if (s0 === peg$FAILED) {
	                s0 = peg$currPos;
	                s1 = peg$currPos;
	                peg$silentFails++;
	                s2 = peg$parsequote();
	                peg$silentFails--;
	                if (s2 === peg$FAILED) {
	                    s1 = void 0;
	                }
	                else {
	                    peg$currPos = s1;
	                    s1 = peg$FAILED;
	                }
	                if (s1 !== peg$FAILED) {
	                    if (input.length > peg$currPos) {
	                        s2 = input.charAt(peg$currPos);
	                        peg$currPos++;
	                    }
	                    else {
	                        s2 = peg$FAILED;
	                        if (peg$silentFails === 0) {
	                            peg$fail(peg$c53);
	                        }
	                    }
	                    if (s2 !== peg$FAILED) {
	                        s1 = [s1, s2];
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            return s0;
	        }
	        function peg$parseEscapeSequence() {
	            var s0, s1, s2;
	            s0 = peg$currPos;
	            s1 = peg$parsebackslash();
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parsequote();
	                if (s2 === peg$FAILED) {
	                    s2 = peg$parsedoublequote();
	                    if (s2 === peg$FAILED) {
	                        s2 = peg$parsebackslash();
	                        if (s2 === peg$FAILED) {
	                            if (peg$c54.test(input.charAt(peg$currPos))) {
	                                s2 = input.charAt(peg$currPos);
	                                peg$currPos++;
	                            }
	                            else {
	                                s2 = peg$FAILED;
	                                if (peg$silentFails === 0) {
	                                    peg$fail(peg$c55);
	                                }
	                            }
	                        }
	                    }
	                }
	                if (s2 !== peg$FAILED) {
	                    s1 = [s1, s2];
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parsebackslash() {
	            var s0;
	            if (input.charCodeAt(peg$currPos) === 92) {
	                s0 = peg$c56;
	                peg$currPos++;
	            }
	            else {
	                s0 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c57);
	                }
	            }
	            return s0;
	        }
	        function peg$parsequote() {
	            var s0;
	            if (input.charCodeAt(peg$currPos) === 39) {
	                s0 = peg$c58;
	                peg$currPos++;
	            }
	            else {
	                s0 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c59);
	                }
	            }
	            return s0;
	        }
	        function peg$parseCharLiteral() {
	            var s0, s1, s2, s3;
	            s0 = peg$currPos;
	            s1 = peg$parsequote();
	            if (s1 !== peg$FAILED) {
	                s2 = [];
	                s3 = peg$parseQChar();
	                while (s3 !== peg$FAILED) {
	                    s2.push(s3);
	                    s3 = peg$parseQChar();
	                }
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$parsequote();
	                    if (s3 !== peg$FAILED) {
	                        peg$savedPos = s0;
	                        s1 = peg$c50(s2);
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseInteger() {
	            var s0, s1, s2;
	            s0 = peg$currPos;
	            s1 = [];
	            s2 = peg$parsedigit();
	            if (s2 !== peg$FAILED) {
	                while (s2 !== peg$FAILED) {
	                    s1.push(s2);
	                    s2 = peg$parsedigit();
	                }
	            }
	            else {
	                s1 = peg$FAILED;
	            }
	            if (s1 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c60(s1);
	            }
	            s0 = s1;
	            return s0;
	        }
	        function peg$parsedigit() {
	            var s0;
	            if (peg$c61.test(input.charAt(peg$currPos))) {
	                s0 = input.charAt(peg$currPos);
	                peg$currPos++;
	            }
	            else {
	                s0 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c62);
	                }
	            }
	            return s0;
	        }
	        function peg$parseNumberLiteral() {
	            var s0, s1, s2, s3, s4;
	            s0 = peg$currPos;
	            s1 = peg$parseInteger();
	            if (s1 !== peg$FAILED) {
	                s2 = peg$currPos;
	                if (input.charCodeAt(peg$currPos) === 46) {
	                    s3 = peg$c47;
	                    peg$currPos++;
	                }
	                else {
	                    s3 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c48);
	                    }
	                }
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parseInteger();
	                    if (s4 !== peg$FAILED) {
	                        s3 = [s3, s4];
	                        s2 = s3;
	                    }
	                    else {
	                        peg$currPos = s2;
	                        s2 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	                if (s2 === peg$FAILED) {
	                    s2 = null;
	                }
	                if (s2 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c63(s1, s2);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseSign() {
	            var s0;
	            if (input.charCodeAt(peg$currPos) === 45) {
	                s0 = peg$c64;
	                peg$currPos++;
	            }
	            else {
	                s0 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c65);
	                }
	            }
	            return s0;
	        }
	        peg$result = peg$startRuleFunction();
	        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	            return peg$result;
	        }
	        else {
	            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
	                peg$fail({ type: "end", description: "end of input" });
	            }
	            throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
	        }
	    }
	    return {
	        SyntaxError: peg$SyntaxError,
	        parse: peg$parse
	    };
	})();
	module.exports = parser;
	//# sourceMappingURL=ramlExpressionParser.js.map

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var mod = (function () {
	    /*
	     * Generated by PEG.js 0.8.0.
	     *
	     * http://pegjs.majda.cz/
	     */
	    function peg$subclass(child, parent) {
	        function ctor() {
	            this.constructor = child;
	        }
	        ctor.prototype = parent.prototype;
	        child.prototype = new ctor();
	    }
	    function SyntaxError(message, expected, found, offset, line, column) {
	        this.message = message;
	        this.expected = expected;
	        this.found = found;
	        this.offset = offset;
	        this.line = line;
	        this.column = column;
	        this.name = "SyntaxError";
	    }
	    peg$subclass(SyntaxError, Error);
	    function parse(input) {
	        var options = arguments.length > 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = { start: peg$parsestart }, peg$startRuleFunction = peg$parsestart, peg$c0 = peg$FAILED, peg$c1 = "|", peg$c2 = { type: "literal", value: "|", description: "\"|\"" }, peg$c3 = function (left, r) {
	            return { 'type': 'or', 'left': left, 'right': r ? r : null };
	        }, peg$c4 = ".", peg$c5 = { type: "literal", value: ".", description: "\".\"" }, peg$c6 = function (left, r) {
	            return { 'type': 'dot', 'left': left, 'right': r };
	        }, peg$c7 = "$", peg$c8 = { type: "literal", value: "$", description: "\"$\"" }, peg$c9 = function () {
	            return { 'type': 'parent' };
	        }, peg$c10 = "$$", peg$c11 = { type: "literal", value: "$$", description: "\"$$\"" }, peg$c12 = function () {
	            return { 'type': 'ancestor' };
	        }, peg$c13 = "**", peg$c14 = { type: "literal", value: "**", description: "\"**\"" }, peg$c15 = function () {
	            return { 'type': 'descendant' };
	        }, peg$c16 = "*", peg$c17 = { type: "literal", value: "*", description: "\"*\"" }, peg$c18 = function () {
	            return { 'type': 'child' };
	        }, peg$c19 = [], peg$c20 = /^[A-z]/, peg$c21 = { type: "class", value: "[A-z]", description: "[A-z]" }, peg$c22 = function (chars) {
	            return { 'type': 'classLiteral', "name": chars.join("") };
	        }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = { line: 1, column: 1, seenCR: false }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
	        if ("startRule" in options) {
	            if (!(options.startRule in peg$startRuleFunctions)) {
	                throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	            }
	            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	        }
	        function text() {
	            return input.substring(peg$reportedPos, peg$currPos);
	        }
	        function offset() {
	            return peg$reportedPos;
	        }
	        function line() {
	            return peg$computePosDetails(peg$reportedPos).line;
	        }
	        function column() {
	            return peg$computePosDetails(peg$reportedPos).column;
	        }
	        function expected(description) {
	            throw peg$buildException(null, [{ type: "other", description: description }], peg$reportedPos);
	        }
	        function error(message) {
	            throw peg$buildException(message, null, peg$reportedPos);
	        }
	        function peg$computePosDetails(pos) {
	            function advance(details, startPos, endPos) {
	                var p, ch;
	                for (p = startPos; p < endPos; p++) {
	                    ch = input.charAt(p);
	                    if (ch === "\n") {
	                        if (!details.seenCR) {
	                            details.line++;
	                        }
	                        details.column = 1;
	                        details.seenCR = false;
	                    }
	                    else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
	                        details.line++;
	                        details.column = 1;
	                        details.seenCR = true;
	                    }
	                    else {
	                        details.column++;
	                        details.seenCR = false;
	                    }
	                }
	            }
	            if (peg$cachedPos !== pos) {
	                if (peg$cachedPos > pos) {
	                    peg$cachedPos = 0;
	                    peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
	                }
	                advance(peg$cachedPosDetails, peg$cachedPos, pos);
	                peg$cachedPos = pos;
	            }
	            return peg$cachedPosDetails;
	        }
	        function peg$fail(expected) {
	            if (peg$currPos < peg$maxFailPos) {
	                return;
	            }
	            if (peg$currPos > peg$maxFailPos) {
	                peg$maxFailPos = peg$currPos;
	                peg$maxFailExpected = [];
	            }
	            peg$maxFailExpected.push(expected);
	        }
	        function peg$buildException(message, expected, pos) {
	            function cleanupExpected(expected) {
	                var i = 1;
	                expected.sort(function (a, b) {
	                    if (a.description < b.description) {
	                        return -1;
	                    }
	                    else if (a.description > b.description) {
	                        return 1;
	                    }
	                    else {
	                        return 0;
	                    }
	                });
	                while (i < expected.length) {
	                    if (expected[i - 1] === expected[i]) {
	                        expected.splice(i, 1);
	                    }
	                    else {
	                        i++;
	                    }
	                }
	            }
	            function buildMessage(expected, found) {
	                function stringEscape(s) {
	                    function hex(ch) {
	                        return ch.charCodeAt(0).toString(16).toUpperCase();
	                    }
	                    return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (ch) {
	                        return '\\x0' + hex(ch);
	                    }).replace(/[\x10-\x1F\x80-\xFF]/g, function (ch) {
	                        return '\\x' + hex(ch);
	                    }).replace(/[\u0180-\u0FFF]/g, function (ch) {
	                        return '\\u0' + hex(ch);
	                    }).replace(/[\u1080-\uFFFF]/g, function (ch) {
	                        return '\\u' + hex(ch);
	                    });
	                }
	                var expectedDescs = new Array(expected.length), expectedDesc, foundDesc, i;
	                for (i = 0; i < expected.length; i++) {
	                    expectedDescs[i] = expected[i].description;
	                }
	                expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];
	                foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
	                return "Expected " + expectedDesc + " but " + foundDesc + " found.";
	            }
	            var posDetails = peg$computePosDetails(pos), found = pos < input.length ? input.charAt(pos) : null;
	            if (expected !== null) {
	                cleanupExpected(expected);
	            }
	            return new SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, pos, posDetails.line, posDetails.column);
	        }
	        function peg$parsestart() {
	            var s0;
	            s0 = peg$parseor();
	            return s0;
	        }
	        function peg$parseor() {
	            var s0, s1, s2, s3;
	            s0 = peg$currPos;
	            s1 = peg$parsesequence();
	            if (s1 !== peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 124) {
	                    s2 = peg$c1;
	                    peg$currPos++;
	                }
	                else {
	                    s2 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c2);
	                    }
	                }
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$parseor();
	                    if (s3 !== peg$FAILED) {
	                        peg$reportedPos = s0;
	                        s1 = peg$c3(s1, s3);
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$c0;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$c0;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$c0;
	            }
	            if (s0 === peg$FAILED) {
	                s0 = peg$parsesequence();
	            }
	            return s0;
	        }
	        function peg$parsesequence() {
	            var s0, s1, s2, s3;
	            s0 = peg$currPos;
	            s1 = peg$parseprimary();
	            if (s1 !== peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 46) {
	                    s2 = peg$c4;
	                    peg$currPos++;
	                }
	                else {
	                    s2 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c5);
	                    }
	                }
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$parsesequence();
	                    if (s3 !== peg$FAILED) {
	                        peg$reportedPos = s0;
	                        s1 = peg$c6(s1, s3);
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$c0;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$c0;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$c0;
	            }
	            if (s0 === peg$FAILED) {
	                s0 = peg$parseprimary();
	            }
	            return s0;
	        }
	        function peg$parseprimary() {
	            var s0;
	            s0 = peg$parsechildRef();
	            if (s0 === peg$FAILED) {
	                s0 = peg$parsedoubleStar();
	                if (s0 === peg$FAILED) {
	                    s0 = peg$parsestar();
	                    if (s0 === peg$FAILED) {
	                        s0 = peg$parsedoubleDollar();
	                        if (s0 === peg$FAILED) {
	                            s0 = peg$parsedollar();
	                        }
	                    }
	                }
	            }
	            return s0;
	        }
	        function peg$parsedollar() {
	            var s0, s1;
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 36) {
	                s1 = peg$c7;
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c8);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                peg$reportedPos = s0;
	                s1 = peg$c9();
	            }
	            s0 = s1;
	            return s0;
	        }
	        function peg$parsedoubleDollar() {
	            var s0, s1;
	            s0 = peg$currPos;
	            if (input.substr(peg$currPos, 2) === peg$c10) {
	                s1 = peg$c10;
	                peg$currPos += 2;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c11);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                peg$reportedPos = s0;
	                s1 = peg$c12();
	            }
	            s0 = s1;
	            return s0;
	        }
	        function peg$parsedoubleStar() {
	            var s0, s1;
	            s0 = peg$currPos;
	            if (input.substr(peg$currPos, 2) === peg$c13) {
	                s1 = peg$c13;
	                peg$currPos += 2;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c14);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                peg$reportedPos = s0;
	                s1 = peg$c15();
	            }
	            s0 = s1;
	            return s0;
	        }
	        function peg$parsestar() {
	            var s0, s1;
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 42) {
	                s1 = peg$c16;
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c17);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                peg$reportedPos = s0;
	                s1 = peg$c18();
	            }
	            s0 = s1;
	            return s0;
	        }
	        function peg$parsechildRef() {
	            var s0, s1, s2;
	            s0 = peg$currPos;
	            s1 = [];
	            if (peg$c20.test(input.charAt(peg$currPos))) {
	                s2 = input.charAt(peg$currPos);
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c21);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                while (s2 !== peg$FAILED) {
	                    s1.push(s2);
	                    if (peg$c20.test(input.charAt(peg$currPos))) {
	                        s2 = input.charAt(peg$currPos);
	                        peg$currPos++;
	                    }
	                    else {
	                        s2 = peg$FAILED;
	                        if (peg$silentFails === 0) {
	                            peg$fail(peg$c21);
	                        }
	                    }
	                }
	            }
	            else {
	                s1 = peg$c0;
	            }
	            if (s1 !== peg$FAILED) {
	                peg$reportedPos = s0;
	                s1 = peg$c22(s1);
	            }
	            s0 = s1;
	            return s0;
	        }
	        peg$result = peg$startRuleFunction();
	        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	            return peg$result;
	        }
	        else {
	            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
	                peg$fail({ type: "end", description: "end of input" });
	            }
	            throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
	        }
	    }
	    return {
	        SyntaxError: SyntaxError,
	        parse: parse
	    };
	})();
	module.exports = mod;
	//# sourceMappingURL=ramlselector.js.map

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(61);
	function resolveJavascriptUndefined() {
	    return true;
	}
	function constructJavascriptUndefined() {
	    /*eslint-disable no-undefined*/
	    return undefined;
	}
	function representJavascriptUndefined() {
	    return '';
	}
	function isUndefined(object) {
	    return 'undefined' === typeof object;
	}
	module.exports = new Type('tag:yaml.org,2002:js/undefined', {
	    kind: 'scalar',
	    resolve: resolveJavascriptUndefined,
	    construct: constructJavascriptUndefined,
	    predicate: isUndefined,
	    represent: representJavascriptUndefined
	});
	//# sourceMappingURL=undefined.js.map

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(61);
	function resolveJavascriptRegExp(data) {
	    if (null === data) {
	        return false;
	    }
	    if (0 === data.length) {
	        return false;
	    }
	    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = '';
	    // if regexp starts with '/' it can have modifiers and must be properly closed
	    // `/foo/gim` - modifiers tail can be maximum 3 chars
	    if ('/' === regexp[0]) {
	        if (tail) {
	            modifiers = tail[1];
	        }
	        if (modifiers.length > 3) {
	            return false;
	        }
	        // if expression starts with /, is should be properly terminated
	        if (regexp[regexp.length - modifiers.length - 1] !== '/') {
	            return false;
	        }
	        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
	    }
	    try {
	        var dummy = new RegExp(regexp, modifiers);
	        return true;
	    }
	    catch (error) {
	        return false;
	    }
	}
	function constructJavascriptRegExp(data) {
	    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = '';
	    // `/foo/gim` - tail can be maximum 4 chars
	    if ('/' === regexp[0]) {
	        if (tail) {
	            modifiers = tail[1];
	        }
	        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
	    }
	    return new RegExp(regexp, modifiers);
	}
	function representJavascriptRegExp(object /*, style*/) {
	    var result = '/' + object.source + '/';
	    if (object.global) {
	        result += 'g';
	    }
	    if (object.multiline) {
	        result += 'm';
	    }
	    if (object.ignoreCase) {
	        result += 'i';
	    }
	    return result;
	}
	function isRegExp(object) {
	    return '[object RegExp]' === Object.prototype.toString.call(object);
	}
	module.exports = new Type('tag:yaml.org,2002:js/regexp', {
	    kind: 'scalar',
	    resolve: resolveJavascriptRegExp,
	    construct: constructJavascriptRegExp,
	    predicate: isRegExp,
	    represent: representJavascriptRegExp
	});
	//# sourceMappingURL=regexp.js.map

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../../typings/tsd.d.ts" />
	'use strict';
	var esprima = __webpack_require__(120);
	// Browserified version does not have esprima
	//
	// 1. For node.js just require module as deps
	// 2. For browser try to require mudule via external AMD system.
	//    If not found - try to fallback to window.esprima. If not
	//    found too - then fail to parse.
	//
	var Type = __webpack_require__(61);
	function resolveJavascriptFunction(data) {
	    if (null === data) {
	        return false;
	    }
	    try {
	        var source = '(' + data + ')', ast = esprima.parse(source, { range: true }), params = [], body;
	        if ('Program' !== ast.type || 1 !== ast.body.length || 'ExpressionStatement' !== ast.body[0].type || 'FunctionExpression' !== ast.body[0]['expression'].type) {
	            return false;
	        }
	        return true;
	    }
	    catch (err) {
	        return false;
	    }
	}
	function constructJavascriptFunction(data) {
	    /*jslint evil:true*/
	    var source = '(' + data + ')', ast = esprima.parse(source, { range: true }), params = [], body;
	    if ('Program' !== ast.type || 1 !== ast.body.length || 'ExpressionStatement' !== ast.body[0].type || 'FunctionExpression' !== ast.body[0]['expression'].type) {
	        throw new Error('Failed to resolve function');
	    }
	    ast.body[0]['expression'].params.forEach(function (param) {
	        params.push(param.name);
	    });
	    body = ast.body[0]['expression'].body.range;
	    // Esprima's ranges include the first '{' and the last '}' characters on
	    // function expressions. So cut them out.
	    /*eslint-disable no-new-func*/
	    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
	}
	function representJavascriptFunction(object /*, style*/) {
	    return object.toString();
	}
	function isFunction(object) {
	    return '[object Function]' === Object.prototype.toString.call(object);
	}
	module.exports = new Type('tag:yaml.org,2002:js/function', {
	    kind: 'scalar',
	    resolve: resolveJavascriptFunction,
	    construct: constructJavascriptFunction,
	    predicate: isFunction,
	    represent: representJavascriptFunction
	});
	//# sourceMappingURL=function.js.map

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(61);
	var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + '-([0-9][0-9]?)' + '-([0-9][0-9]?)' + '(?:(?:[Tt]|[ \\t]+)' + '([0-9][0-9]?)' + ':([0-9][0-9])' + ':([0-9][0-9])' + '(?:\\.([0-9]*))?' + '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + '(?::([0-9][0-9]))?))?)?$'); // [11] tz_minute
	function resolveYamlTimestamp(data) {
	    if (null === data) {
	        return false;
	    }
	    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
	    match = YAML_TIMESTAMP_REGEXP.exec(data);
	    if (null === match) {
	        return false;
	    }
	    return true;
	}
	function constructYamlTimestamp(data) {
	    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
	    match = YAML_TIMESTAMP_REGEXP.exec(data);
	    if (null === match) {
	        throw new Error('Date resolve error');
	    }
	    // match: [1] year [2] month [3] day
	    year = +(match[1]);
	    month = +(match[2]) - 1; // JS month starts with 0
	    day = +(match[3]);
	    if (!match[4]) {
	        return new Date(Date.UTC(year, month, day));
	    }
	    // match: [4] hour [5] minute [6] second [7] fraction
	    hour = +(match[4]);
	    minute = +(match[5]);
	    second = +(match[6]);
	    if (match[7]) {
	        fraction = match[7].slice(0, 3);
	        while (fraction.length < 3) {
	            fraction = fraction + '0';
	        }
	        fraction = +fraction;
	    }
	    // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute
	    if (match[9]) {
	        tz_hour = +(match[10]);
	        tz_minute = +(match[11] || 0);
	        delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
	        if ('-' === match[9]) {
	            delta = -delta;
	        }
	    }
	    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
	    if (delta) {
	        date.setTime(date.getTime() - delta);
	    }
	    return date;
	}
	function representYamlTimestamp(object /*, style*/) {
	    return object.toISOString();
	}
	module.exports = new Type('tag:yaml.org,2002:timestamp', {
	    kind: 'scalar',
	    resolve: resolveYamlTimestamp,
	    construct: constructYamlTimestamp,
	    instanceOf: Date,
	    represent: representYamlTimestamp
	});
	//# sourceMappingURL=timestamp.js.map

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(61);
	function resolveYamlMerge(data) {
	    return '<<' === data || null === data;
	}
	module.exports = new Type('tag:yaml.org,2002:merge', {
	    kind: 'scalar',
	    resolve: resolveYamlMerge
	});
	//# sourceMappingURL=merge.js.map

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	/*eslint-disable no-bitwise*/
	// A trick for browserified version.
	// Since we make browserifier to ignore `buffer` module, NodeBuffer will be undefined
	var NodeBuffer = __webpack_require__(77).Buffer;
	var Type = __webpack_require__(61);
	// [ 64, 65, 66 ] -> [ padding, CR, LF ]
	var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';
	function resolveYamlBinary(data) {
	    if (null === data) {
	        return false;
	    }
	    var code, idx, bitlen = 0, len = 0, max = data.length, map = BASE64_MAP;
	    for (idx = 0; idx < max; idx++) {
	        code = map.indexOf(data.charAt(idx));
	        // Skip CR/LF
	        if (code > 64) {
	            continue;
	        }
	        // Fail on illegal characters
	        if (code < 0) {
	            return false;
	        }
	        bitlen += 6;
	    }
	    // If there are any bits left, source was corrupted
	    return (bitlen % 8) === 0;
	}
	function constructYamlBinary(data) {
	    var code, idx, tailbits, input = data.replace(/[\r\n=]/g, ''), max = input.length, map = BASE64_MAP, bits = 0, result = [];
	    for (idx = 0; idx < max; idx++) {
	        if ((idx % 4 === 0) && idx) {
	            result.push((bits >> 16) & 0xFF);
	            result.push((bits >> 8) & 0xFF);
	            result.push(bits & 0xFF);
	        }
	        bits = (bits << 6) | map.indexOf(input.charAt(idx));
	    }
	    // Dump tail
	    tailbits = (max % 4) * 6;
	    if (tailbits === 0) {
	        result.push((bits >> 16) & 0xFF);
	        result.push((bits >> 8) & 0xFF);
	        result.push(bits & 0xFF);
	    }
	    else if (tailbits === 18) {
	        result.push((bits >> 10) & 0xFF);
	        result.push((bits >> 2) & 0xFF);
	    }
	    else if (tailbits === 12) {
	        result.push((bits >> 4) & 0xFF);
	    }
	    // Wrap into Buffer for NodeJS and leave Array for browser
	    if (NodeBuffer) {
	        return new NodeBuffer(result);
	    }
	    return result;
	}
	function representYamlBinary(object /*, style*/) {
	    var result = '', bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
	    for (idx = 0; idx < max; idx++) {
	        if ((idx % 3 === 0) && idx) {
	            result += map[(bits >> 18) & 0x3F];
	            result += map[(bits >> 12) & 0x3F];
	            result += map[(bits >> 6) & 0x3F];
	            result += map[bits & 0x3F];
	        }
	        bits = (bits << 8) + object[idx];
	    }
	    // Dump tail
	    tail = max % 3;
	    if (tail === 0) {
	        result += map[(bits >> 18) & 0x3F];
	        result += map[(bits >> 12) & 0x3F];
	        result += map[(bits >> 6) & 0x3F];
	        result += map[bits & 0x3F];
	    }
	    else if (tail === 2) {
	        result += map[(bits >> 10) & 0x3F];
	        result += map[(bits >> 4) & 0x3F];
	        result += map[(bits << 2) & 0x3F];
	        result += map[64];
	    }
	    else if (tail === 1) {
	        result += map[(bits >> 2) & 0x3F];
	        result += map[(bits << 4) & 0x3F];
	        result += map[64];
	        result += map[64];
	    }
	    return result;
	}
	function isBinary(object) {
	    return NodeBuffer && NodeBuffer.isBuffer(object);
	}
	module.exports = new Type('tag:yaml.org,2002:binary', {
	    kind: 'scalar',
	    resolve: resolveYamlBinary,
	    construct: constructYamlBinary,
	    predicate: isBinary,
	    represent: representYamlBinary
	});
	//# sourceMappingURL=binary.js.map

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(61);
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	var _toString = Object.prototype.toString;
	function resolveYamlOmap(data) {
	    if (null === data) {
	        return true;
	    }
	    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
	    for (index = 0, length = object.length; index < length; index += 1) {
	        pair = object[index];
	        pairHasKey = false;
	        if ('[object Object]' !== _toString.call(pair)) {
	            return false;
	        }
	        for (pairKey in pair) {
	            if (_hasOwnProperty.call(pair, pairKey)) {
	                if (!pairHasKey) {
	                    pairHasKey = true;
	                }
	                else {
	                    return false;
	                }
	            }
	        }
	        if (!pairHasKey) {
	            return false;
	        }
	        if (-1 === objectKeys.indexOf(pairKey)) {
	            objectKeys.push(pairKey);
	        }
	        else {
	            return false;
	        }
	    }
	    return true;
	}
	function constructYamlOmap(data) {
	    return null !== data ? data : [];
	}
	module.exports = new Type('tag:yaml.org,2002:omap', {
	    kind: 'sequence',
	    resolve: resolveYamlOmap,
	    construct: constructYamlOmap
	});
	//# sourceMappingURL=omap.js.map

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(61);
	var _toString = Object.prototype.toString;
	function resolveYamlPairs(data) {
	    if (null === data) {
	        return true;
	    }
	    var index, length, pair, keys, result, object = data;
	    result = new Array(object.length);
	    for (index = 0, length = object.length; index < length; index += 1) {
	        pair = object[index];
	        if ('[object Object]' !== _toString.call(pair)) {
	            return false;
	        }
	        keys = Object.keys(pair);
	        if (1 !== keys.length) {
	            return false;
	        }
	        result[index] = [keys[0], pair[keys[0]]];
	    }
	    return true;
	}
	function constructYamlPairs(data) {
	    if (null === data) {
	        return [];
	    }
	    var index, length, pair, keys, result, object = data;
	    result = new Array(object.length);
	    for (index = 0, length = object.length; index < length; index += 1) {
	        pair = object[index];
	        keys = Object.keys(pair);
	        result[index] = [keys[0], pair[keys[0]]];
	    }
	    return result;
	}
	module.exports = new Type('tag:yaml.org,2002:pairs', {
	    kind: 'sequence',
	    resolve: resolveYamlPairs,
	    construct: constructYamlPairs
	});
	//# sourceMappingURL=pairs.js.map

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(61);
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	function resolveYamlSet(data) {
	    if (null === data) {
	        return true;
	    }
	    var key, object = data;
	    for (key in object) {
	        if (_hasOwnProperty.call(object, key)) {
	            if (null !== object[key]) {
	                return false;
	            }
	        }
	    }
	    return true;
	}
	function constructYamlSet(data) {
	    return null !== data ? data : {};
	}
	module.exports = new Type('tag:yaml.org,2002:set', {
	    kind: 'mapping',
	    resolve: resolveYamlSet,
	    construct: constructYamlSet
	});
	//# sourceMappingURL=set.js.map

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(61);
	module.exports = new Type('tag:yaml.org,2002:str', {
	    kind: 'scalar',
	    construct: function (data) {
	        return null !== data ? data : '';
	    }
	});
	//# sourceMappingURL=str.js.map

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(61);
	module.exports = new Type('tag:yaml.org,2002:seq', {
	    kind: 'sequence',
	    construct: function (data) {
	        return null !== data ? data : [];
	    }
	});
	//# sourceMappingURL=seq.js.map

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(61);
	module.exports = new Type('tag:yaml.org,2002:map', {
	    kind: 'mapping',
	    construct: function (data) {
	        return null !== data ? data : {};
	    }
	});
	//# sourceMappingURL=map.js.map

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(61);
	function resolveYamlNull(data) {
	    if (null === data) {
	        return true;
	    }
	    var max = data.length;
	    return (max === 1 && data === '~') || (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
	}
	function constructYamlNull() {
	    return null;
	}
	function isNull(object) {
	    return null === object;
	}
	module.exports = new Type('tag:yaml.org,2002:null', {
	    kind: 'scalar',
	    resolve: resolveYamlNull,
	    construct: constructYamlNull,
	    predicate: isNull,
	    represent: {
	        canonical: function () {
	            return '~';
	        },
	        lowercase: function () {
	            return 'null';
	        },
	        uppercase: function () {
	            return 'NULL';
	        },
	        camelcase: function () {
	            return 'Null';
	        }
	    },
	    defaultStyle: 'lowercase'
	});
	//# sourceMappingURL=null.js.map

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(61);
	function resolveYamlBoolean(data) {
	    if (null === data) {
	        return false;
	    }
	    var max = data.length;
	    return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) || (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
	}
	function constructYamlBoolean(data) {
	    return data === 'true' || data === 'True' || data === 'TRUE';
	}
	function isBoolean(object) {
	    return '[object Boolean]' === Object.prototype.toString.call(object);
	}
	module.exports = new Type('tag:yaml.org,2002:bool', {
	    kind: 'scalar',
	    resolve: resolveYamlBoolean,
	    construct: constructYamlBoolean,
	    predicate: isBoolean,
	    represent: {
	        lowercase: function (object) {
	            return object ? 'true' : 'false';
	        },
	        uppercase: function (object) {
	            return object ? 'TRUE' : 'FALSE';
	        },
	        camelcase: function (object) {
	            return object ? 'True' : 'False';
	        }
	    },
	    defaultStyle: 'lowercase'
	});
	//# sourceMappingURL=bool.js.map

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var common = __webpack_require__(57);
	var Type = __webpack_require__(61);
	function isHexCode(c) {
	    return ((0x30 <= c) && (c <= 0x39)) || ((0x41 <= c) && (c <= 0x46)) || ((0x61 <= c) && (c <= 0x66));
	}
	function isOctCode(c) {
	    return ((0x30 <= c) && (c <= 0x37));
	}
	function isDecCode(c) {
	    return ((0x30 <= c) && (c <= 0x39));
	}
	function resolveYamlInteger(data) {
	    if (null === data) {
	        return false;
	    }
	    var max = data.length, index = 0, hasDigits = false, ch;
	    if (!max) {
	        return false;
	    }
	    ch = data[index];
	    // sign
	    if (ch === '-' || ch === '+') {
	        ch = data[++index];
	    }
	    if (ch === '0') {
	        // 0
	        if (index + 1 === max) {
	            return true;
	        }
	        ch = data[++index];
	        // base 2, base 8, base 16
	        if (ch === 'b') {
	            // base 2
	            index++;
	            for (; index < max; index++) {
	                ch = data[index];
	                if (ch === '_') {
	                    continue;
	                }
	                if (ch !== '0' && ch !== '1') {
	                    return false;
	                }
	                hasDigits = true;
	            }
	            return hasDigits;
	        }
	        if (ch === 'x') {
	            // base 16
	            index++;
	            for (; index < max; index++) {
	                ch = data[index];
	                if (ch === '_') {
	                    continue;
	                }
	                if (!isHexCode(data.charCodeAt(index))) {
	                    return false;
	                }
	                hasDigits = true;
	            }
	            return hasDigits;
	        }
	        for (; index < max; index++) {
	            ch = data[index];
	            if (ch === '_') {
	                continue;
	            }
	            if (!isOctCode(data.charCodeAt(index))) {
	                return false;
	            }
	            hasDigits = true;
	        }
	        return hasDigits;
	    }
	    for (; index < max; index++) {
	        ch = data[index];
	        if (ch === '_') {
	            continue;
	        }
	        if (ch === ':') {
	            break;
	        }
	        if (!isDecCode(data.charCodeAt(index))) {
	            return false;
	        }
	        hasDigits = true;
	    }
	    if (!hasDigits) {
	        return false;
	    }
	    // if !base60 - done;
	    if (ch !== ':') {
	        return true;
	    }
	    // base60 almost not used, no needs to optimize
	    return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
	}
	function constructYamlInteger(data) {
	    var value = data, sign = 1, ch, base, digits = [];
	    if (value.indexOf('_') !== -1) {
	        value = value.replace(/_/g, '');
	    }
	    ch = value[0];
	    if (ch === '-' || ch === '+') {
	        if (ch === '-') {
	            sign = -1;
	        }
	        value = value.slice(1);
	        ch = value[0];
	    }
	    if ('0' === value) {
	        return 0;
	    }
	    if (ch === '0') {
	        if (value[1] === 'b') {
	            return sign * parseInt(value.slice(2), 2);
	        }
	        if (value[1] === 'x') {
	            return sign * parseInt(value, 16);
	        }
	        return sign * parseInt(value, 8);
	    }
	    if (value.indexOf(':') !== -1) {
	        value.split(':').forEach(function (v) {
	            digits.unshift(parseInt(v, 10));
	        });
	        value = 0;
	        base = 1;
	        digits.forEach(function (d) {
	            value += (d * base);
	            base *= 60;
	        });
	        return sign * value;
	    }
	    return sign * parseInt(value, 10);
	}
	function isInteger(object) {
	    return ('[object Number]' === Object.prototype.toString.call(object)) && (0 === object % 1 && !common.isNegativeZero(object));
	}
	module.exports = new Type('tag:yaml.org,2002:int', {
	    kind: 'scalar',
	    resolve: resolveYamlInteger,
	    construct: constructYamlInteger,
	    predicate: isInteger,
	    represent: {
	        binary: function (object) {
	            return '0b' + object.toString(2);
	        },
	        octal: function (object) {
	            return '0' + object.toString(8);
	        },
	        decimal: function (object) {
	            return object.toString(10);
	        },
	        hexadecimal: function (object) {
	            return '0x' + object.toString(16).toUpperCase();
	        }
	    },
	    defaultStyle: 'decimal',
	    styleAliases: {
	        binary: [2, 'bin'],
	        octal: [8, 'oct'],
	        decimal: [10, 'dec'],
	        hexadecimal: [16, 'hex']
	    }
	});
	//# sourceMappingURL=int.js.map

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var common = __webpack_require__(57);
	var Type = __webpack_require__(61);
	var YAML_FLOAT_PATTERN = new RegExp('^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?' + '|\\.[0-9_]+(?:[eE][-+][0-9]+)?' + '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' + '|[-+]?\\.(?:inf|Inf|INF)' + '|\\.(?:nan|NaN|NAN))$');
	function resolveYamlFloat(data) {
	    if (null === data) {
	        return false;
	    }
	    var value, sign, base, digits;
	    if (!YAML_FLOAT_PATTERN.test(data)) {
	        return false;
	    }
	    return true;
	}
	function constructYamlFloat(data) {
	    var value, sign, base, digits;
	    value = data.replace(/_/g, '').toLowerCase();
	    sign = '-' === value[0] ? -1 : 1;
	    digits = [];
	    if (0 <= '+-'.indexOf(value[0])) {
	        value = value.slice(1);
	    }
	    if ('.inf' === value) {
	        return (1 === sign) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
	    }
	    else if ('.nan' === value) {
	        return NaN;
	    }
	    else if (0 <= value.indexOf(':')) {
	        value.split(':').forEach(function (v) {
	            digits.unshift(parseFloat(v, 10));
	        });
	        value = 0.0;
	        base = 1;
	        digits.forEach(function (d) {
	            value += d * base;
	            base *= 60;
	        });
	        return sign * value;
	    }
	    return sign * parseFloat(value, 10);
	}
	function representYamlFloat(object, style) {
	    if (isNaN(object)) {
	        switch (style) {
	            case 'lowercase':
	                return '.nan';
	            case 'uppercase':
	                return '.NAN';
	            case 'camelcase':
	                return '.NaN';
	        }
	    }
	    else if (Number.POSITIVE_INFINITY === object) {
	        switch (style) {
	            case 'lowercase':
	                return '.inf';
	            case 'uppercase':
	                return '.INF';
	            case 'camelcase':
	                return '.Inf';
	        }
	    }
	    else if (Number.NEGATIVE_INFINITY === object) {
	        switch (style) {
	            case 'lowercase':
	                return '-.inf';
	            case 'uppercase':
	                return '-.INF';
	            case 'camelcase':
	                return '-.Inf';
	        }
	    }
	    else if (common.isNegativeZero(object)) {
	        return '-0.0';
	    }
	    return object.toString(10);
	}
	function isFloat(object) {
	    return ('[object Number]' === Object.prototype.toString.call(object)) && (0 !== object % 1 || common.isNegativeZero(object));
	}
	module.exports = new Type('tag:yaml.org,2002:float', {
	    kind: 'scalar',
	    resolve: resolveYamlFloat,
	    construct: constructYamlFloat,
	    predicate: isFloat,
	    represent: representYamlFloat,
	    defaultStyle: 'lowercase'
	});
	//# sourceMappingURL=float.js.map

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../typings/tsd.d.ts" />
	'use strict';
	var common = __webpack_require__(57);
	var Mark = (function () {
	    function Mark(name, buffer, position, line, column) {
	        this.name = name;
	        this.buffer = buffer;
	        this.position = position;
	        this.line = line;
	        this.column = column;
	    }
	    Mark.prototype.getSnippet = function (indent, maxLength) {
	        if (indent === void 0) { indent = 0; }
	        if (maxLength === void 0) { maxLength = 75; }
	        var head, start, tail, end, snippet;
	        if (!this.buffer) {
	            return null;
	        }
	        indent = indent || 4;
	        maxLength = maxLength || 75;
	        head = '';
	        start = this.position;
	        while (start > 0 && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1))) {
	            start -= 1;
	            if (this.position - start > (maxLength / 2 - 1)) {
	                head = ' ... ';
	                start += 5;
	                break;
	            }
	        }
	        tail = '';
	        end = this.position;
	        while (end < this.buffer.length && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end))) {
	            end += 1;
	            if (end - this.position > (maxLength / 2 - 1)) {
	                tail = ' ... ';
	                end -= 5;
	                break;
	            }
	        }
	        snippet = this.buffer.slice(start, end);
	        return common.repeat(' ', indent) + head + snippet + tail + '\n' + common.repeat(' ', indent + this.position - start + head.length) + '^';
	    };
	    Mark.prototype.toString = function (compact) {
	        if (compact === void 0) { compact = true; }
	        var snippet, where = '';
	        if (this.name) {
	            where += 'in "' + this.name + '" ';
	        }
	        where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);
	        if (!compact) {
	            snippet = this.getSnippet();
	            if (snippet) {
	                where += ':\n' + snippet;
	            }
	        }
	        return where;
	    };
	    return Mark;
	})();
	module.exports = Mark;
	//# sourceMappingURL=mark.js.map

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	var indexOf = __webpack_require__(123);

	var Object_keys = function (obj) {
	    if (Object.keys) return Object.keys(obj)
	    else {
	        var res = [];
	        for (var key in obj) res.push(key)
	        return res;
	    }
	};

	var forEach = function (xs, fn) {
	    if (xs.forEach) return xs.forEach(fn)
	    else for (var i = 0; i < xs.length; i++) {
	        fn(xs[i], i, xs);
	    }
	};

	var defineProp = (function() {
	    try {
	        Object.defineProperty({}, '_', {});
	        return function(obj, name, value) {
	            Object.defineProperty(obj, name, {
	                writable: true,
	                enumerable: false,
	                configurable: true,
	                value: value
	            })
	        };
	    } catch(e) {
	        return function(obj, name, value) {
	            obj[name] = value;
	        };
	    }
	}());

	var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
	'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
	'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
	'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
	'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

	function Context() {}
	Context.prototype = {};

	var Script = exports.Script = function NodeScript (code) {
	    if (!(this instanceof Script)) return new Script(code);
	    this.code = code;
	};

	Script.prototype.runInContext = function (context) {
	    if (!(context instanceof Context)) {
	        throw new TypeError("needs a 'context' argument.");
	    }
	    
	    var iframe = document.createElement('iframe');
	    if (!iframe.style) iframe.style = {};
	    iframe.style.display = 'none';
	    
	    document.body.appendChild(iframe);
	    
	    var win = iframe.contentWindow;
	    var wEval = win.eval, wExecScript = win.execScript;

	    if (!wEval && wExecScript) {
	        // win.eval() magically appears when this is called in IE:
	        wExecScript.call(win, 'null');
	        wEval = win.eval;
	    }
	    
	    forEach(Object_keys(context), function (key) {
	        win[key] = context[key];
	    });
	    forEach(globals, function (key) {
	        if (context[key]) {
	            win[key] = context[key];
	        }
	    });
	    
	    var winKeys = Object_keys(win);

	    var res = wEval.call(win, this.code);
	    
	    forEach(Object_keys(win), function (key) {
	        // Avoid copying circular objects like `top` and `window` by only
	        // updating existing context properties or new properties in the `win`
	        // that was only introduced after the eval.
	        if (key in context || indexOf(winKeys, key) === -1) {
	            context[key] = win[key];
	        }
	    });

	    forEach(globals, function (key) {
	        if (!(key in context)) {
	            defineProp(context, key, win[key]);
	        }
	    });
	    
	    document.body.removeChild(iframe);
	    
	    return res;
	};

	Script.prototype.runInThisContext = function () {
	    return eval(this.code); // maybe...
	};

	Script.prototype.runInNewContext = function (context) {
	    var ctx = Script.createContext(context);
	    var res = this.runInContext(ctx);

	    forEach(Object_keys(ctx), function (key) {
	        context[key] = ctx[key];
	    });

	    return res;
	};

	forEach(Object_keys(Script.prototype), function (name) {
	    exports[name] = Script[name] = function (code) {
	        var s = Script(code);
	        return s[name].apply(s, [].slice.call(arguments, 1));
	    };
	});

	exports.createScript = function (code) {
	    return exports.Script(code);
	};

	exports.createContext = Script.createContext = function (context) {
	    var copy = new Context();
	    if(typeof context === 'object') {
	        forEach(Object_keys(context), function (key) {
	            copy[key] = context[key];
	        });
	    }
	    return copy;
	};


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	var JsonSchemaCompatability = (function () {

		function convert3to4Type(types, always) {
			if (!Array.isArray(types)) {
				types = [types];
			}
			var needsReplacement = !!always;
			var result = [];
			for (var i = 0; i < types.length; i++) {
				var entry = types[i];
				if (typeof entry === 'object') {
					result.push(entry);
					needsReplacement = true;
				} else {
					result.push({"type": entry});
				}
			}
			return needsReplacement && result;
		}

		function convert3to4(obj) {
			// Old-style "type"
			if (obj.type && typeof obj.type !== 'string') {
				var anyOf = convert3to4Type(obj.type);
				if (anyOf) {
					obj.anyOf = anyOf;
					delete obj.type;
				}
			}
			if (obj['extends']) {
				var allOf = obj['extends'];
				if (!Array.isArray(allOf)) {
					allOf = [allOf];
				}
				obj.allOf = allOf;
				delete obj['extends'];
			}
			if (obj.disallow) {
				if (typeof obj.disallow === 'string') {
					obj.not = {"type": obj.disallow};
				} else {
					obj.not = {"anyOf": convert3to4Type(obj.disallow, true)};
				}
				delete obj.disallow;
			}

			// Object concerns
			if (obj.properties) {
				var required = Array.isArray(obj.required) ? obj.required : [];
				for (var key in obj.properties) {
					var subSchema = obj.properties[key];
					if (subSchema && typeof subSchema.required === 'boolean') {
						if (subSchema.required) {
							required.push(key);
						}
						delete subSchema.required;
					}
				}
				if (required.length) {
					obj.required = required;
				}
			}
			if (obj.dependencies) {
				for (var key in obj.dependencies) {
					if (typeof obj.dependencies[key] === 'string') {
						obj.dependencies[key] = [obj.dependencies[key]];
					}
				}
			}
			
			// Numeric concerns
			if (typeof obj.divisibleBy !== 'undefined') {
				obj.multipleOf = obj.divisibleBy;
				delete obj.divisibleBy;
			}
			

			for (var key in obj) {
				if (key === "properties" || key === "patternProperties" || key === "dependencies") {
					for (var subKey in obj[key]) {
						obj[key][subKey] = convert3to4(obj[key][subKey]);
					}
				} else if (key !== "enum") {
					if (Array.isArray(obj[key])) {
						for (var i = 0; i < obj[key].length; i++) {
							obj[key][i] = convert3to4(obj[key][i]);
						}
					} else if (typeof obj[key] === "object") {
						obj[key] = convert3to4(obj[key]);
					}
				}
			}
			return obj;
		}

		var api = {
			v4: convert3to4
		};
		
		if (true) {
			module.exports = api;
		}
		return api;
	})();

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var parse = __webpack_require__(126).parse;
	var stringify = __webpack_require__(126).stringify;

	module.exports = handleQs;
	function handleQs(url, query) {
	  url = url.split('?');
	  var start = url[0];
	  var qs = (url[1] || '').split('#')[0];
	  var end = url[1] && url[1].split('#').length > 1 ? '#' + url[1].split('#')[1] : '';

	  var baseQs = parse(qs);
	  for (var i in query) {
	    baseQs[i] = query[i];
	  }
	  qs = stringify(baseQs);
	  if (qs !== '') {
	    qs = '?' + qs;
	  }
	  return start + qs + end;
	}


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	function DOMParser(options){
		this.options = options ||{locator:{}};
		
	}
	DOMParser.prototype.parseFromString = function(source,mimeType){	
		var options = this.options;
		var sax =  new XMLReader();
		var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
		var errorHandler = options.errorHandler;
		var locator = options.locator;
		var defaultNSMap = options.xmlns||{};
		var entityMap = {'lt':'<','gt':'>','amp':'&','quot':'"','apos':"'"}
		if(locator){
			domBuilder.setDocumentLocator(locator)
		}
		
		sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);
		sax.domBuilder = options.domBuilder || domBuilder;
		if(/\/x?html?$/.test(mimeType)){
			entityMap.nbsp = '\xa0';
			entityMap.copy = '\xa9';
			defaultNSMap['']= 'http://www.w3.org/1999/xhtml';
		}
		if(source){
			sax.parse(source,defaultNSMap,entityMap);
		}else{
			sax.errorHandler.error("invalid document source");
		}
		return domBuilder.document;
	}
	function buildErrorHandler(errorImpl,domBuilder,locator){
		if(!errorImpl){
			if(domBuilder instanceof DOMHandler){
				return domBuilder;
			}
			errorImpl = domBuilder ;
		}
		var errorHandler = {}
		var isCallback = errorImpl instanceof Function;
		locator = locator||{}
		function build(key){
			var fn = errorImpl[key];
			if(!fn){
				if(isCallback){
					fn = errorImpl.length == 2?function(msg){errorImpl(key,msg)}:errorImpl;
				}else{
					var i=arguments.length;
					while(--i){
						if(fn = errorImpl[arguments[i]]){
							break;
						}
					}
				}
			}
			errorHandler[key] = fn && function(msg){
				fn(msg+_locator(locator));
			}||function(){};
		}
		build('warning','warn');
		build('error','warn','warning');
		build('fatalError','warn','warning','error');
		return errorHandler;
	}
	/**
	 * +ContentHandler+ErrorHandler
	 * +LexicalHandler+EntityResolver2
	 * -DeclHandler-DTDHandler 
	 * 
	 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
	 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
	 */
	function DOMHandler() {
	    this.cdata = false;
	}
	function position(locator,node){
		node.lineNumber = locator.lineNumber;
		node.columnNumber = locator.columnNumber;
	}
	/**
	 * @see org.xml.sax.ContentHandler#startDocument
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
	 */ 
	DOMHandler.prototype = {
		startDocument : function() {
	    	this.document = new DOMImplementation().createDocument(null, null, null);
	    	if (this.locator) {
	        	this.document.documentURI = this.locator.systemId;
	    	}
		},
		startElement:function(namespaceURI, localName, qName, attrs) {
			var doc = this.document;
		    var el = doc.createElementNS(namespaceURI, qName||localName);
		    var len = attrs.length;
		    appendElement(this, el);
		    this.currentElement = el;
		    
			this.locator && position(this.locator,el)
		    for (var i = 0 ; i < len; i++) {
		        var namespaceURI = attrs.getURI(i);
		        var value = attrs.getValue(i);
		        var qName = attrs.getQName(i);
				var attr = doc.createAttributeNS(namespaceURI, qName);
				if( attr.getOffset){
					position(attr.getOffset(1),attr)
				}
				attr.value = attr.nodeValue = value;
				el.setAttributeNode(attr)
		    }
		},
		endElement:function(namespaceURI, localName, qName) {
			var current = this.currentElement
		    var tagName = current.tagName;
		    this.currentElement = current.parentNode;
		},
		startPrefixMapping:function(prefix, uri) {
		},
		endPrefixMapping:function(prefix) {
		},
		processingInstruction:function(target, data) {
		    var ins = this.document.createProcessingInstruction(target, data);
		    this.locator && position(this.locator,ins)
		    appendElement(this, ins);
		},
		ignorableWhitespace:function(ch, start, length) {
		},
		characters:function(chars, start, length) {
			chars = _toString.apply(this,arguments)
			//console.log(chars)
			if(this.currentElement && chars){
				if (this.cdata) {
					var charNode = this.document.createCDATASection(chars);
					this.currentElement.appendChild(charNode);
				} else {
					var charNode = this.document.createTextNode(chars);
					this.currentElement.appendChild(charNode);
				}
				this.locator && position(this.locator,charNode)
			}
		},
		skippedEntity:function(name) {
		},
		endDocument:function() {
			this.document.normalize();
		},
		setDocumentLocator:function (locator) {
		    if(this.locator = locator){// && !('lineNumber' in locator)){
		    	locator.lineNumber = 0;
		    }
		},
		//LexicalHandler
		comment:function(chars, start, length) {
			chars = _toString.apply(this,arguments)
		    var comm = this.document.createComment(chars);
		    this.locator && position(this.locator,comm)
		    appendElement(this, comm);
		},
		
		startCDATA:function() {
		    //used in characters() methods
		    this.cdata = true;
		},
		endCDATA:function() {
		    this.cdata = false;
		},
		
		startDTD:function(name, publicId, systemId) {
			var impl = this.document.implementation;
		    if (impl && impl.createDocumentType) {
		        var dt = impl.createDocumentType(name, publicId, systemId);
		        this.locator && position(this.locator,dt)
		        appendElement(this, dt);
		    }
		},
		/**
		 * @see org.xml.sax.ErrorHandler
		 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
		 */
		warning:function(error) {
			console.warn(error,_locator(this.locator));
		},
		error:function(error) {
			console.error(error,_locator(this.locator));
		},
		fatalError:function(error) {
			console.error(error,_locator(this.locator));
		    throw error;
		}
	}
	function _locator(l){
		if(l){
			return '\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'
		}
	}
	function _toString(chars,start,length){
		if(typeof chars == 'string'){
			return chars.substr(start,length)
		}else{//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
			if(chars.length >= start+length || start){
				return new java.lang.String(chars,start,length)+'';
			}
			return chars;
		}
	}

	/*
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
	 * used method of org.xml.sax.ext.LexicalHandler:
	 *  #comment(chars, start, length)
	 *  #startCDATA()
	 *  #endCDATA()
	 *  #startDTD(name, publicId, systemId)
	 *
	 *
	 * IGNORED method of org.xml.sax.ext.LexicalHandler:
	 *  #endDTD()
	 *  #startEntity(name)
	 *  #endEntity(name)
	 *
	 *
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
	 * IGNORED method of org.xml.sax.ext.DeclHandler
	 * 	#attributeDecl(eName, aName, type, mode, value)
	 *  #elementDecl(name, model)
	 *  #externalEntityDecl(name, publicId, systemId)
	 *  #internalEntityDecl(name, value)
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
	 * IGNORED method of org.xml.sax.EntityResolver2
	 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
	 *  #resolveEntity(publicId, systemId)
	 *  #getExternalSubset(name, baseURI)
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
	 * IGNORED method of org.xml.sax.DTDHandler
	 *  #notationDecl(name, publicId, systemId) {};
	 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
	 */
	"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){
		DOMHandler.prototype[key] = function(){return null}
	})

	/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
	function appendElement (hander,node) {
	    if (!hander.currentElement) {
	        hander.document.appendChild(node);
	    } else {
	        hander.currentElement.appendChild(node);
	    }
	}//appendChild and setAttributeNS are preformance key

	if(true){
		var XMLReader = __webpack_require__(121).XMLReader;
		var DOMImplementation = exports.DOMImplementation = __webpack_require__(122).DOMImplementation;
		exports.XMLSerializer = __webpack_require__(122).XMLSerializer ;
		exports.DOMParser = DOMParser;
	}


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = __webpack_require__(127);

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(137);

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(72)))

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	exports.parse = __webpack_require__(124);
	exports.stringify = __webpack_require__(125);


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	var undefined = (void 0); // Paranoia

	// Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to
	// create, and consume so much memory, that the browser appears frozen.
	var MAX_ARRAY_LENGTH = 1e5;

	// Approximations of internal ECMAScript conversion functions
	var ECMAScript = (function() {
	  // Stash a copy in case other scripts modify these
	  var opts = Object.prototype.toString,
	      ophop = Object.prototype.hasOwnProperty;

	  return {
	    // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:
	    Class: function(v) { return opts.call(v).replace(/^\[object *|\]$/g, ''); },
	    HasProperty: function(o, p) { return p in o; },
	    HasOwnProperty: function(o, p) { return ophop.call(o, p); },
	    IsCallable: function(o) { return typeof o === 'function'; },
	    ToInt32: function(v) { return v >> 0; },
	    ToUint32: function(v) { return v >>> 0; }
	  };
	}());

	// Snapshot intrinsics
	var LN2 = Math.LN2,
	    abs = Math.abs,
	    floor = Math.floor,
	    log = Math.log,
	    min = Math.min,
	    pow = Math.pow,
	    round = Math.round;

	// ES5: lock down object properties
	function configureProperties(obj) {
	  if (getOwnPropNames && defineProp) {
	    var props = getOwnPropNames(obj), i;
	    for (i = 0; i < props.length; i += 1) {
	      defineProp(obj, props[i], {
	        value: obj[props[i]],
	        writable: false,
	        enumerable: false,
	        configurable: false
	      });
	    }
	  }
	}

	// emulate ES5 getter/setter API using legacy APIs
	// http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx
	// (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but
	// note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)
	var defineProp
	if (Object.defineProperty && (function() {
	      try {
	        Object.defineProperty({}, 'x', {});
	        return true;
	      } catch (e) {
	        return false;
	      }
	    })()) {
	  defineProp = Object.defineProperty;
	} else {
	  defineProp = function(o, p, desc) {
	    if (!o === Object(o)) throw new TypeError("Object.defineProperty called on non-object");
	    if (ECMAScript.HasProperty(desc, 'get') && Object.prototype.__defineGetter__) { Object.prototype.__defineGetter__.call(o, p, desc.get); }
	    if (ECMAScript.HasProperty(desc, 'set') && Object.prototype.__defineSetter__) { Object.prototype.__defineSetter__.call(o, p, desc.set); }
	    if (ECMAScript.HasProperty(desc, 'value')) { o[p] = desc.value; }
	    return o;
	  };
	}

	var getOwnPropNames = Object.getOwnPropertyNames || function (o) {
	  if (o !== Object(o)) throw new TypeError("Object.getOwnPropertyNames called on non-object");
	  var props = [], p;
	  for (p in o) {
	    if (ECMAScript.HasOwnProperty(o, p)) {
	      props.push(p);
	    }
	  }
	  return props;
	};

	// ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)
	// for index in 0 ... obj.length
	function makeArrayAccessors(obj) {
	  if (!defineProp) { return; }

	  if (obj.length > MAX_ARRAY_LENGTH) throw new RangeError("Array too large for polyfill");

	  function makeArrayAccessor(index) {
	    defineProp(obj, index, {
	      'get': function() { return obj._getter(index); },
	      'set': function(v) { obj._setter(index, v); },
	      enumerable: true,
	      configurable: false
	    });
	  }

	  var i;
	  for (i = 0; i < obj.length; i += 1) {
	    makeArrayAccessor(i);
	  }
	}

	// Internal conversion functions:
	//    pack<Type>()   - take a number (interpreted as Type), output a byte array
	//    unpack<Type>() - take a byte array, output a Type-like number

	function as_signed(value, bits) { var s = 32 - bits; return (value << s) >> s; }
	function as_unsigned(value, bits) { var s = 32 - bits; return (value << s) >>> s; }

	function packI8(n) { return [n & 0xff]; }
	function unpackI8(bytes) { return as_signed(bytes[0], 8); }

	function packU8(n) { return [n & 0xff]; }
	function unpackU8(bytes) { return as_unsigned(bytes[0], 8); }

	function packU8Clamped(n) { n = round(Number(n)); return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff]; }

	function packI16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
	function unpackI16(bytes) { return as_signed(bytes[0] << 8 | bytes[1], 16); }

	function packU16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
	function unpackU16(bytes) { return as_unsigned(bytes[0] << 8 | bytes[1], 16); }

	function packI32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
	function unpackI32(bytes) { return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }

	function packU32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
	function unpackU32(bytes) { return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }

	function packIEEE754(v, ebits, fbits) {

	  var bias = (1 << (ebits - 1)) - 1,
	      s, e, f, ln,
	      i, bits, str, bytes;

	  function roundToEven(n) {
	    var w = floor(n), f = n - w;
	    if (f < 0.5)
	      return w;
	    if (f > 0.5)
	      return w + 1;
	    return w % 2 ? w + 1 : w;
	  }

	  // Compute sign, exponent, fraction
	  if (v !== v) {
	    // NaN
	    // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping
	    e = (1 << ebits) - 1; f = pow(2, fbits - 1); s = 0;
	  } else if (v === Infinity || v === -Infinity) {
	    e = (1 << ebits) - 1; f = 0; s = (v < 0) ? 1 : 0;
	  } else if (v === 0) {
	    e = 0; f = 0; s = (1 / v === -Infinity) ? 1 : 0;
	  } else {
	    s = v < 0;
	    v = abs(v);

	    if (v >= pow(2, 1 - bias)) {
	      e = min(floor(log(v) / LN2), 1023);
	      f = roundToEven(v / pow(2, e) * pow(2, fbits));
	      if (f / pow(2, fbits) >= 2) {
	        e = e + 1;
	        f = 1;
	      }
	      if (e > bias) {
	        // Overflow
	        e = (1 << ebits) - 1;
	        f = 0;
	      } else {
	        // Normalized
	        e = e + bias;
	        f = f - pow(2, fbits);
	      }
	    } else {
	      // Denormalized
	      e = 0;
	      f = roundToEven(v / pow(2, 1 - bias - fbits));
	    }
	  }

	  // Pack sign, exponent, fraction
	  bits = [];
	  for (i = fbits; i; i -= 1) { bits.push(f % 2 ? 1 : 0); f = floor(f / 2); }
	  for (i = ebits; i; i -= 1) { bits.push(e % 2 ? 1 : 0); e = floor(e / 2); }
	  bits.push(s ? 1 : 0);
	  bits.reverse();
	  str = bits.join('');

	  // Bits to bytes
	  bytes = [];
	  while (str.length) {
	    bytes.push(parseInt(str.substring(0, 8), 2));
	    str = str.substring(8);
	  }
	  return bytes;
	}

	function unpackIEEE754(bytes, ebits, fbits) {

	  // Bytes to bits
	  var bits = [], i, j, b, str,
	      bias, s, e, f;

	  for (i = bytes.length; i; i -= 1) {
	    b = bytes[i - 1];
	    for (j = 8; j; j -= 1) {
	      bits.push(b % 2 ? 1 : 0); b = b >> 1;
	    }
	  }
	  bits.reverse();
	  str = bits.join('');

	  // Unpack sign, exponent, fraction
	  bias = (1 << (ebits - 1)) - 1;
	  s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
	  e = parseInt(str.substring(1, 1 + ebits), 2);
	  f = parseInt(str.substring(1 + ebits), 2);

	  // Produce number
	  if (e === (1 << ebits) - 1) {
	    return f !== 0 ? NaN : s * Infinity;
	  } else if (e > 0) {
	    // Normalized
	    return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
	  } else if (f !== 0) {
	    // Denormalized
	    return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
	  } else {
	    return s < 0 ? -0 : 0;
	  }
	}

	function unpackF64(b) { return unpackIEEE754(b, 11, 52); }
	function packF64(v) { return packIEEE754(v, 11, 52); }
	function unpackF32(b) { return unpackIEEE754(b, 8, 23); }
	function packF32(v) { return packIEEE754(v, 8, 23); }


	//
	// 3 The ArrayBuffer Type
	//

	(function() {

	  /** @constructor */
	  var ArrayBuffer = function ArrayBuffer(length) {
	    length = ECMAScript.ToInt32(length);
	    if (length < 0) throw new RangeError('ArrayBuffer size is not a small enough positive integer');

	    this.byteLength = length;
	    this._bytes = [];
	    this._bytes.length = length;

	    var i;
	    for (i = 0; i < this.byteLength; i += 1) {
	      this._bytes[i] = 0;
	    }

	    configureProperties(this);
	  };

	  exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer;

	  //
	  // 4 The ArrayBufferView Type
	  //

	  // NOTE: this constructor is not exported
	  /** @constructor */
	  var ArrayBufferView = function ArrayBufferView() {
	    //this.buffer = null;
	    //this.byteOffset = 0;
	    //this.byteLength = 0;
	  };

	  //
	  // 5 The Typed Array View Types
	  //

	  function makeConstructor(bytesPerElement, pack, unpack) {
	    // Each TypedArray type requires a distinct constructor instance with
	    // identical logic, which this produces.

	    var ctor;
	    ctor = function(buffer, byteOffset, length) {
	      var array, sequence, i, s;

	      if (!arguments.length || typeof arguments[0] === 'number') {
	        // Constructor(unsigned long length)
	        this.length = ECMAScript.ToInt32(arguments[0]);
	        if (length < 0) throw new RangeError('ArrayBufferView size is not a small enough positive integer');

	        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
	        this.buffer = new ArrayBuffer(this.byteLength);
	        this.byteOffset = 0;
	      } else if (typeof arguments[0] === 'object' && arguments[0].constructor === ctor) {
	        // Constructor(TypedArray array)
	        array = arguments[0];

	        this.length = array.length;
	        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
	        this.buffer = new ArrayBuffer(this.byteLength);
	        this.byteOffset = 0;

	        for (i = 0; i < this.length; i += 1) {
	          this._setter(i, array._getter(i));
	        }
	      } else if (typeof arguments[0] === 'object' &&
	                 !(arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {
	        // Constructor(sequence<type> array)
	        sequence = arguments[0];

	        this.length = ECMAScript.ToUint32(sequence.length);
	        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
	        this.buffer = new ArrayBuffer(this.byteLength);
	        this.byteOffset = 0;

	        for (i = 0; i < this.length; i += 1) {
	          s = sequence[i];
	          this._setter(i, Number(s));
	        }
	      } else if (typeof arguments[0] === 'object' &&
	                 (arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {
	        // Constructor(ArrayBuffer buffer,
	        //             optional unsigned long byteOffset, optional unsigned long length)
	        this.buffer = buffer;

	        this.byteOffset = ECMAScript.ToUint32(byteOffset);
	        if (this.byteOffset > this.buffer.byteLength) {
	          throw new RangeError("byteOffset out of range");
	        }

	        if (this.byteOffset % this.BYTES_PER_ELEMENT) {
	          // The given byteOffset must be a multiple of the element
	          // size of the specific type, otherwise an exception is raised.
	          throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
	        }

	        if (arguments.length < 3) {
	          this.byteLength = this.buffer.byteLength - this.byteOffset;

	          if (this.byteLength % this.BYTES_PER_ELEMENT) {
	            throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
	          }
	          this.length = this.byteLength / this.BYTES_PER_ELEMENT;
	        } else {
	          this.length = ECMAScript.ToUint32(length);
	          this.byteLength = this.length * this.BYTES_PER_ELEMENT;
	        }

	        if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {
	          throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
	        }
	      } else {
	        throw new TypeError("Unexpected argument type(s)");
	      }

	      this.constructor = ctor;

	      configureProperties(this);
	      makeArrayAccessors(this);
	    };

	    ctor.prototype = new ArrayBufferView();
	    ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
	    ctor.prototype._pack = pack;
	    ctor.prototype._unpack = unpack;
	    ctor.BYTES_PER_ELEMENT = bytesPerElement;

	    // getter type (unsigned long index);
	    ctor.prototype._getter = function(index) {
	      if (arguments.length < 1) throw new SyntaxError("Not enough arguments");

	      index = ECMAScript.ToUint32(index);
	      if (index >= this.length) {
	        return undefined;
	      }

	      var bytes = [], i, o;
	      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
	           i < this.BYTES_PER_ELEMENT;
	           i += 1, o += 1) {
	        bytes.push(this.buffer._bytes[o]);
	      }
	      return this._unpack(bytes);
	    };

	    // NONSTANDARD: convenience alias for getter: type get(unsigned long index);
	    ctor.prototype.get = ctor.prototype._getter;

	    // setter void (unsigned long index, type value);
	    ctor.prototype._setter = function(index, value) {
	      if (arguments.length < 2) throw new SyntaxError("Not enough arguments");

	      index = ECMAScript.ToUint32(index);
	      if (index >= this.length) {
	        return undefined;
	      }

	      var bytes = this._pack(value), i, o;
	      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
	           i < this.BYTES_PER_ELEMENT;
	           i += 1, o += 1) {
	        this.buffer._bytes[o] = bytes[i];
	      }
	    };

	    // void set(TypedArray array, optional unsigned long offset);
	    // void set(sequence<type> array, optional unsigned long offset);
	    ctor.prototype.set = function(index, value) {
	      if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
	      var array, sequence, offset, len,
	          i, s, d,
	          byteOffset, byteLength, tmp;

	      if (typeof arguments[0] === 'object' && arguments[0].constructor === this.constructor) {
	        // void set(TypedArray array, optional unsigned long offset);
	        array = arguments[0];
	        offset = ECMAScript.ToUint32(arguments[1]);

	        if (offset + array.length > this.length) {
	          throw new RangeError("Offset plus length of array is out of range");
	        }

	        byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
	        byteLength = array.length * this.BYTES_PER_ELEMENT;

	        if (array.buffer === this.buffer) {
	          tmp = [];
	          for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {
	            tmp[i] = array.buffer._bytes[s];
	          }
	          for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
	            this.buffer._bytes[d] = tmp[i];
	          }
	        } else {
	          for (i = 0, s = array.byteOffset, d = byteOffset;
	               i < byteLength; i += 1, s += 1, d += 1) {
	            this.buffer._bytes[d] = array.buffer._bytes[s];
	          }
	        }
	      } else if (typeof arguments[0] === 'object' && typeof arguments[0].length !== 'undefined') {
	        // void set(sequence<type> array, optional unsigned long offset);
	        sequence = arguments[0];
	        len = ECMAScript.ToUint32(sequence.length);
	        offset = ECMAScript.ToUint32(arguments[1]);

	        if (offset + len > this.length) {
	          throw new RangeError("Offset plus length of array is out of range");
	        }

	        for (i = 0; i < len; i += 1) {
	          s = sequence[i];
	          this._setter(offset + i, Number(s));
	        }
	      } else {
	        throw new TypeError("Unexpected argument type(s)");
	      }
	    };

	    // TypedArray subarray(long begin, optional long end);
	    ctor.prototype.subarray = function(start, end) {
	      function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }

	      start = ECMAScript.ToInt32(start);
	      end = ECMAScript.ToInt32(end);

	      if (arguments.length < 1) { start = 0; }
	      if (arguments.length < 2) { end = this.length; }

	      if (start < 0) { start = this.length + start; }
	      if (end < 0) { end = this.length + end; }

	      start = clamp(start, 0, this.length);
	      end = clamp(end, 0, this.length);

	      var len = end - start;
	      if (len < 0) {
	        len = 0;
	      }

	      return new this.constructor(
	        this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);
	    };

	    return ctor;
	  }

	  var Int8Array = makeConstructor(1, packI8, unpackI8);
	  var Uint8Array = makeConstructor(1, packU8, unpackU8);
	  var Uint8ClampedArray = makeConstructor(1, packU8Clamped, unpackU8);
	  var Int16Array = makeConstructor(2, packI16, unpackI16);
	  var Uint16Array = makeConstructor(2, packU16, unpackU16);
	  var Int32Array = makeConstructor(4, packI32, unpackI32);
	  var Uint32Array = makeConstructor(4, packU32, unpackU32);
	  var Float32Array = makeConstructor(4, packF32, unpackF32);
	  var Float64Array = makeConstructor(8, packF64, unpackF64);

	  exports.Int8Array = exports.Int8Array || Int8Array;
	  exports.Uint8Array = exports.Uint8Array || Uint8Array;
	  exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray;
	  exports.Int16Array = exports.Int16Array || Int16Array;
	  exports.Uint16Array = exports.Uint16Array || Uint16Array;
	  exports.Int32Array = exports.Int32Array || Int32Array;
	  exports.Uint32Array = exports.Uint32Array || Uint32Array;
	  exports.Float32Array = exports.Float32Array || Float32Array;
	  exports.Float64Array = exports.Float64Array || Float64Array;
	}());

	//
	// 6 The DataView View Type
	//

	(function() {
	  function r(array, index) {
	    return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
	  }

	  var IS_BIG_ENDIAN = (function() {
	    var u16array = new(exports.Uint16Array)([0x1234]),
	        u8array = new(exports.Uint8Array)(u16array.buffer);
	    return r(u8array, 0) === 0x12;
	  }());

	  // Constructor(ArrayBuffer buffer,
	  //             optional unsigned long byteOffset,
	  //             optional unsigned long byteLength)
	  /** @constructor */
	  var DataView = function DataView(buffer, byteOffset, byteLength) {
	    if (arguments.length === 0) {
	      buffer = new exports.ArrayBuffer(0);
	    } else if (!(buffer instanceof exports.ArrayBuffer || ECMAScript.Class(buffer) === 'ArrayBuffer')) {
	      throw new TypeError("TypeError");
	    }

	    this.buffer = buffer || new exports.ArrayBuffer(0);

	    this.byteOffset = ECMAScript.ToUint32(byteOffset);
	    if (this.byteOffset > this.buffer.byteLength) {
	      throw new RangeError("byteOffset out of range");
	    }

	    if (arguments.length < 3) {
	      this.byteLength = this.buffer.byteLength - this.byteOffset;
	    } else {
	      this.byteLength = ECMAScript.ToUint32(byteLength);
	    }

	    if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {
	      throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
	    }

	    configureProperties(this);
	  };

	  function makeGetter(arrayType) {
	    return function(byteOffset, littleEndian) {

	      byteOffset = ECMAScript.ToUint32(byteOffset);

	      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
	        throw new RangeError("Array index out of range");
	      }
	      byteOffset += this.byteOffset;

	      var uint8Array = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),
	          bytes = [], i;
	      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
	        bytes.push(r(uint8Array, i));
	      }

	      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
	        bytes.reverse();
	      }

	      return r(new arrayType(new exports.Uint8Array(bytes).buffer), 0);
	    };
	  }

	  DataView.prototype.getUint8 = makeGetter(exports.Uint8Array);
	  DataView.prototype.getInt8 = makeGetter(exports.Int8Array);
	  DataView.prototype.getUint16 = makeGetter(exports.Uint16Array);
	  DataView.prototype.getInt16 = makeGetter(exports.Int16Array);
	  DataView.prototype.getUint32 = makeGetter(exports.Uint32Array);
	  DataView.prototype.getInt32 = makeGetter(exports.Int32Array);
	  DataView.prototype.getFloat32 = makeGetter(exports.Float32Array);
	  DataView.prototype.getFloat64 = makeGetter(exports.Float64Array);

	  function makeSetter(arrayType) {
	    return function(byteOffset, value, littleEndian) {

	      byteOffset = ECMAScript.ToUint32(byteOffset);
	      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
	        throw new RangeError("Array index out of range");
	      }

	      // Get bytes
	      var typeArray = new arrayType([value]),
	          byteArray = new exports.Uint8Array(typeArray.buffer),
	          bytes = [], i, byteView;

	      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
	        bytes.push(r(byteArray, i));
	      }

	      // Flip if necessary
	      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
	        bytes.reverse();
	      }

	      // Write them
	      byteView = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
	      byteView.set(bytes);
	    };
	  }

	  DataView.prototype.setUint8 = makeSetter(exports.Uint8Array);
	  DataView.prototype.setInt8 = makeSetter(exports.Int8Array);
	  DataView.prototype.setUint16 = makeSetter(exports.Uint16Array);
	  DataView.prototype.setInt16 = makeSetter(exports.Int16Array);
	  DataView.prototype.setUint32 = makeSetter(exports.Uint32Array);
	  DataView.prototype.setInt32 = makeSetter(exports.Int32Array);
	  DataView.prototype.setFloat32 = makeSetter(exports.Float32Array);
	  DataView.prototype.setFloat64 = makeSetter(exports.Float64Array);

	  exports.DataView = exports.DataView || DataView;

	}());


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [
		{
			"code": "1xx",
			"phrase": "**Informational**",
			"description": "\"indicates an interim response for communicating connection status or request progress prior to completing the requested action and sending a final response.\" ~ [sure](http://www.urbandictionary.com/define.php?term=sure)",
			"spec_title": "RFC7231#6.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.2"
		},
		{
			"code": "100",
			"phrase": "Continue",
			"description": "\"indicates that the initial part of a request has been received and has not yet been rejected by the server.\"",
			"spec_title": "RFC7231#6.2.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.2.1"
		},
		{
			"code": "101",
			"phrase": "Switching Protocols",
			"description": "\"indicates that the server understands and is willing to comply with the client's request, via the Upgrade header field, for a change in the application protocol being used on this connection.\"",
			"spec_title": "RFC7231#6.2.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.2.2"
		},
		{
			"code": "2xx",
			"phrase": "**Successful**",
			"description": "\"indicates that the client's request was successfully received, understood, and accepted.\" ~ [cool](https://twitter.com/DanaDanger/status/183316183494311936)",
			"spec_title": "RFC7231#6.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3"
		},
		{
			"code": "200",
			"phrase": "OK",
			"description": "\"indicates that the request has succeeded.\"",
			"spec_title": "RFC7231#6.3.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3.1"
		},
		{
			"code": "201",
			"phrase": "Created",
			"description": "\"indicates that the request has been fulfilled and has resulted in one or more new resources being created.\"",
			"spec_title": "RFC7231#6.3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3.2"
		},
		{
			"code": "202",
			"phrase": "Accepted",
			"description": "\"indicates that the request has been accepted for processing, but the processing has not been completed.\"",
			"spec_title": "RFC7231#6.3.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3.3"
		},
		{
			"code": "203",
			"phrase": "Non-Authoritative Information",
			"description": "\"indicates that the request was successful but the enclosed payload has been modified from that of the origin server's 200 (OK) response by a transforming proxy.\"",
			"spec_title": "RFC7231#6.3.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3.4"
		},
		{
			"code": "204",
			"phrase": "No Content",
			"description": "\"indicates that the server has successfully fulfilled the request and that there is no additional content to send in the response payload body.\"",
			"spec_title": "RFC7231#6.3.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3.5"
		},
		{
			"code": "205",
			"phrase": "Reset Content",
			"description": "\"indicates that the server has fulfilled the request and desires that the user agent reset the \"document view\", which caused the request to be sent, to its original state as received from the origin server.\"",
			"spec_title": "RFC7231#6.3.6",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3.6"
		},
		{
			"code": "206",
			"phrase": "Partial Content",
			"description": "\"indicates that the server is successfully fulfilling a range request for the target resource by transferring one or more parts of the selected representation that correspond to the satisfiable ranges found in the requests's Range header field.\"",
			"spec_title": "RFC7233#4.1",
			"spec_href": "http://tools.ietf.org/html/rfc7233#section-4.1"
		},
		{
			"code": "3xx",
			"phrase": "**Redirection**",
			"description": "\"indicates that further action needs to be taken by the user agent in order to fulfill the request.\" ~ [ask that dude over there](https://twitter.com/DanaDanger/status/183316183494311936)",
			"spec_title": "RFC7231#6.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.4"
		},
		{
			"code": "300",
			"phrase": "Multiple Choices",
			"description": "\"indicates that the target resource has more than one representation, each with its own more specific identifier, and information about the alternatives is being provided so that the user (or user agent) can select a preferred representation by redirecting its request to one or more of those identifiers.\"",
			"spec_title": "RFC7231#6.4.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.4.1"
		},
		{
			"code": "301",
			"phrase": "Moved Permanently",
			"description": "\"indicates that the target resource has been assigned a new permanent URI and any future references to this resource ought to use one of the enclosed URIs.\"",
			"spec_title": "RFC7231#6.4.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.4.2"
		},
		{
			"code": "302",
			"phrase": "Found",
			"description": "\"indicates that the target resource resides temporarily under a different URI.\"",
			"spec_title": "RFC7231#6.4.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.4.3"
		},
		{
			"code": "303",
			"phrase": "See Other",
			"description": "\"indicates that the server is redirecting the user agent to a different resource, as indicated by a URI in the Location header field, that is intended to provide an indirect response to the original request.\"",
			"spec_title": "RFC7231#6.4.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.4.4"
		},
		{
			"code": "304",
			"phrase": "Not Modified",
			"description": "\"indicates that a conditional GET request has been received and would have resulted in a 200 (OK) response if it were not for the fact that the condition has evaluated to false.\"",
			"spec_title": "RFC7232#4.1",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-4.1"
		},
		{
			"code": "305",
			"phrase": "Use Proxy",
			"description": "*deprecated*",
			"spec_title": "RFC7231#6.4.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.4.5"
		},
		{
			"code": "307",
			"phrase": "Temporary Redirect",
			"description": "\"indicates that the target resource resides temporarily under a different URI and the user agent MUST NOT change the request method if it performs an automatic redirection to that URI.\"",
			"spec_title": "RFC7231#6.4.7",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.4.7"
		},
		{
			"code": "4xx",
			"phrase": "**Client Error**",
			"description": "\"indicates that the client seems to have erred.\" ~ [*you* fucked up](https://twitter.com/DanaDanger/status/183316183494311936)",
			"spec_title": "RFC7231#6.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5"
		},
		{
			"code": "400",
			"phrase": "Bad Request",
			"description": "\"indicates that the server cannot or will not process the request because the received syntax is invalid, nonsensical, or exceeds some limitation on what the server is willing to process.\"",
			"spec_title": "RFC7231#6.5.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.1"
		},
		{
			"code": "401",
			"phrase": "Unauthorized",
			"description": "\"indicates that the request has not been applied because it lacks valid authentication credentials for the target resource.\"",
			"spec_title": "RFC7235#6.3.1",
			"spec_href": "http://tools.ietf.org/html/rfc7235#section-3.1"
		},
		{
			"code": "402",
			"phrase": "Payment Required",
			"description": "*reserved*",
			"spec_title": "RFC7231#6.5.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.2"
		},
		{
			"code": "403",
			"phrase": "Forbidden",
			"description": "\"indicates that the server understood the request but refuses to authorize it.\"",
			"spec_title": "RFC7231#6.5.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.3"
		},
		{
			"code": "404",
			"phrase": "Not Found",
			"description": "\"indicates that the origin server did not find a current representation for the target resource or is not willing to disclose that one exists.\"",
			"spec_title": "RFC7231#6.5.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.4"
		},
		{
			"code": "405",
			"phrase": "Method Not Allowed",
			"description": "\"indicates that the method specified in the request-line is known by the origin server but not supported by the target resource.\"",
			"spec_title": "RFC7231#6.5.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.5"
		},
		{
			"code": "406",
			"phrase": "Not Acceptable",
			"description": "\"indicates that the target resource does not have a current representation that would be acceptable to the user agent, according to the proactive negotiation header fields received in the request, and the server is unwilling to supply a default representation.\"",
			"spec_title": "RFC7231#6.5.6",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.6"
		},
		{
			"code": "407",
			"phrase": "Proxy Authentication Required",
			"description": "\"is similar to 401 (Unauthorized), but indicates that the client needs to authenticate itself in order to use a proxy.\"",
			"spec_title": "RFC7231#6.3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3.2"
		},
		{
			"code": "408",
			"phrase": "Request Timeout",
			"description": "\"indicates that the server did not receive a complete request message within the time that it was prepared to wait.\"",
			"spec_title": "RFC7231#6.5.7",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.7"
		},
		{
			"code": "409",
			"phrase": "Conflict",
			"description": "\"indicates that the request could not be completed due to a conflict with the current state of the resource.\"",
			"spec_title": "RFC7231#6.5.8",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.8"
		},
		{
			"code": "410",
			"phrase": "Gone",
			"description": "\"indicates that access to the target resource is no longer available at the origin server and that this condition is likely to be permanent.\"",
			"spec_title": "RFC7231#6.5.9",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.9"
		},
		{
			"code": "411",
			"phrase": "Length Required",
			"description": "\"indicates that the server refuses to accept the request without a defined Content-Length.\"",
			"spec_title": "RFC7231#6.5.10",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.10"
		},
		{
			"code": "412",
			"phrase": "Precondition Failed",
			"description": "\"indicates that one or more preconditions given in the request header fields evaluated to false when tested on the server.\"",
			"spec_title": "RFC7232#4.2",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-4.2"
		},
		{
			"code": "413",
			"phrase": "Payload Too Large",
			"description": "\"indicates that the server is refusing to process a request because the request payload is larger than the server is willing or able to process.\"",
			"spec_title": "RFC7231#6.5.11",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.11"
		},
		{
			"code": "414",
			"phrase": "URI Too Long",
			"description": "\"indicates that the server is refusing to service the request because the request-target is longer than the server is willing to interpret.\"",
			"spec_title": "RFC7231#6.5.12",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.12"
		},
		{
			"code": "415",
			"phrase": "Unsupported Media Type",
			"description": "\"indicates that the origin server is refusing to service the request because the payload is in a format not supported by the target resource for this method.\"",
			"spec_title": "RFC7231#6.5.13",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.13"
		},
		{
			"code": "416",
			"phrase": "Range Not Satisfiable",
			"description": "\"indicates that none of the ranges in the request's Range header field overlap the current extent of the selected resource or that the set of ranges requested has been rejected due to invalid ranges or an excessive request of small or overlapping ranges.\"",
			"spec_title": "RFC7233#4.4",
			"spec_href": "http://tools.ietf.org/html/rfc7233#section-4.4"
		},
		{
			"code": "417",
			"phrase": "Expectation Failed",
			"description": "\"indicates that the expectation given in the request's Expect header field could not be met by at least one of the inbound servers.\"",
			"spec_title": "RFC7231#6.5.14",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.14"
		},
		{
			"code": "426",
			"phrase": "Upgrade Required",
			"description": "\"indicates that the server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol.\"",
			"spec_title": "RFC7231#6.5.15",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.15"
		},
		{
			"code": "5xx",
			"phrase": "**Server Error**",
			"description": "\"indicates that the server is aware that it has erred or is incapable of performing the requested method.\" ~ [*we* fucked up](https://twitter.com/DanaDanger/status/183316183494311936)",
			"spec_title": "RFC7231#6.6",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.6"
		},
		{
			"code": "500",
			"phrase": "Internal Server Error",
			"description": "\"indicates that the server encountered an unexpected condition that prevented it from fulfilling the request.\"",
			"spec_title": "RFC7231#6.6.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.6.1"
		},
		{
			"code": "501",
			"phrase": "Not Implemented",
			"description": "\"indicates that the server does not support the functionality required to fulfill the request.\"",
			"spec_title": "RFC7231#6.6.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.6.2"
		},
		{
			"code": "502",
			"phrase": "Bad Gateway",
			"description": "\"indicates that the server, while acting as a gateway or proxy, received an invalid response from an inbound server it accessed while attempting to fulfill the request.\"",
			"spec_title": "RFC7231#6.6.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.6.3"
		},
		{
			"code": "503",
			"phrase": "Service Unavailable",
			"description": "\"indicates that the server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.\"",
			"spec_title": "RFC7231#6.6.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.6.4"
		},
		{
			"code": "504",
			"phrase": "Gateway Time-out",
			"description": "\"indicates that the server, while acting as a gateway or proxy, did not receive a timely response from an upstream server it needed to access in order to complete the request.\"",
			"spec_title": "RFC7231#6.6.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.6.5"
		},
		{
			"code": "505",
			"phrase": "HTTP Version Not Supported",
			"description": "\"indicates that the server does not support, or refuses to support, the protocol version that was used in the request message.\"",
			"spec_title": "RFC7231#6.6.6",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.6.6"
		},
		{
			"code": "102",
			"phrase": "Processing",
			"description": "\"is an interim response used to inform the client that the server has accepted the complete request, but has not yet completed it.\"",
			"spec_title": "RFC5218#10.1",
			"spec_href": "http://tools.ietf.org/html/rfc2518#section-10.1"
		},
		{
			"code": "207",
			"phrase": "Multi-Status",
			"description": "\"provides status for multiple independent operations.\"",
			"spec_title": "RFC5218#10.2",
			"spec_href": "http://tools.ietf.org/html/rfc2518#section-10.2"
		},
		{
			"code": "226",
			"phrase": "IM Used",
			"description": "\"The server has fulfilled a GET request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.\"",
			"spec_title": "RFC3229#10.4.1",
			"spec_href": "http://tools.ietf.org/html/rfc3229#section-10.4.1"
		},
		{
			"code": "308",
			"phrase": "Permanent Redirect",
			"description": "\"The target resource has been assigned a new permanent URI and any future references to this resource SHOULD use one of the returned URIs. [...] This status code is similar to 301 Moved Permanently (Section 7.3.2 of rfc7231), except that it does not allow rewriting the request method from POST to GET.\"",
			"spec_title": "RFC7238",
			"spec_href": "http://tools.ietf.org/html/rfc7238"
		},
		{
			"code": "422",
			"phrase": "Unprocessable Entity",
			"description": "\"means the server understands the content type of the request entity (hence a 415(Unsupported Media Type) status code is inappropriate), and the syntax of the request entity is correct (thus a 400 (Bad Request) status code is inappropriate) but was unable to process the contained instructions.\"",
			"spec_title": "RFC5218#10.3",
			"spec_href": "http://tools.ietf.org/html/rfc2518#section-10.3"
		},
		{
			"code": "423",
			"phrase": "Locked",
			"description": "\"means the source or destination resource of a method is locked.\"",
			"spec_title": "RFC5218#10.4",
			"spec_href": "http://tools.ietf.org/html/rfc2518#section-10.4"
		},
		{
			"code": "424",
			"phrase": "Failed Dependency",
			"description": "\"means that the method could not be performed on the resource because the requested action depended on another action and that action failed.\"",
			"spec_title": "RFC5218#10.5",
			"spec_href": "http://tools.ietf.org/html/rfc2518#section-10.5"
		},
		{
			"code": "428",
			"phrase": "Precondition Required",
			"description": "\"indicates that the origin server requires the request to be conditional.\"",
			"spec_title": "RFC6585#3",
			"spec_href": "http://tools.ietf.org/html/rfc6585#section-3"
		},
		{
			"code": "429",
			"phrase": "Too Many Requests",
			"description": "\"indicates that the user has sent too many requests in a given amount of time (\"rate limiting\").\"",
			"spec_title": "RFC6585#4",
			"spec_href": "http://tools.ietf.org/html/rfc6585#section-4"
		},
		{
			"code": "431",
			"phrase": "Request Header Fields Too Large",
			"description": "\"indicates that the server is unwilling to process the request because its header fields are too large.\"",
			"spec_title": "RFC6585#5",
			"spec_href": "http://tools.ietf.org/html/rfc6585#section-5"
		},
		{
			"code": "451",
			"phrase": "Unavailable For Legal Reasons",
			"description": "\"This status code indicates that the server is denying access to the resource in response to a legal demand.\"",
			"spec_title": "draft-tbray-http-legally-restricted-status",
			"spec_href": "http://tools.ietf.org/html/draft-tbray-http-legally-restricted-status"
		},
		{
			"code": "506",
			"phrase": "Variant Also Negotiates",
			"description": "\"indicates that the server has an internal configuration error: the chosen variant resource is configured to engage in transparent content negotiation itself, and is therefore not a proper end point in the negotiation process.\"",
			"spec_title": "RFC2295#8.1",
			"spec_href": "http://tools.ietf.org/html/rfc2295#section-8.1"
		},
		{
			"code": "507",
			"phrase": "Insufficient Storage",
			"description": "\"means the method could not be performed on the resource because the server is unable to store the representation needed to successfully complete the request.\"",
			"spec_title": "RFC5218#10.6",
			"spec_href": "http://tools.ietf.org/html/rfc2518#section-10.6"
		},
		{
			"code": "511",
			"phrase": "Network Authentication Required",
			"description": "\"indicates that the client needs to authenticate to gain network access.\"",
			"spec_title": "RFC6585#6",
			"spec_href": "http://tools.ietf.org/html/rfc6585#section-6"
		},
		{
			"code": "7xx",
			"phrase": "**Developer Error**",
			"description": "[err](http://www.urbandictionary.com/define.php?term=err)",
			"spec_title": "7xx-rfc",
			"spec_href": "http://documentup.com/joho/7XX-rfc"
		}
	]

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [
		{
			"method": "CONNECT",
			"description": "\"requests that the recipient establish a tunnel to the destination origin server identified by the request-target and, if successful, thereafter restrict its behavior to blind forwarding of packets, in both directions, until the connection is closed.\"",
			"safe": true,
			"idempotent": true,
			"cacheable": false,
			"spec_title": "RFC7231#4.3.6",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.6"
		},
		{
			"method": "DELETE",
			"description": "\"requests that the origin server remove the association between the target resource and its current functionality.\"",
			"safe": false,
			"idempotent": true,
			"cacheable": false,
			"spec_title": "RFC7231#4.3.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.5"
		},
		{
			"method": "GET",
			"description": "\"requests transfer of a current selected representation for the target resource.\"",
			"safe": true,
			"idempotent": true,
			"cacheable": true,
			"spec_title": "RFC7231#4.3.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.1"
		},
		{
			"method": "HEAD",
			"description": "\"is identical to GET except that the server MUST NOT send a message body in the response (i.e., the response terminates at the end of the header block).\"",
			"safe": true,
			"idempotent": true,
			"cacheable": true,
			"spec_title": "RFC7231#4.3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.2"
		},
		{
			"method": "OPTIONS",
			"description": "\"requests information about the communication options available on the request/response chain identified by the effective request URI.\"",
			"safe": true,
			"idempotent": true,
			"cacheable": false,
			"spec_title": "RFC7231#4.3.7",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.7"
		},
		{
			"method": "POST",
			"description": "\"requests that the target resource process the representation enclosed in the request according to the resource's own specific semantics.\"",
			"safe": false,
			"idempotent": false,
			"cacheable": false,
			"spec_title": "RFC7231#4.3.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.3"
		},
		{
			"method": "PUT",
			"description": "\"requests that the state of the target resource be created or replaced with the state defined by the representation enclosed in the request message payload.\"",
			"safe": false,
			"idempotent": true,
			"cacheable": false,
			"spec_title": "RFC7231#4.3.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.4"
		},
		{
			"method": "TRACE",
			"description": "\"is used to invoke a remote, application-layer loopback of the request message.\"",
			"safe": true,
			"idempotent": true,
			"cacheable": false,
			"spec_title": "RFC7231#4.3.8",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.8"
		},
		{
			"method": "ACL",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3744#8.1",
			"spec_href": "http://tools.ietf.org/html/rfc3744#section-8.1"
		},
		{
			"method": "BASELINE-CONTROL",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#12.6",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-12.6"
		},
		{
			"method": "BIND",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC5842#4",
			"spec_href": "http://tools.ietf.org/html/rfc5842#section-4"
		},
		{
			"method": "CHECKIN",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#4.4",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-4.4"
		},
		{
			"method": "CHECKOUT",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#4.3",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-4.3"
		},
		{
			"method": "COPY",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4918#9.8",
			"spec_href": "http://tools.ietf.org/html/rfc4918#section-9.8"
		},
		{
			"method": "LABEL",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#8.2",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-8.2"
		},
		{
			"method": "LINK",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC2068#19.6.1.2",
			"spec_href": "http://tools.ietf.org/html/rfc2068#section-19.6.1.2"
		},
		{
			"method": "LOCK",
			"description": "",
			"safe": false,
			"idempotent": false,
			"cacheable": "",
			"spec_title": "RFC4918#9.10",
			"spec_href": "http://tools.ietf.org/html/rfc4918#section-9.10"
		},
		{
			"method": "MERGE",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#11.2",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-11.2"
		},
		{
			"method": "MKACTIVITY",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#13.5",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-13.5"
		},
		{
			"method": "MKCALENDAR",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4791#5.3.1",
			"spec_href": "http://tools.ietf.org/html/rfc4791#section-5.3.1"
		},
		{
			"method": "MKCOL",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4918#9.3",
			"spec_href": "http://tools.ietf.org/html/rfc4918#section-9.3"
		},
		{
			"method": "MKREDIRECTREF",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4437#6",
			"spec_href": "http://tools.ietf.org/html/rfc4437#section-6"
		},
		{
			"method": "MKWORKSPACE",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#6.3",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-6.3"
		},
		{
			"method": "MOVE",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4918#9.9",
			"spec_href": "http://tools.ietf.org/html/rfc4918#section-9.9"
		},
		{
			"method": "ORDERPATCH",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3648#7",
			"spec_href": "http://tools.ietf.org/html/rfc3648#section-7"
		},
		{
			"method": "PATCH",
			"description": "\"requests that a set of changes described in the request entity be applied to the resource identified by the Request-URI.\"",
			"safe": false,
			"idempotent": false,
			"cacheable": false,
			"spec_title": "RFC5789",
			"spec_href": "http://tools.ietf.org/html/rfc5789#section-2"
		},
		{
			"method": "PROPFIND",
			"description": "",
			"safe": true,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4918#9.1",
			"spec_href": "http://tools.ietf.org/html/rfc4918#section-9.1"
		},
		{
			"method": "PROPPATCH",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4918#9.2",
			"spec_href": "http://tools.ietf.org/html/rfc4918#section-9.2"
		},
		{
			"method": "REBIND",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC5842#6",
			"spec_href": "http://tools.ietf.org/html/rfc5842#section-6"
		},
		{
			"method": "REPORT",
			"description": "",
			"safe": true,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#3.6",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-3.6"
		},
		{
			"method": "SEARCH",
			"description": "",
			"safe": true,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC5323#2",
			"spec_href": "http://tools.ietf.org/html/rfc5323#section-2"
		},
		{
			"method": "UNBIND",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC5842#5",
			"spec_href": "http://tools.ietf.org/html/rfc5842#section-5"
		},
		{
			"method": "UNCHECKOUT",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#4.5",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-4.5"
		},
		{
			"method": "UNLINK",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC2068#19.6.1.3",
			"spec_href": "http://tools.ietf.org/html/rfc2068#section-19.6.1.3"
		},
		{
			"method": "UNLOCK",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4918#9.11",
			"spec_href": "http://tools.ietf.org/html/rfc4918#section-9.11"
		},
		{
			"method": "UPDATE",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#7.1",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-7.1"
		},
		{
			"method": "UPDATEREDIRECTREF",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4437#7",
			"spec_href": "http://tools.ietf.org/html/rfc4437#section-7"
		},
		{
			"method": "VERSION-CONTROL",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#3.5",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-3.5"
		}
	]

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [
		{
			"header": "Content-Encoding",
			"description": "\"indicates what content codings have been applied to the representation, beyond those inherent in the media type, and thus what decoding mechanisms have to be applied in order to obtain data in the media type referenced by the Content-Type header field.\"",
			"spec_title": "RFC7231#3.1.2.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-3.1.2.2"
		},
		{
			"header": "Content-Language",
			"description": "\"describes the natural language(s) of the intended audience for the representation.\"",
			"spec_title": "RFC7231#3.1.3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-3.1.3.2"
		},
		{
			"header": "Content-Location",
			"description": "\"references a URI that can be used as an identifier for a specific resource corresponding to the representation in this message's payload.\"",
			"spec_title": "RFC7231#3.1.4.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-3.1.4.2"
		},
		{
			"header": "Content-Type",
			"description": "\"indicates the media type of the associated representation: either the representation enclosed in the message payload or the selected representation, as determined by the message semantics.\"",
			"spec_title": "RFC7231#3.1.1.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-3.1.1.5"
		},
		{
			"header": "Content-Length",
			"description": "\"can provide the anticipated size, as a decimal number of octets, for a potential payload body.\"",
			"spec_title": "RFC7230#3.3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7230#section-3.3.2"
		},
		{
			"header": "Content-Range",
			"description": "\"is sent in a single part 206 (Partial Content) response to indicate the partial range of the selected representation enclosed as the message payload, sent in each part of a multipart 206 response to indicate the range enclosed within each body part, and sent in 416 (Range Not Satisfiable) responses to provide information about the selected representation.\"",
			"spec_title": "RFC7233#4.2",
			"spec_href": "http://tools.ietf.org/html/rfc7233#section-4.2"
		},
		{
			"header": "Transfer-Encoding",
			"description": "\"lists the transfer coding names corresponding to the sequence of transfer codings that have been (or will be) applied to the payload body in order to form the message body.\"",
			"spec_title": "RFC7230#3.3.1",
			"spec_href": "http://tools.ietf.org/html/rfc7230#section-3.3.1"
		},
		{
			"header": "Cache-Control",
			"description": "\"is used to specify directives for caches along the request/response chain.\"",
			"spec_title": "RFC7234#7.2",
			"spec_href": "http://tools.ietf.org/html/rfc7234#section-7.2"
		},
		{
			"header": "Expect",
			"description": "\"is used to indicate that particular server behaviors are required by the client.\"",
			"spec_title": "RFC7231#5.1.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.1.1"
		},
		{
			"header": "Host",
			"description": "\"provides the host and port information from the target URI, enabling the origin server to distinguish among resources while servicing requests for multiple host names on a single IP address.\"",
			"spec_title": "RFC7230#5.4",
			"spec_href": "http://tools.ietf.org/html/rfc7230#section-5.4"
		},
		{
			"header": "Max-Forwards",
			"description": "\"provides a mechanism with the TRACE and OPTIONS methods to limit the number of times that the request is forwarded by proxies.\"",
			"spec_title": "RFC7231#5.1.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.1.2"
		},
		{
			"header": "Pragma",
			"description": "\"allows backwards compatibility with HTTP/1.0 caches, so that clients can specify a \"no-cache\" request that they will understand (as Cache-Control was not defined until HTTP/1.1).\"",
			"spec_title": "RFC7234#7.4",
			"spec_href": "http://tools.ietf.org/html/rfc7234#section-7.4"
		},
		{
			"header": "Range",
			"description": "\"modifies the method semantics to request transfer of only one or more subranges of the selected representation data, rather than the entire selected representation data.\"",
			"spec_title": "RFC7233#3.1",
			"spec_href": "http://tools.ietf.org/html/rfc7233#section-3.1"
		},
		{
			"header": "TE",
			"description": "\"indicates what transfer codings, besides chunked, the client is willing to accept in response, and whether or not the client is willing to accept trailer fields in a chunked transfer coding.\"",
			"spec_title": "RFC7230#4.3",
			"spec_href": "http://tools.ietf.org/html/rfc7230#section-4.3"
		},
		{
			"header": "If-Match",
			"description": "\"can be used to make a request method conditional on the current existence or value of an entity-tag for one or more representations of the target resource.\"",
			"spec_title": "RFC7232#3.1",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-3.1"
		},
		{
			"header": "If-Modified-Since",
			"description": "\"can be used with GET or HEAD to make the method conditional by modification date: if the selected representation has not been modified since the time specified in this field, then do not perform the request method; instead, respond as detailed below.\"",
			"spec_title": "RFC7232#3.3",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-3.3"
		},
		{
			"header": "If-None-Match",
			"description": "\"can be used to make a request method conditional on not matching any of the current entity-tag values for representations of the target resource.\"",
			"spec_title": "RFC7232#3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-3.2"
		},
		{
			"header": "If-Range",
			"description": "\"Informally, its meaning is: if the representation is unchanged, send me the part(s) that I am requesting in Range; otherwise, send me the entire representation.\"",
			"spec_title": "RFC7233#3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7233#section-3.2"
		},
		{
			"header": "If-Unmodified-Since",
			"description": "\"can be used to make a request method conditional by modification date: if the selected representation has been modified since the time specified in this field, then the server MUST NOT perform the requested operation and MUST instead respond with the 412 (Precondition Failed) status code.\"",
			"spec_title": "RFC7232#3.4",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-3.4"
		},
		{
			"header": "Accept",
			"description": "\"can be used to specify certain media types which are acceptable for the response.\"",
			"spec_title": "RFC7231#5.3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.3.2"
		},
		{
			"header": "Accept-Charset",
			"description": "\"can be sent by a user agent to indicate what charsets are acceptable in textual response content.\"",
			"spec_title": "RFC7231#5.3.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.3.3"
		},
		{
			"header": "Accept-Encoding",
			"description": "\"can be used by user agents to indicate what response content-codings are acceptable in the response.\"",
			"spec_title": "RFC7231#5.3.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.3.4"
		},
		{
			"header": "Accept-Language",
			"description": "\"can be used by user agents to indicate the set of natural languages that are preferred in the response.\"",
			"spec_title": "RFC7231#5.3.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.3.5"
		},
		{
			"header": "Authorization",
			"description": "\"allows a user agent to authenticate itself with a server -- usually, but not necessarily, after receiving a 401 (Unauthorized) response.\"",
			"spec_title": "RFC7235#4.1",
			"spec_href": "http://tools.ietf.org/html/rfc7235#section-4.1"
		},
		{
			"header": "Proxy-Authorization",
			"description": "\"allows the client to identify itself (or its user) to a proxy that requires authentication.\"",
			"spec_title": "RFC7235#4.3",
			"spec_href": "http://tools.ietf.org/html/rfc7235#section-4.3"
		},
		{
			"header": "DNT",
			"description": "\"defined as the means for expressing a user's tracking preference via HTTP.\"",
			"spec_title": "Tracking Preference Expression (DNT)",
			"spec_href": "http://www.w3.org/TR/tracking-dnt/#dnt-header-field"
		},
		{
			"header": "From",
			"description": "\"contains an Internet email address for a human user who controls the requesting user agent.\"",
			"spec_title": "RFC7231#5.5.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.5.1"
		},
		{
			"header": "Referer",
			"description": "\"allows the user agent to specify a URI reference for the resource from which the target URI was obtained (i.e., the \"referrer\", though the field name is misspelled).\"",
			"spec_title": "RFC7231#5.5.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.5.2"
		},
		{
			"header": "User-Agent",
			"description": "\"contains information about the user agent originating the request, which is often used by servers to help identify the scope of reported interoperability problems, to work around or tailor responses to avoid particular user agent limitations, and for analytics regarding browser or operating system use.\"",
			"spec_title": "RFC7231#5.5.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.5.3"
		},
		{
			"header": "Age",
			"description": "\"conveys the sender's estimate of the amount of time since the response was generated or successfully validated at the origin server.\"",
			"spec_title": "RFC7234#5.1",
			"spec_href": "http://tools.ietf.org/html/rfc7234#section-5.1"
		},
		{
			"header": "Cache-Control",
			"description": "\"is used to specify directives for caches along the request/response chain.\"",
			"spec_title": "RFC7234#7.2",
			"spec_href": "http://tools.ietf.org/html/rfc7234#section-7.2"
		},
		{
			"header": "Expires",
			"description": "\"gives the date/time after which the response is considered stale.\"",
			"spec_title": "RFC7234#7.3",
			"spec_href": "http://tools.ietf.org/html/rfc7234#section-7.3"
		},
		{
			"header": "Date",
			"description": "\"represents the date and time at which the message was originated\"",
			"spec_title": "RFC7231#7.1.1.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-7.1.1.2"
		},
		{
			"header": "Location",
			"description": "\"is used in some responses to refer to a specific resource in relation to the response.\"",
			"spec_title": "RFC7231#7.1.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-7.1.2"
		},
		{
			"header": "Retry-After",
			"description": "\"indicates how long the user agent ought to wait before making a follow-up request.\"",
			"spec_title": "RFC7231#7.1.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-7.1.3"
		},
		{
			"header": "Tk",
			"description": "\"defined as an OPTIONAL means for indicating the tracking status that applied to the corresponding request and as a REQUIRED means for indicating that a state-changing request has resulted in an interactive change to the tracking status. \"",
			"spec_title": "Tracking Preference Expression (DNT)",
			"spec_href": "http://www.w3.org/TR/tracking-dnt/#response-header-field"
		},
		{
			"header": "Vary",
			"description": "\"describes what parts of a request message, aside from the method and request target, might influence the origin server's process for selecting and representing the response.\"",
			"spec_title": "RFC7231#7.1.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-7.1.4"
		},
		{
			"header": "Warning",
			"description": "\"is used to carry additional information about the status or transformation of a message that might not be reflected in the message.\"",
			"spec_title": "RFC7234#7.6",
			"spec_href": "http://tools.ietf.org/html/rfc7234#section-7.6"
		},
		{
			"header": "ETag",
			"description": "\"provides the current entity-tag for the selected representation, as determined at the conclusion of handling the request.\"",
			"spec_title": "RFC7232#2.3",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-2.3"
		},
		{
			"header": "Last-Modified",
			"description": "\"provides a timestamp indicating the date and time at which the origin server believes the selected representation was last modified, as determined at the conclusion of handling the request.\"",
			"spec_title": "RFC7232#2.2",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-2.2"
		},
		{
			"header": "WWW-Authenticate",
			"description": "\"consists of at least one challenge that indicates the authentication scheme(s) and parameters applicable to the effective request URI.\"",
			"spec_title": "RFC7235#4.4",
			"spec_href": "http://tools.ietf.org/html/rfc7235#section-4.4"
		},
		{
			"header": "Proxy-Authenticate",
			"description": "\"consists of at least one challenge that indicates the authentication scheme(s) and parameters applicable to the proxy for this effective request URI.\"",
			"spec_title": "RFC7235#4.2",
			"spec_href": "http://tools.ietf.org/html/rfc7235#section-4.2"
		},
		{
			"header": "Accept-Ranges",
			"description": "\"allows a server to indicate that it supports range requests for the target resource.\"",
			"spec_title": "RFC7233#2.3",
			"spec_href": "http://tools.ietf.org/html/rfc7233#section-2.3"
		},
		{
			"header": "Allow",
			"description": "\"lists the set of methods advertised as supported by the target resource.\"",
			"spec_title": "RFC7231#7.4.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-7.4.1"
		},
		{
			"header": "Server",
			"description": "\"contains information about the software used by the origin server to handle the request, which is often used by clients to help identify the scope of reported interoperability problems, to work around or tailor requests to avoid particular server limitations, and for analytics regarding server or operating system use.\"",
			"spec_title": "RFC7231#7.4.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-7.4.2"
		},
		{
			"header": "Accept-Patch",
			"description": "\"used to specify the patch document formats accepted by the server.\"",
			"spec_title": "RFC5789#3.1",
			"spec_href": "http://tools.ietf.org/html/rfc5789#section-3.1"
		},
		{
			"header": "Accept-Post",
			"description": "\"indicates server support for specific media types for entity bodies in HTTP POST requests.\"",
			"spec_title": "draft-wilde-accept-post",
			"spec_href": "http://tools.ietf.org/html/draft-wilde-accept-post"
		},
		{
			"header": "Access-Control-Allow-Credentials",
			"description": "\"indicates whether the response to request can be exposed when the omit credentials flag is unset\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-allow-credentials-response-header"
		},
		{
			"header": "Access-Control-Allow-Headers",
			"description": "\"indicates, as part of the response to a preflight request, which header field names can be used during the actual request\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-allow-headers-response-header"
		},
		{
			"header": "Access-Control-Allow-Methods",
			"description": "\"indicates, as part of the response to a preflight request, which methods can be used during the actual request\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-allow-methods-response-header"
		},
		{
			"header": "Access-Control-Allow-Origin",
			"description": "\"indicates whether a resource can be shared\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-allow-origin-response-header"
		},
		{
			"header": "Access-Control-Expose-Headers",
			"description": "\"indicates which headers are safe to expose to the API of a CORS API specification\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-expose-headers-response-header"
		},
		{
			"header": "Access-Control-Max-Age",
			"description": "\"indicates how long the results of a preflight request can be cached in a preflight result cache\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-max-age-response-header"
		},
		{
			"header": "Access-Control-Request-Headers",
			"description": "\"indicates which headers will be used in the actual request as part of the preflight request\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-request-headers-request-header"
		},
		{
			"header": "Access-Control-Request-Method",
			"description": "\"indicates which method will be used in the actual request as part of the preflight request\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-request-method-request-header"
		},
		{
			"header": "Content-Disposition",
			"description": "\"standard\"",
			"spec_title": "RFC6266",
			"spec_href": "http://tools.ietf.org/html/rfc6266"
		},
		{
			"header": "Content-Security-Policy",
			"description": "\"is the preferred mechanism for delivering a CSP policy\"",
			"spec_title": "CSP",
			"spec_href": "http://www.w3.org/TR/CSP/#content-security-policy-header-field"
		},
		{
			"header": "Content-Security-Policy-Report-Only",
			"description": "\"lets servers experiment with policies by monitoring (rather than enforcing) a policy\"",
			"spec_title": "CSP",
			"spec_href": "http://www.w3.org/TR/CSP/#content-security-policy-report-only-header-field"
		},
		{
			"header": "Cookie",
			"description": "\"standard\"",
			"spec_title": "RFC6265",
			"spec_href": "http://tools.ietf.org/html/rfc6265"
		},
		{
			"header": "Forwarded",
			"description": "\"standard\"",
			"spec_title": "RFC7239",
			"spec_href": "http://tools.ietf.org/html/rfc7239"
		},
		{
			"header": "Link",
			"description": "\"provides a means for serialising one or more links in HTTP headers.\"",
			"spec_title": "RFC5988#5",
			"spec_href": "http://tools.ietf.org/html/rfc5988#section-5"
		},
		{
			"header": "Origin",
			"description": "\"standard\"",
			"spec_title": "RFC6454",
			"spec_href": "http://tools.ietf.org/html/rfc6454"
		},
		{
			"header": "Prefer",
			"description": "\"is used to indicate that particular server behaviors are preferred by the client, but not required for successful completion of the request.\"",
			"spec_title": "draft-snell-http-prefer#2",
			"spec_href": "http://tools.ietf.org/html/draft-snell-http-prefer#section-2"
		},
		{
			"header": "Preference-Applied",
			"description": "\"MAY be included within a response message as an indication as to which Prefer tokens were honored by the server and applied to the processing of a request.\"",
			"spec_title": "draft-snell-http-prefer#3",
			"spec_href": "http://tools.ietf.org/html/draft-snell-http-prefer#section-3"
		},
		{
			"header": "Set-Cookie",
			"description": "\"standard\"",
			"spec_title": "RFC6265",
			"spec_href": "http://tools.ietf.org/html/rfc6265"
		},
		{
			"header": "Strict-Transport-Security",
			"description": "\"standard\"",
			"spec_title": "RFC6797",
			"spec_href": "http://tools.ietf.org/html/rfc6797"
		},
		{
			"header": "Via",
			"description": "\"\"",
			"spec_title": "RFC7230#5.7.1",
			"spec_href": "http://tools.ietf.org/html/rfc7230#section-5.7.1"
		},
		{
			"header": "A-IM",
			"description": "\"\"",
			"spec_title": "RFC3229#10.5.3",
			"spec_href": "http://tools.ietf.org/html/rfc3229#section-10.5.3"
		},
		{
			"header": "Accept-Features",
			"description": "\"can be used by a user agent to give information about the presence or absence of certain features in the feature set of the current request.\"",
			"spec_title": "RFC2295#8.2",
			"spec_href": "http://tools.ietf.org/html/rfc2295#section-8.2"
		},
		{
			"header": "Alt-Svc",
			"description": "\"is advertising the availability of alternate services to HTTP/1.1 and HTTP/2.0 clients by adding an Alt-Svc header field to responses.\"",
			"spec_title": "draft-nottingham-httpbis-alt-svc",
			"spec_href": "http://tools.ietf.org/html/draft-nottingham-httpbis-alt-svc"
		},
		{
			"header": "Alternates",
			"description": "\"is used to convey the list of variants bound to a negotiable resource.\"",
			"spec_title": "RFC2295#8.3",
			"spec_href": "http://tools.ietf.org/html/rfc2295#section-8.3"
		},
		{
			"header": "Apply-To-Redirect-Ref",
			"description": "\"\"",
			"spec_title": "RFC4437",
			"spec_href": "http://tools.ietf.org/html/rfc4437"
		},
		{
			"header": "CH",
			"description": "\"describes an example list of client preferences that the server can use to adapt and optimize the resource to satisfy a given request.\"",
			"spec_title": "draft-grigorik-http-client-hints",
			"spec_href": "http://tools.ietf.org/html/draft-grigorik-http-client-hints"
		},
		{
			"header": "Content-Base",
			"description": "\"obsoleted\"",
			"spec_title": "RFC2068",
			"spec_href": "http://tools.ietf.org/html/rfc2068"
		},
		{
			"header": "Cookie2",
			"description": "\"obsoleted\"",
			"spec_title": "RFC2965",
			"spec_href": "http://tools.ietf.org/html/rfc2965"
		},
		{
			"header": "DASL",
			"description": "\"standard\"",
			"spec_title": "RFC5323",
			"spec_href": "http://tools.ietf.org/html/rfc5323"
		},
		{
			"header": "DAV",
			"description": "\"standard\"",
			"spec_title": "RFC4918",
			"spec_href": "http://tools.ietf.org/html/rfc4918"
		},
		{
			"header": "Delta-Base",
			"description": "\"\"",
			"spec_title": "RFC3229#10.5.1",
			"spec_href": "http://tools.ietf.org/html/rfc3229#section-10.5.1"
		},
		{
			"header": "Depth",
			"description": "\"standard\"",
			"spec_title": "RFC4918",
			"spec_href": "http://tools.ietf.org/html/rfc4918"
		},
		{
			"header": "Destination",
			"description": "\"standard\"",
			"spec_title": "RFC4918",
			"spec_href": "http://tools.ietf.org/html/rfc4918"
		},
		{
			"header": "IM",
			"description": "\"\"",
			"spec_title": "RFC3229#10.5.2",
			"spec_href": "http://tools.ietf.org/html/rfc3229#section-10.5.2"
		},
		{
			"header": "If",
			"description": "\"standard\"",
			"spec_title": "RFC4918",
			"spec_href": "http://tools.ietf.org/html/rfc4918"
		},
		{
			"header": "If-Schedule-Tag-Match",
			"description": "\"standard\"",
			"spec_title": "RFC6638",
			"spec_href": "http://tools.ietf.org/html/rfc6638"
		},
		{
			"header": "Last-Event-ID",
			"description": "\"The value of the event source's last event ID string, encoded as UTF-8.\"",
			"spec_title": "Server-Sent Events",
			"spec_href": "http://www.w3.org/TR/eventsource/#last-event-id"
		},
		{
			"header": "Link-Template",
			"description": "\"provides a means for serialising one or more links into HTTP headers.\"",
			"spec_title": "draft-nottingham-link-template",
			"spec_href": "http://tools.ietf.org/html/draft-nottingham-link-template"
		},
		{
			"header": "Lock-Token",
			"description": "\"standard\"",
			"spec_title": "RFC4918",
			"spec_href": "http://tools.ietf.org/html/rfc4918"
		},
		{
			"header": "Negotiate",
			"description": "\"can contain directives for any content negotiation process initiated by the request.\"",
			"spec_title": "RFC2295#8.4",
			"spec_href": "http://tools.ietf.org/html/rfc2295#section-8.4"
		},
		{
			"header": "Nice",
			"description": "\"indicates that a request is less important than a request that doesn't bear this header.\"",
			"spec_title": "draft-thomson-http-nice",
			"spec_href": "http://tools.ietf.org/html/draft-thomson-http-nice"
		},
		{
			"header": "Overwrite",
			"description": "\"standard\"",
			"spec_title": "RFC4918",
			"spec_href": "http://tools.ietf.org/html/rfc4918"
		},
		{
			"header": "Redirect-Ref",
			"description": "\"\"",
			"spec_title": "RFC4437",
			"spec_href": "http://tools.ietf.org/html/rfc4437"
		},
		{
			"header": "Schedule-Reply",
			"description": "\"standard\"",
			"spec_title": "RFC6638",
			"spec_href": "http://tools.ietf.org/html/rfc6638"
		},
		{
			"header": "Schedule-Tag",
			"description": "\"standard\"",
			"spec_title": "RFC6638",
			"spec_href": "http://tools.ietf.org/html/rfc6638"
		},
		{
			"header": "Sec-WebSocket-Accept",
			"description": "\"standard\"",
			"spec_title": "RFC6455",
			"spec_href": "http://tools.ietf.org/html/rfc6455"
		},
		{
			"header": "Sec-WebSocket-Extensions",
			"description": "\"standard\"",
			"spec_title": "RFC6455",
			"spec_href": "http://tools.ietf.org/html/rfc6455"
		},
		{
			"header": "Sec-WebSocket-Key",
			"description": "\"standard\"",
			"spec_title": "RFC6455",
			"spec_href": "http://tools.ietf.org/html/rfc6455"
		},
		{
			"header": "Sec-WebSocket-Protocol",
			"description": "\"standard\"",
			"spec_title": "RFC6455",
			"spec_href": "http://tools.ietf.org/html/rfc6455"
		},
		{
			"header": "Sec-WebSocket-Version",
			"description": "\"standard\"",
			"spec_title": "RFC6455",
			"spec_href": "http://tools.ietf.org/html/rfc6455"
		},
		{
			"header": "Set-Cookie2",
			"description": "\"obsoleted\"",
			"spec_title": "RFC2965",
			"spec_href": "http://tools.ietf.org/html/rfc2965"
		},
		{
			"header": "SLUG",
			"description": "\"standard\"",
			"spec_title": "RFC5023",
			"spec_href": "http://tools.ietf.org/html/rfc5023"
		},
		{
			"header": "TCN",
			"description": "\"is used by a server to signal that the resource is transparently negotiated.\"",
			"spec_title": "RFC2295#8.5",
			"spec_href": "http://tools.ietf.org/html/rfc2295#section-8.5"
		},
		{
			"header": "Timeout",
			"description": "\"standard\"",
			"spec_title": "RFC4918",
			"spec_href": "http://tools.ietf.org/html/rfc4918"
		},
		{
			"header": "Variant-Vary",
			"description": "\"can be used in a choice response to record any vary information which applies to the variant data (the entity body combined with some of the entity headers) contained in the response, rather than to the response as a whole.\"",
			"spec_title": "RFC2295#8.6",
			"spec_href": "http://tools.ietf.org/html/rfc2295#section-8.6"
		},
		{
			"header": "X-Frame-Options",
			"description": "\"indicates a policy that specifies whether the browser should render the transmitted resource within a <frame> or an <iframe>. Servers can declare this policy in the header of their HTTP responses to prevent clickjacking attacks, which ensures that their content is not embedded into other pages or frames.\"",
			"spec_title": "RFC7034",
			"spec_href": "http://tools.ietf.org/html/rfc7034"
		}
	]

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [
		{
			"relation": "about",
			"description": "\"Refers to a resource that is the subject of the link's context.\"",
			"spec_title": "RFC6903",
			"spec_href": "http://tools.ietf.org/html/rfc6903"
		},
		{
			"relation": "alternate",
			"description": "\"Refers to a substitute for this context\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-alternate"
		},
		{
			"relation": "appendix",
			"description": "\"Refers to an appendix.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "archives",
			"description": "\"Refers to a collection of records, documents, or other materials of historical interest.\"",
			"spec_title": "HTML5linksWD",
			"spec_href": "http://www.w3.org/TR/2011/WD-html5-20110113/links.html#rel-archives"
		},
		{
			"relation": "author",
			"description": "\"Refers to the context's author.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-author"
		},
		{
			"relation": "bookmark",
			"description": "\"Gives a permanent link to use for bookmarking purposes.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-bookmark"
		},
		{
			"relation": "canonical",
			"description": "\"Designates the preferred version of a resource (the IRI and its contents).\"",
			"spec_title": "RFC6596",
			"spec_href": "http://tools.ietf.org/html/rfc6596"
		},
		{
			"relation": "chapter",
			"description": "\"Refers to a chapter in a collection of resources.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "collection",
			"description": "\"The target IRI points to a resource which represents the collection resource for the context IRI.\"",
			"spec_title": "RFC6573",
			"spec_href": "http://tools.ietf.org/html/rfc6573"
		},
		{
			"relation": "contents",
			"description": "\"Refers to a table of contents.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "copyright",
			"description": "\"Refers to a copyright statement that applies to the link's context.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "create-form",
			"description": "\"The target IRI points to a resource where a submission form can be obtained.\"",
			"spec_title": "RFC6861",
			"spec_href": "http://tools.ietf.org/html/rfc6861"
		},
		{
			"relation": "current",
			"description": "\"Refers to a resource containing the most recent item(s) in a collection of resources.\"",
			"spec_title": "RFC5005",
			"spec_href": "http://tools.ietf.org/html/rfc5005"
		},
		{
			"relation": "describedby",
			"description": "\"Refers to a resource providing information about the link's context.\"",
			"spec_title": "POWDER",
			"spec_href": "http://www.w3.org/TR/powder-dr/#assoc-linking"
		},
		{
			"relation": "describes",
			"description": "\"The relationship A 'describes' B asserts that resource A provides a description of resource B. There are no constraints on the format or representation of either A or B, neither are there any further constraints on either resource.\"",
			"spec_title": "RFC6892",
			"spec_href": "http://tools.ietf.org/html/rfc6892"
		},
		{
			"relation": "disclosure",
			"description": "\"Refers to a list of patent disclosures made with respect to material for which `disclosure` relation is specified.\"",
			"spec_title": "RFC6579",
			"spec_href": "http://tools.ietf.org/html/rfc6579"
		},
		{
			"relation": "duplicate",
			"description": "\"Refers to a resource whose available representations are byte-for-byte identical with the corresponding representations of the context IRI.\"",
			"spec_title": "RFC6249",
			"spec_href": "http://tools.ietf.org/html/rfc6249"
		},
		{
			"relation": "edit",
			"description": "\"Refers to a resource that can be used to edit the link's context.\"",
			"spec_title": "RFC5023",
			"spec_href": "http://tools.ietf.org/html/rfc5023"
		},
		{
			"relation": "edit-form",
			"description": "\"The target IRI points to a resource where a submission form for editing associated resource can be obtained.\"",
			"spec_title": "RFC6861",
			"spec_href": "http://tools.ietf.org/html/rfc6861"
		},
		{
			"relation": "edit-media",
			"description": "\"Refers to a resource that can be used to edit media associated with the link's context.\"",
			"spec_title": "RFC5023",
			"spec_href": "http://tools.ietf.org/html/rfc5023"
		},
		{
			"relation": "enclosure",
			"description": "\"Identifies a related resource that is potentially large and might require special handling.\"",
			"spec_title": "RFC4287",
			"spec_href": "http://tools.ietf.org/html/rfc4287"
		},
		{
			"relation": "first",
			"description": "\"An IRI that refers to the furthest preceding resource in a series of resources.\"",
			"spec_title": "RFC5988",
			"spec_href": "http://tools.ietf.org/html/rfc5988"
		},
		{
			"relation": "glossary",
			"description": "\"Refers to a glossary of terms.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "help",
			"description": "\"Refers to context-sensitive help.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-help"
		},
		{
			"relation": "hosts",
			"description": "\"Refers to a resource hosted by the server indicated by the link context.\"",
			"spec_title": "RFC6690",
			"spec_href": "http://tools.ietf.org/html/rfc6690"
		},
		{
			"relation": "hub",
			"description": "\"Refers to a hub that enables registration for notification of updates to the context.\"",
			"spec_title": "pubsubhubbub",
			"spec_href": "http://pubsubhubbub.googlecode.com"
		},
		{
			"relation": "icon",
			"description": "\"Refers to an icon representing the link's context.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-icon"
		},
		{
			"relation": "index",
			"description": "\"Refers to an index.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "item",
			"description": "\"The target IRI points to a resource that is a member of the collection represented by the context IRI.\"",
			"spec_title": "RFC6573",
			"spec_href": "http://tools.ietf.org/html/rfc6573"
		},
		{
			"relation": "last",
			"description": "\"An IRI that refers to the furthest following resource in a series of resources.\"",
			"spec_title": "RFC5988",
			"spec_href": "http://tools.ietf.org/html/rfc5988"
		},
		{
			"relation": "latest-version",
			"description": "\"Points to a resource containing the latest (e.g., current) version of the context.\"",
			"spec_title": "RFC5829",
			"spec_href": "http://tools.ietf.org/html/rfc5829"
		},
		{
			"relation": "license",
			"description": "\"Refers to a license associated with this context.\"",
			"spec_title": "RFC4946",
			"spec_href": "http://tools.ietf.org/html/rfc4946"
		},
		{
			"relation": "lrdd",
			"description": "\"Refers to further information about the link's context, expressed as a LRDD (Link-based Resource Descriptor Document) resource. See [RFC6415](http://tools.ietf.org/html/rfc6415) for information about processing this relation type in host-meta documents. When used elsewhere, it refers to additional links and other metadata. Multiple instances indicate additional LRDD resources. LRDD resources MUST have an \"application/xrd+xml\" representation, and MAY have others.\"",
			"spec_title": "RFC6415",
			"spec_href": "http://tools.ietf.org/html/rfc6415"
		},
		{
			"relation": "monitor",
			"description": "\"Refers to a resource that can be used to monitor changes in an HTTP resource.\"",
			"spec_title": "RFC5989",
			"spec_href": "http://tools.ietf.org/html/rfc5989"
		},
		{
			"relation": "monitor-group",
			"description": "\"Refers to a resource that can be used to monitor changes in a specified group of HTTP resources.\"",
			"spec_title": "RFC5989",
			"spec_href": "http://tools.ietf.org/html/rfc5989"
		},
		{
			"relation": "next",
			"description": "\"Indicates that the link's context is a part of a series, and that the next in the series is the link target.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-next"
		},
		{
			"relation": "next-archive",
			"description": "\"Refers to the immediately following archive resource.\"",
			"spec_title": "RFC5005",
			"spec_href": "http://tools.ietf.org/html/rfc5005"
		},
		{
			"relation": "nofollow",
			"description": "\"Indicates that the context’s original author or publisher does not endorse the link target.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-nofollow"
		},
		{
			"relation": "noreferrer",
			"description": "\"Indicates that no referrer information is to be leaked when following the link.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-noreferrer"
		},
		{
			"relation": "payment",
			"description": "\"Indicates a resource where payment is accepted.\"",
			"spec_title": "RFC5988",
			"spec_href": "http://tools.ietf.org/html/rfc5988"
		},
		{
			"relation": "predecessor-version",
			"description": "\"Points to a resource containing the predecessor version in the version history.\"",
			"spec_title": "RFC5829",
			"spec_href": "http://tools.ietf.org/html/rfc5829"
		},
		{
			"relation": "prefetch",
			"description": "\"Indicates that the link target should be preemptively cached.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-prefetch"
		},
		{
			"relation": "prev",
			"description": "\"Indicates that the link's context is a part of a series, and that the previous in the series is the link target.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-prev"
		},
		{
			"relation": "preview",
			"description": "\"Refers to a resource that provides a preview of the link's context.\"",
			"spec_title": "RFC6903",
			"spec_href": "http://tools.ietf.org/html/rfc6903"
		},
		{
			"relation": "previous",
			"description": "\"Refers to the previous resource in an ordered series of resources. Synonym for `prev`.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "prev-archive",
			"description": "\"Refers to the immediately preceding archive resource.\"",
			"spec_title": "RFC5005",
			"spec_href": "http://tools.ietf.org/html/rfc5005"
		},
		{
			"relation": "privacy-policy",
			"description": "\"Refers to a privacy policy associated with the link's context.\"",
			"spec_title": "RFC6903",
			"spec_href": "http://tools.ietf.org/html/rfc6903"
		},
		{
			"relation": "profile",
			"description": "Identifying that a resource representation conforms to a certain profile, without affecting the non-profile semantics of the resource representation",
			"spec_title": "RFC6906",
			"spec_href": "http://tools.ietf.org/html/rfc6906"
		},
		{
			"relation": "related",
			"description": "\"Identifies a related resource.\"",
			"spec_title": "RFC4287",
			"spec_href": "http://tools.ietf.org/html/rfc4287"
		},
		{
			"relation": "replies",
			"description": "\"Identifies a resource that is a reply to the context of the link.\"",
			"spec_title": "RFC4685",
			"spec_href": "http://tools.ietf.org/html/rfc4685"
		},
		{
			"relation": "search",
			"description": "\"Refers to a resource that can be used to search through the link's context and related resources.\"",
			"spec_title": "OpenSearch",
			"spec_href": "http://www.opensearch.org/Specifications/OpenSearch/1.1"
		},
		{
			"relation": "section",
			"description": "\"Refers to a section in a collection of resources.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "self",
			"description": "\"Conveys an identifier for the link's context.\"",
			"spec_title": "RFC4287",
			"spec_href": "http://tools.ietf.org/html/rfc4287"
		},
		{
			"relation": "service",
			"description": "\"Indicates a URI that can be used to retrieve a service document.\"",
			"spec_title": "RFC5023",
			"spec_href": "http://tools.ietf.org/html/rfc5023"
		},
		{
			"relation": "start",
			"description": "\"Refers to the first resource in a collection of resources.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "stylesheet",
			"description": "\"Refers to a stylesheet.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-stylesheet"
		},
		{
			"relation": "subsection",
			"description": "\"Refers to a resource serving as a subsection in a collection of resources.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "successor-version",
			"description": "\"Points to a resource containing the successor version in the version history.\"",
			"spec_title": "RFC5829",
			"spec_href": "http://tools.ietf.org/html/rfc5829"
		},
		{
			"relation": "tag",
			"description": "\"Gives a tag (identified by the given address) that applies to the current document.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-tag"
		},
		{
			"relation": "terms-of-service",
			"description": "\"Refers to the terms of service associated with the link's context.\"",
			"spec_title": "RFC6903",
			"spec_href": "http://tools.ietf.org/html/rfc6903"
		},
		{
			"relation": "type",
			"description": "\"Refers to a resource identifying the abstract semantic type of which the link's context is considered to be an instance.\"",
			"spec_title": "RFC6903",
			"spec_href": "http://tools.ietf.org/html/rfc6903"
		},
		{
			"relation": "up",
			"description": "\"Refers to a parent document in a hierarchy of documents.\"",
			"spec_title": "RFC5988",
			"spec_href": "http://tools.ietf.org/html/rfc5988"
		},
		{
			"relation": "version-history",
			"description": "\"Points to a resource containing the version history for the context.\"",
			"spec_title": "RFC5829",
			"spec_href": "http://tools.ietf.org/html/rfc5829"
		},
		{
			"relation": "via",
			"description": "\"Identifies a resource that is the source of the information in the link's context.\"",
			"spec_title": "RFC4287",
			"spec_href": "http://tools.ietf.org/html/rfc4287"
		},
		{
			"relation": "working-copy",
			"description": "\"Points to a working copy for this resource.\"",
			"spec_title": "RFC5829",
			"spec_href": "http://tools.ietf.org/html/rfc5829"
		},
		{
			"relation": "working-copy-of",
			"description": "\"Points to the versioned resource from which this working copy was obtained.\"",
			"spec_title": "RFC5829",
			"spec_href": "http://tools.ietf.org/html/rfc5829"
		}
	]

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * isArray
	 */

	var isArray = Array.isArray;

	/**
	 * toString
	 */

	var str = Object.prototype.toString;

	/**
	 * Whether or not the given `val`
	 * is an array.
	 *
	 * example:
	 *
	 *        isArray([]);
	 *        // > true
	 *        isArray(arguments);
	 *        // > false
	 *        isArray('');
	 *        // > false
	 *
	 * @param {mixed} val
	 * @return {bool}
	 */

	module.exports = isArray || function (val) {
	  return !! val && '[object Array]' == str.call(val);
	};


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	exports.read = function(buffer, offset, isLE, mLen, nBytes) {
	  var e, m,
	      eLen = nBytes * 8 - mLen - 1,
	      eMax = (1 << eLen) - 1,
	      eBias = eMax >> 1,
	      nBits = -7,
	      i = isLE ? (nBytes - 1) : 0,
	      d = isLE ? -1 : 1,
	      s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity);
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
	};

	exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c,
	      eLen = nBytes * 8 - mLen - 1,
	      eMax = (1 << eLen) - 1,
	      eBias = eMax >> 1,
	      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
	      i = isLE ? 0 : (nBytes - 1),
	      d = isLE ? 1 : -1,
	      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

	  buffer[offset + i - d] |= s * 128;
	};


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(128)
	__webpack_require__(129)
	__webpack_require__(130)
	__webpack_require__(131)

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = (function (){
	  try {
	    return __webpack_require__(138); // hack to fix a circular dependency issue when used with browserify
	  } catch(_){}
	}());
	exports = module.exports = __webpack_require__(132);
	exports.Stream = Stream || exports;
	exports.Readable = exports;
	exports.Writable = __webpack_require__(133);
	exports.Duplex = __webpack_require__(134);
	exports.Transform = __webpack_require__(135);
	exports.PassThrough = __webpack_require__(136);


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array

		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)

		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}

		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length

			var L = 0

			function push (v) {
				arr[L++] = v
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}

			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}

			return arr
		}

		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length

			function encode (num) {
				return lookup.charAt(num)
			}

			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}

			return output
		}

		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}(false ? (this.base64js = {}) : exports))


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
	  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
	  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
	  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
	  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
	  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
	  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
	  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
	  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
	  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function (root, factory) {
	    'use strict';

	    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
	    // Rhino, and plain browser loading.

	    /* istanbul ignore next */
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports !== 'undefined') {
	        factory(exports);
	    } else {
	        factory((root.esprima = {}));
	    }
	}(this, function (exports) {
	    'use strict';

	    var Token,
	        TokenName,
	        FnExprTokens,
	        Syntax,
	        PlaceHolders,
	        Messages,
	        Regex,
	        source,
	        strict,
	        sourceType,
	        index,
	        lineNumber,
	        lineStart,
	        hasLineTerminator,
	        lastIndex,
	        lastLineNumber,
	        lastLineStart,
	        startIndex,
	        startLineNumber,
	        startLineStart,
	        scanning,
	        length,
	        lookahead,
	        state,
	        extra,
	        isBindingElement,
	        isAssignmentTarget,
	        firstCoverInitializedNameError;

	    Token = {
	        BooleanLiteral: 1,
	        EOF: 2,
	        Identifier: 3,
	        Keyword: 4,
	        NullLiteral: 5,
	        NumericLiteral: 6,
	        Punctuator: 7,
	        StringLiteral: 8,
	        RegularExpression: 9,
	        Template: 10
	    };

	    TokenName = {};
	    TokenName[Token.BooleanLiteral] = 'Boolean';
	    TokenName[Token.EOF] = '<end>';
	    TokenName[Token.Identifier] = 'Identifier';
	    TokenName[Token.Keyword] = 'Keyword';
	    TokenName[Token.NullLiteral] = 'Null';
	    TokenName[Token.NumericLiteral] = 'Numeric';
	    TokenName[Token.Punctuator] = 'Punctuator';
	    TokenName[Token.StringLiteral] = 'String';
	    TokenName[Token.RegularExpression] = 'RegularExpression';
	    TokenName[Token.Template] = 'Template';

	    // A function following one of those tokens is an expression.
	    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	                    'return', 'case', 'delete', 'throw', 'void',
	                    // assignment operators
	                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
	                    '&=', '|=', '^=', ',',
	                    // binary/unary operators
	                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	                    '<=', '<', '>', '!=', '!=='];

	    Syntax = {
	        AssignmentExpression: 'AssignmentExpression',
	        AssignmentPattern: 'AssignmentPattern',
	        ArrayExpression: 'ArrayExpression',
	        ArrayPattern: 'ArrayPattern',
	        ArrowFunctionExpression: 'ArrowFunctionExpression',
	        BlockStatement: 'BlockStatement',
	        BinaryExpression: 'BinaryExpression',
	        BreakStatement: 'BreakStatement',
	        CallExpression: 'CallExpression',
	        CatchClause: 'CatchClause',
	        ClassBody: 'ClassBody',
	        ClassDeclaration: 'ClassDeclaration',
	        ClassExpression: 'ClassExpression',
	        ConditionalExpression: 'ConditionalExpression',
	        ContinueStatement: 'ContinueStatement',
	        DoWhileStatement: 'DoWhileStatement',
	        DebuggerStatement: 'DebuggerStatement',
	        EmptyStatement: 'EmptyStatement',
	        ExportAllDeclaration: 'ExportAllDeclaration',
	        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	        ExportNamedDeclaration: 'ExportNamedDeclaration',
	        ExportSpecifier: 'ExportSpecifier',
	        ExpressionStatement: 'ExpressionStatement',
	        ForStatement: 'ForStatement',
	        ForInStatement: 'ForInStatement',
	        FunctionDeclaration: 'FunctionDeclaration',
	        FunctionExpression: 'FunctionExpression',
	        Identifier: 'Identifier',
	        IfStatement: 'IfStatement',
	        ImportDeclaration: 'ImportDeclaration',
	        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	        ImportSpecifier: 'ImportSpecifier',
	        Literal: 'Literal',
	        LabeledStatement: 'LabeledStatement',
	        LogicalExpression: 'LogicalExpression',
	        MemberExpression: 'MemberExpression',
	        MethodDefinition: 'MethodDefinition',
	        NewExpression: 'NewExpression',
	        ObjectExpression: 'ObjectExpression',
	        ObjectPattern: 'ObjectPattern',
	        Program: 'Program',
	        Property: 'Property',
	        RestElement: 'RestElement',
	        ReturnStatement: 'ReturnStatement',
	        SequenceExpression: 'SequenceExpression',
	        SpreadElement: 'SpreadElement',
	        Super: 'Super',
	        SwitchCase: 'SwitchCase',
	        SwitchStatement: 'SwitchStatement',
	        TaggedTemplateExpression: 'TaggedTemplateExpression',
	        TemplateElement: 'TemplateElement',
	        TemplateLiteral: 'TemplateLiteral',
	        ThisExpression: 'ThisExpression',
	        ThrowStatement: 'ThrowStatement',
	        TryStatement: 'TryStatement',
	        UnaryExpression: 'UnaryExpression',
	        UpdateExpression: 'UpdateExpression',
	        VariableDeclaration: 'VariableDeclaration',
	        VariableDeclarator: 'VariableDeclarator',
	        WhileStatement: 'WhileStatement',
	        WithStatement: 'WithStatement'
	    };

	    PlaceHolders = {
	        ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'
	    };

	    // Error messages should be identical to V8.
	    Messages = {
	        UnexpectedToken: 'Unexpected token %0',
	        UnexpectedNumber: 'Unexpected number',
	        UnexpectedString: 'Unexpected string',
	        UnexpectedIdentifier: 'Unexpected identifier',
	        UnexpectedReserved: 'Unexpected reserved word',
	        UnexpectedTemplate: 'Unexpected quasi %0',
	        UnexpectedEOS: 'Unexpected end of input',
	        NewlineAfterThrow: 'Illegal newline after throw',
	        InvalidRegExp: 'Invalid regular expression',
	        UnterminatedRegExp: 'Invalid regular expression: missing /',
	        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	        NoCatchOrFinally: 'Missing catch or finally after try',
	        UnknownLabel: 'Undefined label \'%0\'',
	        Redeclaration: '%0 \'%1\' has already been declared',
	        IllegalContinue: 'Illegal continue statement',
	        IllegalBreak: 'Illegal break statement',
	        IllegalReturn: 'Illegal return statement',
	        StrictModeWith: 'Strict mode code may not include a with statement',
	        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	        StrictReservedWord: 'Use of future reserved word in strict mode',
	        TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
	        ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
	        DefaultRestParameter: 'Unexpected token =',
	        ObjectPatternAsRestParameter: 'Unexpected token {',
	        DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
	        ConstructorSpecialMethod: 'Class constructor may not be an accessor',
	        DuplicateConstructor: 'A class may only have one constructor',
	        StaticPrototype: 'Classes may not have static property named prototype',
	        MissingFromClause: 'Unexpected token',
	        NoAsAfterImportNamespace: 'Unexpected token',
	        InvalidModuleSpecifier: 'Unexpected token',
	        IllegalImportDeclaration: 'Unexpected token',
	        IllegalExportDeclaration: 'Unexpected token'
	    };

	    // See also tools/generate-unicode-regex.py.
	    Regex = {
	        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
	        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
	    };

	    // Ensure the condition is true, otherwise throw an error.
	    // This is only to have a better contract semantic, i.e. another safety net
	    // to catch a logic error. The condition shall be fulfilled in normal case.
	    // Do NOT use this to enforce a certain condition on any user input.

	    function assert(condition, message) {
	        /* istanbul ignore if */
	        if (!condition) {
	            throw new Error('ASSERT: ' + message);
	        }
	    }

	    function isDecimalDigit(ch) {
	        return (ch >= 0x30 && ch <= 0x39);   // 0..9
	    }

	    function isHexDigit(ch) {
	        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
	    }

	    function isOctalDigit(ch) {
	        return '01234567'.indexOf(ch) >= 0;
	    }

	    function octalToDecimal(ch) {
	        // \0 is not octal escape sequence
	        var octal = (ch !== '0'), code = '01234567'.indexOf(ch);

	        if (index < length && isOctalDigit(source[index])) {
	            octal = true;
	            code = code * 8 + '01234567'.indexOf(source[index++]);

	            // 3 digits are only allowed when string starts
	            // with 0, 1, 2, 3
	            if ('0123'.indexOf(ch) >= 0 &&
	                    index < length &&
	                    isOctalDigit(source[index])) {
	                code = code * 8 + '01234567'.indexOf(source[index++]);
	            }
	        }

	        return {
	            code: code,
	            octal: octal
	        };
	    }

	    // 7.2 White Space

	    function isWhiteSpace(ch) {
	        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
	            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
	    }

	    // 7.3 Line Terminators

	    function isLineTerminator(ch) {
	        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
	    }

	    // 7.6 Identifier Names and Identifiers

	    function isIdentifierStart(ch) {
	        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
	            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
	            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
	            (ch === 0x5C) ||                      // \ (backslash)
	            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
	    }

	    function isIdentifierPart(ch) {
	        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
	            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
	            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
	            (ch >= 0x30 && ch <= 0x39) ||         // 0..9
	            (ch === 0x5C) ||                      // \ (backslash)
	            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
	    }

	    // 7.6.1.2 Future Reserved Words

	    function isFutureReservedWord(id) {
	        switch (id) {
	        case 'enum':
	        case 'export':
	        case 'import':
	        case 'super':
	            return true;
	        default:
	            return false;
	        }
	    }

	    // 11.6.2.2 Future Reserved Words

	    function isStrictModeReservedWord(id) {
	        switch (id) {
	        case 'implements':
	        case 'interface':
	        case 'package':
	        case 'private':
	        case 'protected':
	        case 'public':
	        case 'static':
	        case 'yield':
	        case 'let':
	            return true;
	        default:
	            return false;
	        }
	    }

	    function isRestrictedWord(id) {
	        return id === 'eval' || id === 'arguments';
	    }

	    // 7.6.1.1 Keywords

	    function isKeyword(id) {

	        // 'const' is specialized as Keyword in V8.
	        // 'yield' and 'let' are for compatibility with SpiderMonkey and ES.next.
	        // Some others are from future reserved words.

	        switch (id.length) {
	        case 2:
	            return (id === 'if') || (id === 'in') || (id === 'do');
	        case 3:
	            return (id === 'var') || (id === 'for') || (id === 'new') ||
	                (id === 'try') || (id === 'let');
	        case 4:
	            return (id === 'this') || (id === 'else') || (id === 'case') ||
	                (id === 'void') || (id === 'with') || (id === 'enum');
	        case 5:
	            return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                (id === 'class') || (id === 'super');
	        case 6:
	            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                (id === 'switch') || (id === 'export') || (id === 'import');
	        case 7:
	            return (id === 'default') || (id === 'finally') || (id === 'extends');
	        case 8:
	            return (id === 'function') || (id === 'continue') || (id === 'debugger');
	        case 10:
	            return (id === 'instanceof');
	        default:
	            return false;
	        }
	    }

	    // 7.4 Comments

	    function addComment(type, value, start, end, loc) {
	        var comment;

	        assert(typeof start === 'number', 'Comment must have valid position');

	        state.lastCommentStart = start;

	        comment = {
	            type: type,
	            value: value
	        };
	        if (extra.range) {
	            comment.range = [start, end];
	        }
	        if (extra.loc) {
	            comment.loc = loc;
	        }
	        extra.comments.push(comment);
	        if (extra.attachComment) {
	            extra.leadingComments.push(comment);
	            extra.trailingComments.push(comment);
	        }
	    }

	    function skipSingleLineComment(offset) {
	        var start, loc, ch, comment;

	        start = index - offset;
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart - offset
	            }
	        };

	        while (index < length) {
	            ch = source.charCodeAt(index);
	            ++index;
	            if (isLineTerminator(ch)) {
	                hasLineTerminator = true;
	                if (extra.comments) {
	                    comment = source.slice(start + offset, index - 1);
	                    loc.end = {
	                        line: lineNumber,
	                        column: index - lineStart - 1
	                    };
	                    addComment('Line', comment, start, index - 1, loc);
	                }
	                if (ch === 13 && source.charCodeAt(index) === 10) {
	                    ++index;
	                }
	                ++lineNumber;
	                lineStart = index;
	                return;
	            }
	        }

	        if (extra.comments) {
	            comment = source.slice(start + offset, index);
	            loc.end = {
	                line: lineNumber,
	                column: index - lineStart
	            };
	            addComment('Line', comment, start, index, loc);
	        }
	    }

	    function skipMultiLineComment() {
	        var start, loc, ch, comment;

	        if (extra.comments) {
	            start = index - 2;
	            loc = {
	                start: {
	                    line: lineNumber,
	                    column: index - lineStart - 2
	                }
	            };
	        }

	        while (index < length) {
	            ch = source.charCodeAt(index);
	            if (isLineTerminator(ch)) {
	                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
	                    ++index;
	                }
	                hasLineTerminator = true;
	                ++lineNumber;
	                ++index;
	                lineStart = index;
	            } else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (source.charCodeAt(index + 1) === 0x2F) {
	                    ++index;
	                    ++index;
	                    if (extra.comments) {
	                        comment = source.slice(start + 2, index - 2);
	                        loc.end = {
	                            line: lineNumber,
	                            column: index - lineStart
	                        };
	                        addComment('Block', comment, start, index, loc);
	                    }
	                    return;
	                }
	                ++index;
	            } else {
	                ++index;
	            }
	        }

	        // Ran off the end of the file - the whole thing is a comment
	        if (extra.comments) {
	            loc.end = {
	                line: lineNumber,
	                column: index - lineStart
	            };
	            comment = source.slice(start + 2, index);
	            addComment('Block', comment, start, index, loc);
	        }
	        tolerateUnexpectedToken();
	    }

	    function skipComment() {
	        var ch, start;
	        hasLineTerminator = false;

	        start = (index === 0);
	        while (index < length) {
	            ch = source.charCodeAt(index);

	            if (isWhiteSpace(ch)) {
	                ++index;
	            } else if (isLineTerminator(ch)) {
	                hasLineTerminator = true;
	                ++index;
	                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
	                    ++index;
	                }
	                ++lineNumber;
	                lineStart = index;
	                start = true;
	            } else if (ch === 0x2F) { // U+002F is '/'
	                ch = source.charCodeAt(index + 1);
	                if (ch === 0x2F) {
	                    ++index;
	                    ++index;
	                    skipSingleLineComment(2);
	                    start = true;
	                } else if (ch === 0x2A) {  // U+002A is '*'
	                    ++index;
	                    ++index;
	                    skipMultiLineComment();
	                } else {
	                    break;
	                }
	            } else if (start && ch === 0x2D) { // U+002D is '-'
	                // U+003E is '>'
	                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    index += 3;
	                    skipSingleLineComment(3);
	                } else {
	                    break;
	                }
	            } else if (ch === 0x3C) { // U+003C is '<'
	                if (source.slice(index + 1, index + 4) === '!--') {
	                    ++index; // `<`
	                    ++index; // `!`
	                    ++index; // `-`
	                    ++index; // `-`
	                    skipSingleLineComment(4);
	                } else {
	                    break;
	                }
	            } else {
	                break;
	            }
	        }
	    }

	    function scanHexEscape(prefix) {
	        var i, len, ch, code = 0;

	        len = (prefix === 'u') ? 4 : 2;
	        for (i = 0; i < len; ++i) {
	            if (index < length && isHexDigit(source[index])) {
	                ch = source[index++];
	                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
	            } else {
	                return '';
	            }
	        }
	        return String.fromCharCode(code);
	    }

	    function scanUnicodeCodePointEscape() {
	        var ch, code, cu1, cu2;

	        ch = source[index];
	        code = 0;

	        // At least, one hex digit is required.
	        if (ch === '}') {
	            throwUnexpectedToken();
	        }

	        while (index < length) {
	            ch = source[index++];
	            if (!isHexDigit(ch)) {
	                break;
	            }
	            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
	        }

	        if (code > 0x10FFFF || ch !== '}') {
	            throwUnexpectedToken();
	        }

	        // UTF-16 Encoding
	        if (code <= 0xFFFF) {
	            return String.fromCharCode(code);
	        }
	        cu1 = ((code - 0x10000) >> 10) + 0xD800;
	        cu2 = ((code - 0x10000) & 1023) + 0xDC00;
	        return String.fromCharCode(cu1, cu2);
	    }

	    function getEscapedIdentifier() {
	        var ch, id;

	        ch = source.charCodeAt(index++);
	        id = String.fromCharCode(ch);

	        // '\u' (U+005C, U+0075) denotes an escaped character.
	        if (ch === 0x5C) {
	            if (source.charCodeAt(index) !== 0x75) {
	                throwUnexpectedToken();
	            }
	            ++index;
	            ch = scanHexEscape('u');
	            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
	                throwUnexpectedToken();
	            }
	            id = ch;
	        }

	        while (index < length) {
	            ch = source.charCodeAt(index);
	            if (!isIdentifierPart(ch)) {
	                break;
	            }
	            ++index;
	            id += String.fromCharCode(ch);

	            // '\u' (U+005C, U+0075) denotes an escaped character.
	            if (ch === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (source.charCodeAt(index) !== 0x75) {
	                    throwUnexpectedToken();
	                }
	                ++index;
	                ch = scanHexEscape('u');
	                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
	                    throwUnexpectedToken();
	                }
	                id += ch;
	            }
	        }

	        return id;
	    }

	    function getIdentifier() {
	        var start, ch;

	        start = index++;
	        while (index < length) {
	            ch = source.charCodeAt(index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                index = start;
	                return getEscapedIdentifier();
	            }
	            if (isIdentifierPart(ch)) {
	                ++index;
	            } else {
	                break;
	            }
	        }

	        return source.slice(start, index);
	    }

	    function scanIdentifier() {
	        var start, id, type;

	        start = index;

	        // Backslash (U+005C) starts an escaped character.
	        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();

	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = Token.Identifier;
	        } else if (isKeyword(id)) {
	            type = Token.Keyword;
	        } else if (id === 'null') {
	            type = Token.NullLiteral;
	        } else if (id === 'true' || id === 'false') {
	            type = Token.BooleanLiteral;
	        } else {
	            type = Token.Identifier;
	        }

	        return {
	            type: type,
	            value: id,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }


	    // 7.7 Punctuators

	    function scanPunctuator() {
	        var token, str;

	        token = {
	            type: Token.Punctuator,
	            value: '',
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: index,
	            end: index
	        };

	        // Check for most common single-character punctuators.
	        str = source[index];
	        switch (str) {

	        case '(':
	            if (extra.tokenize) {
	                extra.openParenToken = extra.tokens.length;
	            }
	            ++index;
	            break;

	        case '{':
	            if (extra.tokenize) {
	                extra.openCurlyToken = extra.tokens.length;
	            }
	            state.curlyStack.push('{');
	            ++index;
	            break;

	        case '.':
	            ++index;
	            if (source[index] === '.' && source[index + 1] === '.') {
	                // Spread operator: ...
	                index += 2;
	                str = '...';
	            }
	            break;

	        case '}':
	            ++index;
	            state.curlyStack.pop();
	            break;
	        case ')':
	        case ';':
	        case ',':
	        case '[':
	        case ']':
	        case ':':
	        case '?':
	        case '~':
	            ++index;
	            break;

	        default:
	            // 4-character punctuator.
	            str = source.substr(index, 4);
	            if (str === '>>>=') {
	                index += 4;
	            } else {

	                // 3-character punctuators.
	                str = str.substr(0, 3);
	                if (str === '===' || str === '!==' || str === '>>>' ||
	                    str === '<<=' || str === '>>=') {
	                    index += 3;
	                } else {

	                    // 2-character punctuators.
	                    str = str.substr(0, 2);
	                    if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
	                        str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
	                        str === '++' || str === '--' || str === '<<' || str === '>>' ||
	                        str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
	                        str === '<=' || str === '>=' || str === '=>') {
	                        index += 2;
	                    } else {

	                        // 1-character punctuators.
	                        str = source[index];
	                        if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
	                            ++index;
	                        }
	                    }
	                }
	            }
	        }

	        if (index === token.start) {
	            throwUnexpectedToken();
	        }

	        token.end = index;
	        token.value = str;
	        return token;
	    }

	    // 7.8.3 Numeric Literals

	    function scanHexLiteral(start) {
	        var number = '';

	        while (index < length) {
	            if (!isHexDigit(source[index])) {
	                break;
	            }
	            number += source[index++];
	        }

	        if (number.length === 0) {
	            throwUnexpectedToken();
	        }

	        if (isIdentifierStart(source.charCodeAt(index))) {
	            throwUnexpectedToken();
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseInt('0x' + number, 16),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    function scanBinaryLiteral(start) {
	        var ch, number;

	        number = '';

	        while (index < length) {
	            ch = source[index];
	            if (ch !== '0' && ch !== '1') {
	                break;
	            }
	            number += source[index++];
	        }

	        if (number.length === 0) {
	            // only 0b or 0B
	            throwUnexpectedToken();
	        }

	        if (index < length) {
	            ch = source.charCodeAt(index);
	            /* istanbul ignore else */
	            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
	                throwUnexpectedToken();
	            }
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseInt(number, 2),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    function scanOctalLiteral(prefix, start) {
	        var number, octal;

	        if (isOctalDigit(prefix)) {
	            octal = true;
	            number = '0' + source[index++];
	        } else {
	            octal = false;
	            ++index;
	            number = '';
	        }

	        while (index < length) {
	            if (!isOctalDigit(source[index])) {
	                break;
	            }
	            number += source[index++];
	        }

	        if (!octal && number.length === 0) {
	            // only 0o or 0O
	            throwUnexpectedToken();
	        }

	        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
	            throwUnexpectedToken();
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseInt(number, 8),
	            octal: octal,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    function isImplicitOctalLiteral() {
	        var i, ch;

	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (i = index + 1; i < length; ++i) {
	            ch = source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!isOctalDigit(ch)) {
	                return true;
	            }
	        }

	        return true;
	    }

	    function scanNumericLiteral() {
	        var number, start, ch;

	        ch = source[index];
	        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
	            'Numeric literal must start with a decimal digit or a decimal point');

	        start = index;
	        number = '';
	        if (ch !== '.') {
	            number = source[index++];
	            ch = source[index];

	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            // Octal number in ES6 starts with '0o'.
	            // Binary number in ES6 starts with '0b'.
	            if (number === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++index;
	                    return scanHexLiteral(start);
	                }
	                if (ch === 'b' || ch === 'B') {
	                    ++index;
	                    return scanBinaryLiteral(start);
	                }
	                if (ch === 'o' || ch === 'O') {
	                    return scanOctalLiteral(ch, start);
	                }

	                if (isOctalDigit(ch)) {
	                    if (isImplicitOctalLiteral()) {
	                        return scanOctalLiteral(ch, start);
	                    }
	                }
	            }

	            while (isDecimalDigit(source.charCodeAt(index))) {
	                number += source[index++];
	            }
	            ch = source[index];
	        }

	        if (ch === '.') {
	            number += source[index++];
	            while (isDecimalDigit(source.charCodeAt(index))) {
	                number += source[index++];
	            }
	            ch = source[index];
	        }

	        if (ch === 'e' || ch === 'E') {
	            number += source[index++];

	            ch = source[index];
	            if (ch === '+' || ch === '-') {
	                number += source[index++];
	            }
	            if (isDecimalDigit(source.charCodeAt(index))) {
	                while (isDecimalDigit(source.charCodeAt(index))) {
	                    number += source[index++];
	                }
	            } else {
	                throwUnexpectedToken();
	            }
	        }

	        if (isIdentifierStart(source.charCodeAt(index))) {
	            throwUnexpectedToken();
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseFloat(number),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    // 7.8.4 String Literals

	    function scanStringLiteral() {
	        var str = '', quote, start, ch, unescaped, octToDec, octal = false;

	        quote = source[index];
	        assert((quote === '\'' || quote === '"'),
	            'String literal must starts with a quote');

	        start = index;
	        ++index;

	        while (index < length) {
	            ch = source[index++];

	            if (ch === quote) {
	                quote = '';
	                break;
	            } else if (ch === '\\') {
	                ch = source[index++];
	                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                    case 'u':
	                    case 'x':
	                        if (source[index] === '{') {
	                            ++index;
	                            str += scanUnicodeCodePointEscape();
	                        } else {
	                            unescaped = scanHexEscape(ch);
	                            if (!unescaped) {
	                                throw throwUnexpectedToken();
	                            }
	                            str += unescaped;
	                        }
	                        break;
	                    case 'n':
	                        str += '\n';
	                        break;
	                    case 'r':
	                        str += '\r';
	                        break;
	                    case 't':
	                        str += '\t';
	                        break;
	                    case 'b':
	                        str += '\b';
	                        break;
	                    case 'f':
	                        str += '\f';
	                        break;
	                    case 'v':
	                        str += '\x0B';
	                        break;
	                    case '8':
	                    case '9':
	                        throw throwUnexpectedToken();

	                    default:
	                        if (isOctalDigit(ch)) {
	                            octToDec = octalToDecimal(ch);

	                            octal = octToDec.octal || octal;
	                            str += String.fromCharCode(octToDec.code);
	                        } else {
	                            str += ch;
	                        }
	                        break;
	                    }
	                } else {
	                    ++lineNumber;
	                    if (ch === '\r' && source[index] === '\n') {
	                        ++index;
	                    }
	                    lineStart = index;
	                }
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            } else {
	                str += ch;
	            }
	        }

	        if (quote !== '') {
	            throwUnexpectedToken();
	        }

	        return {
	            type: Token.StringLiteral,
	            value: str,
	            octal: octal,
	            lineNumber: startLineNumber,
	            lineStart: startLineStart,
	            start: start,
	            end: index
	        };
	    }

	    function scanTemplate() {
	        var cooked = '', ch, start, rawOffset, terminated, head, tail, restore, unescaped;

	        terminated = false;
	        tail = false;
	        start = index;
	        head = (source[index] === '`');
	        rawOffset = 2;

	        ++index;

	        while (index < length) {
	            ch = source[index++];
	            if (ch === '`') {
	                rawOffset = 1;
	                tail = true;
	                terminated = true;
	                break;
	            } else if (ch === '$') {
	                if (source[index] === '{') {
	                    state.curlyStack.push('${');
	                    ++index;
	                    terminated = true;
	                    break;
	                }
	                cooked += ch;
	            } else if (ch === '\\') {
	                ch = source[index++];
	                if (!isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                    case 'n':
	                        cooked += '\n';
	                        break;
	                    case 'r':
	                        cooked += '\r';
	                        break;
	                    case 't':
	                        cooked += '\t';
	                        break;
	                    case 'u':
	                    case 'x':
	                        if (source[index] === '{') {
	                            ++index;
	                            cooked += scanUnicodeCodePointEscape();
	                        } else {
	                            restore = index;
	                            unescaped = scanHexEscape(ch);
	                            if (unescaped) {
	                                cooked += unescaped;
	                            } else {
	                                index = restore;
	                                cooked += ch;
	                            }
	                        }
	                        break;
	                    case 'b':
	                        cooked += '\b';
	                        break;
	                    case 'f':
	                        cooked += '\f';
	                        break;
	                    case 'v':
	                        cooked += '\v';
	                        break;

	                    default:
	                        if (ch === '0') {
	                            if (isDecimalDigit(source.charCodeAt(index))) {
	                                // Illegal: \01 \02 and so on
	                                throwError(Messages.TemplateOctalLiteral);
	                            }
	                            cooked += '\0';
	                        } else if (isOctalDigit(ch)) {
	                            // Illegal: \1 \2
	                            throwError(Messages.TemplateOctalLiteral);
	                        } else {
	                            cooked += ch;
	                        }
	                        break;
	                    }
	                } else {
	                    ++lineNumber;
	                    if (ch === '\r' && source[index] === '\n') {
	                        ++index;
	                    }
	                    lineStart = index;
	                }
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                ++lineNumber;
	                if (ch === '\r' && source[index] === '\n') {
	                    ++index;
	                }
	                lineStart = index;
	                cooked += '\n';
	            } else {
	                cooked += ch;
	            }
	        }

	        if (!terminated) {
	            throwUnexpectedToken();
	        }

	        if (!head) {
	            state.curlyStack.pop();
	        }

	        return {
	            type: Token.Template,
	            value: {
	                cooked: cooked,
	                raw: source.slice(start + 1, index - rawOffset)
	            },
	            head: head,
	            tail: tail,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    function testRegExp(pattern, flags) {
	        var tmp = pattern;

	        if (flags.indexOf('u') >= 0) {
	            // Replace each astral symbol and every Unicode escape sequence
	            // that possibly represents an astral symbol or a paired surrogate
	            // with a single ASCII symbol to avoid throwing on regular
	            // expressions that are only valid in combination with the `/u`
	            // flag.
	            // Note: replacing with the ASCII symbol `x` might cause false
	            // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
	            // perfectly valid pattern that is equivalent to `[a-b]`, but it
	            // would be replaced by `[x-b]` which throws an error.
	            tmp = tmp
	                .replace(/\\u\{([0-9a-fA-F]+)\}/g, function ($0, $1) {
	                    if (parseInt($1, 16) <= 0x10FFFF) {
	                        return 'x';
	                    }
	                    throwUnexpectedToken(null, Messages.InvalidRegExp);
	                })
	                .replace(
	                    /\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
	                    'x'
	                );
	        }

	        // First, detect invalid regular expressions.
	        try {
	            RegExp(tmp);
	        } catch (e) {
	            throwUnexpectedToken(null, Messages.InvalidRegExp);
	        }

	        // Return a regular expression object for this pattern-flag pair, or
	        // `null` in case the current environment doesn't support the flags it
	        // uses.
	        try {
	            return new RegExp(pattern, flags);
	        } catch (exception) {
	            return null;
	        }
	    }

	    function scanRegExpBody() {
	        var ch, str, classMarker, terminated, body;

	        ch = source[index];
	        assert(ch === '/', 'Regular expression literal must start with a slash');
	        str = source[index++];

	        classMarker = false;
	        terminated = false;
	        while (index < length) {
	            ch = source[index++];
	            str += ch;
	            if (ch === '\\') {
	                ch = source[index++];
	                // ECMA-262 7.8.5
	                if (isLineTerminator(ch.charCodeAt(0))) {
	                    throwUnexpectedToken(null, Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                throwUnexpectedToken(null, Messages.UnterminatedRegExp);
	            } else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            } else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                } else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }

	        if (!terminated) {
	            throwUnexpectedToken(null, Messages.UnterminatedRegExp);
	        }

	        // Exclude leading and trailing slash.
	        body = str.substr(1, str.length - 2);
	        return {
	            value: body,
	            literal: str
	        };
	    }

	    function scanRegExpFlags() {
	        var ch, str, flags, restore;

	        str = '';
	        flags = '';
	        while (index < length) {
	            ch = source[index];
	            if (!isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }

	            ++index;
	            if (ch === '\\' && index < length) {
	                ch = source[index];
	                if (ch === 'u') {
	                    ++index;
	                    restore = index;
	                    ch = scanHexEscape('u');
	                    if (ch) {
	                        flags += ch;
	                        for (str += '\\u'; restore < index; ++restore) {
	                            str += source[restore];
	                        }
	                    } else {
	                        index = restore;
	                        flags += 'u';
	                        str += '\\u';
	                    }
	                    tolerateUnexpectedToken();
	                } else {
	                    str += '\\';
	                    tolerateUnexpectedToken();
	                }
	            } else {
	                flags += ch;
	                str += ch;
	            }
	        }

	        return {
	            value: flags,
	            literal: str
	        };
	    }

	    function scanRegExp() {
	        scanning = true;
	        var start, body, flags, value;

	        lookahead = null;
	        skipComment();
	        start = index;

	        body = scanRegExpBody();
	        flags = scanRegExpFlags();
	        value = testRegExp(body.value, flags.value);
	        scanning = false;
	        if (extra.tokenize) {
	            return {
	                type: Token.RegularExpression,
	                value: value,
	                regex: {
	                    pattern: body.value,
	                    flags: flags.value
	                },
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	            };
	        }

	        return {
	            literal: body.literal + flags.literal,
	            value: value,
	            regex: {
	                pattern: body.value,
	                flags: flags.value
	            },
	            start: start,
	            end: index
	        };
	    }

	    function collectRegex() {
	        var pos, loc, regex, token;

	        skipComment();

	        pos = index;
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart
	            }
	        };

	        regex = scanRegExp();

	        loc.end = {
	            line: lineNumber,
	            column: index - lineStart
	        };

	        /* istanbul ignore next */
	        if (!extra.tokenize) {
	            // Pop the previous token, which is likely '/' or '/='
	            if (extra.tokens.length > 0) {
	                token = extra.tokens[extra.tokens.length - 1];
	                if (token.range[0] === pos && token.type === 'Punctuator') {
	                    if (token.value === '/' || token.value === '/=') {
	                        extra.tokens.pop();
	                    }
	                }
	            }

	            extra.tokens.push({
	                type: 'RegularExpression',
	                value: regex.literal,
	                regex: regex.regex,
	                range: [pos, index],
	                loc: loc
	            });
	        }

	        return regex;
	    }

	    function isIdentifierName(token) {
	        return token.type === Token.Identifier ||
	            token.type === Token.Keyword ||
	            token.type === Token.BooleanLiteral ||
	            token.type === Token.NullLiteral;
	    }

	    function advanceSlash() {
	        var prevToken,
	            checkToken;
	        // Using the following algorithm:
	        // https://github.com/mozilla/sweet.js/wiki/design
	        prevToken = extra.tokens[extra.tokens.length - 1];
	        if (!prevToken) {
	            // Nothing before that: it cannot be a division.
	            return collectRegex();
	        }
	        if (prevToken.type === 'Punctuator') {
	            if (prevToken.value === ']') {
	                return scanPunctuator();
	            }
	            if (prevToken.value === ')') {
	                checkToken = extra.tokens[extra.openParenToken - 1];
	                if (checkToken &&
	                        checkToken.type === 'Keyword' &&
	                        (checkToken.value === 'if' ||
	                         checkToken.value === 'while' ||
	                         checkToken.value === 'for' ||
	                         checkToken.value === 'with')) {
	                    return collectRegex();
	                }
	                return scanPunctuator();
	            }
	            if (prevToken.value === '}') {
	                // Dividing a function by anything makes little sense,
	                // but we have to check for that.
	                if (extra.tokens[extra.openCurlyToken - 3] &&
	                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
	                    // Anonymous function.
	                    checkToken = extra.tokens[extra.openCurlyToken - 4];
	                    if (!checkToken) {
	                        return scanPunctuator();
	                    }
	                } else if (extra.tokens[extra.openCurlyToken - 4] &&
	                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
	                    // Named function.
	                    checkToken = extra.tokens[extra.openCurlyToken - 5];
	                    if (!checkToken) {
	                        return collectRegex();
	                    }
	                } else {
	                    return scanPunctuator();
	                }
	                // checkToken determines whether the function is
	                // a declaration or an expression.
	                if (FnExprTokens.indexOf(checkToken.value) >= 0) {
	                    // It is an expression.
	                    return scanPunctuator();
	                }
	                // It is a declaration.
	                return collectRegex();
	            }
	            return collectRegex();
	        }
	        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {
	            return collectRegex();
	        }
	        return scanPunctuator();
	    }

	    function advance() {
	        var ch, token;

	        if (index >= length) {
	            return {
	                type: Token.EOF,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: index,
	                end: index
	            };
	        }

	        ch = source.charCodeAt(index);

	        if (isIdentifierStart(ch)) {
	            token = scanIdentifier();
	            if (strict && isStrictModeReservedWord(token.value)) {
	                token.type = Token.Keyword;
	            }
	            return token;
	        }

	        // Very common: ( and ) and ;
	        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
	            return scanPunctuator();
	        }

	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (ch === 0x27 || ch === 0x22) {
	            return scanStringLiteral();
	        }

	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (ch === 0x2E) {
	            if (isDecimalDigit(source.charCodeAt(index + 1))) {
	                return scanNumericLiteral();
	            }
	            return scanPunctuator();
	        }

	        if (isDecimalDigit(ch)) {
	            return scanNumericLiteral();
	        }

	        // Slash (/) U+002F can also start a regex.
	        if (extra.tokenize && ch === 0x2F) {
	            return advanceSlash();
	        }

	        // Template literals start with ` (U+0060) for template head
	        // or } (U+007D) for template middle or template tail.
	        if (ch === 0x60 || (ch === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${')) {
	            return scanTemplate();
	        }

	        return scanPunctuator();
	    }

	    function collectToken() {
	        var loc, token, value, entry;

	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart
	            }
	        };

	        token = advance();
	        loc.end = {
	            line: lineNumber,
	            column: index - lineStart
	        };

	        if (token.type !== Token.EOF) {
	            value = source.slice(token.start, token.end);
	            entry = {
	                type: TokenName[token.type],
	                value: value,
	                range: [token.start, token.end],
	                loc: loc
	            };
	            if (token.regex) {
	                entry.regex = {
	                    pattern: token.regex.pattern,
	                    flags: token.regex.flags
	                };
	            }
	            extra.tokens.push(entry);
	        }

	        return token;
	    }

	    function lex() {
	        var token;
	        scanning = true;

	        lastIndex = index;
	        lastLineNumber = lineNumber;
	        lastLineStart = lineStart;

	        skipComment();

	        token = lookahead;

	        startIndex = index;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;

	        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
	        scanning = false;
	        return token;
	    }

	    function peek() {
	        scanning = true;

	        skipComment();

	        lastIndex = index;
	        lastLineNumber = lineNumber;
	        lastLineStart = lineStart;

	        startIndex = index;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;

	        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
	        scanning = false;
	    }

	    function Position() {
	        this.line = startLineNumber;
	        this.column = startIndex - startLineStart;
	    }

	    function SourceLocation() {
	        this.start = new Position();
	        this.end = null;
	    }

	    function WrappingSourceLocation(startToken) {
	        this.start = {
	            line: startToken.lineNumber,
	            column: startToken.start - startToken.lineStart
	        };
	        this.end = null;
	    }

	    function Node() {
	        if (extra.range) {
	            this.range = [startIndex, 0];
	        }
	        if (extra.loc) {
	            this.loc = new SourceLocation();
	        }
	    }

	    function WrappingNode(startToken) {
	        if (extra.range) {
	            this.range = [startToken.start, 0];
	        }
	        if (extra.loc) {
	            this.loc = new WrappingSourceLocation(startToken);
	        }
	    }

	    WrappingNode.prototype = Node.prototype = {

	        processComment: function () {
	            var lastChild,
	                leadingComments,
	                trailingComments,
	                bottomRight = extra.bottomRightStack,
	                i,
	                comment,
	                last = bottomRight[bottomRight.length - 1];

	            if (this.type === Syntax.Program) {
	                if (this.body.length > 0) {
	                    return;
	                }
	            }

	            if (extra.trailingComments.length > 0) {
	                trailingComments = [];
	                for (i = extra.trailingComments.length - 1; i >= 0; --i) {
	                    comment = extra.trailingComments[i];
	                    if (comment.range[0] >= this.range[1]) {
	                        trailingComments.unshift(comment);
	                        extra.trailingComments.splice(i, 1);
	                    }
	                }
	                extra.trailingComments = [];
	            } else {
	                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {
	                    trailingComments = last.trailingComments;
	                    delete last.trailingComments;
	                }
	            }

	            // Eating the stack.
	            if (last) {
	                while (last && last.range[0] >= this.range[0]) {
	                    lastChild = last;
	                    last = bottomRight.pop();
	                }
	            }

	            if (lastChild) {
	                if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= this.range[0]) {
	                    this.leadingComments = lastChild.leadingComments;
	                    lastChild.leadingComments = undefined;
	                }
	            } else if (extra.leadingComments.length > 0) {
	                leadingComments = [];
	                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
	                    comment = extra.leadingComments[i];
	                    if (comment.range[1] <= this.range[0]) {
	                        leadingComments.unshift(comment);
	                        extra.leadingComments.splice(i, 1);
	                    }
	                }
	            }


	            if (leadingComments && leadingComments.length > 0) {
	                this.leadingComments = leadingComments;
	            }
	            if (trailingComments && trailingComments.length > 0) {
	                this.trailingComments = trailingComments;
	            }

	            bottomRight.push(this);
	        },

	        finish: function () {
	            if (extra.range) {
	                this.range[1] = lastIndex;
	            }
	            if (extra.loc) {
	                this.loc.end = {
	                    line: lastLineNumber,
	                    column: lastIndex - lastLineStart
	                };
	                if (extra.source) {
	                    this.loc.source = extra.source;
	                }
	            }

	            if (extra.attachComment) {
	                this.processComment();
	            }
	        },

	        finishArrayExpression: function (elements) {
	            this.type = Syntax.ArrayExpression;
	            this.elements = elements;
	            this.finish();
	            return this;
	        },

	        finishArrayPattern: function (elements) {
	            this.type = Syntax.ArrayPattern;
	            this.elements = elements;
	            this.finish();
	            return this;
	        },

	        finishArrowFunctionExpression: function (params, defaults, body, expression) {
	            this.type = Syntax.ArrowFunctionExpression;
	            this.id = null;
	            this.params = params;
	            this.defaults = defaults;
	            this.body = body;
	            this.generator = false;
	            this.expression = expression;
	            this.finish();
	            return this;
	        },

	        finishAssignmentExpression: function (operator, left, right) {
	            this.type = Syntax.AssignmentExpression;
	            this.operator = operator;
	            this.left = left;
	            this.right = right;
	            this.finish();
	            return this;
	        },

	        finishAssignmentPattern: function (left, right) {
	            this.type = Syntax.AssignmentPattern;
	            this.left = left;
	            this.right = right;
	            this.finish();
	            return this;
	        },

	        finishBinaryExpression: function (operator, left, right) {
	            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
	            this.operator = operator;
	            this.left = left;
	            this.right = right;
	            this.finish();
	            return this;
	        },

	        finishBlockStatement: function (body) {
	            this.type = Syntax.BlockStatement;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishBreakStatement: function (label) {
	            this.type = Syntax.BreakStatement;
	            this.label = label;
	            this.finish();
	            return this;
	        },

	        finishCallExpression: function (callee, args) {
	            this.type = Syntax.CallExpression;
	            this.callee = callee;
	            this.arguments = args;
	            this.finish();
	            return this;
	        },

	        finishCatchClause: function (param, body) {
	            this.type = Syntax.CatchClause;
	            this.param = param;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishClassBody: function (body) {
	            this.type = Syntax.ClassBody;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishClassDeclaration: function (id, superClass, body) {
	            this.type = Syntax.ClassDeclaration;
	            this.id = id;
	            this.superClass = superClass;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishClassExpression: function (id, superClass, body) {
	            this.type = Syntax.ClassExpression;
	            this.id = id;
	            this.superClass = superClass;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishConditionalExpression: function (test, consequent, alternate) {
	            this.type = Syntax.ConditionalExpression;
	            this.test = test;
	            this.consequent = consequent;
	            this.alternate = alternate;
	            this.finish();
	            return this;
	        },

	        finishContinueStatement: function (label) {
	            this.type = Syntax.ContinueStatement;
	            this.label = label;
	            this.finish();
	            return this;
	        },

	        finishDebuggerStatement: function () {
	            this.type = Syntax.DebuggerStatement;
	            this.finish();
	            return this;
	        },

	        finishDoWhileStatement: function (body, test) {
	            this.type = Syntax.DoWhileStatement;
	            this.body = body;
	            this.test = test;
	            this.finish();
	            return this;
	        },

	        finishEmptyStatement: function () {
	            this.type = Syntax.EmptyStatement;
	            this.finish();
	            return this;
	        },

	        finishExpressionStatement: function (expression) {
	            this.type = Syntax.ExpressionStatement;
	            this.expression = expression;
	            this.finish();
	            return this;
	        },

	        finishForStatement: function (init, test, update, body) {
	            this.type = Syntax.ForStatement;
	            this.init = init;
	            this.test = test;
	            this.update = update;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishForInStatement: function (left, right, body) {
	            this.type = Syntax.ForInStatement;
	            this.left = left;
	            this.right = right;
	            this.body = body;
	            this.each = false;
	            this.finish();
	            return this;
	        },

	        finishFunctionDeclaration: function (id, params, defaults, body) {
	            this.type = Syntax.FunctionDeclaration;
	            this.id = id;
	            this.params = params;
	            this.defaults = defaults;
	            this.body = body;
	            this.generator = false;
	            this.expression = false;
	            this.finish();
	            return this;
	        },

	        finishFunctionExpression: function (id, params, defaults, body) {
	            this.type = Syntax.FunctionExpression;
	            this.id = id;
	            this.params = params;
	            this.defaults = defaults;
	            this.body = body;
	            this.generator = false;
	            this.expression = false;
	            this.finish();
	            return this;
	        },

	        finishIdentifier: function (name) {
	            this.type = Syntax.Identifier;
	            this.name = name;
	            this.finish();
	            return this;
	        },

	        finishIfStatement: function (test, consequent, alternate) {
	            this.type = Syntax.IfStatement;
	            this.test = test;
	            this.consequent = consequent;
	            this.alternate = alternate;
	            this.finish();
	            return this;
	        },

	        finishLabeledStatement: function (label, body) {
	            this.type = Syntax.LabeledStatement;
	            this.label = label;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishLiteral: function (token) {
	            this.type = Syntax.Literal;
	            this.value = token.value;
	            this.raw = source.slice(token.start, token.end);
	            if (token.regex) {
	                this.regex = token.regex;
	            }
	            this.finish();
	            return this;
	        },

	        finishMemberExpression: function (accessor, object, property) {
	            this.type = Syntax.MemberExpression;
	            this.computed = accessor === '[';
	            this.object = object;
	            this.property = property;
	            this.finish();
	            return this;
	        },

	        finishNewExpression: function (callee, args) {
	            this.type = Syntax.NewExpression;
	            this.callee = callee;
	            this.arguments = args;
	            this.finish();
	            return this;
	        },

	        finishObjectExpression: function (properties) {
	            this.type = Syntax.ObjectExpression;
	            this.properties = properties;
	            this.finish();
	            return this;
	        },

	        finishObjectPattern: function (properties) {
	            this.type = Syntax.ObjectPattern;
	            this.properties = properties;
	            this.finish();
	            return this;
	        },

	        finishPostfixExpression: function (operator, argument) {
	            this.type = Syntax.UpdateExpression;
	            this.operator = operator;
	            this.argument = argument;
	            this.prefix = false;
	            this.finish();
	            return this;
	        },

	        finishProgram: function (body) {
	            this.type = Syntax.Program;
	            this.body = body;
	            if (sourceType === 'module') {
	                // very restrictive for now
	                this.sourceType = sourceType;
	            }
	            this.finish();
	            return this;
	        },

	        finishProperty: function (kind, key, computed, value, method, shorthand) {
	            this.type = Syntax.Property;
	            this.key = key;
	            this.computed = computed;
	            this.value = value;
	            this.kind = kind;
	            this.method = method;
	            this.shorthand = shorthand;
	            this.finish();
	            return this;
	        },

	        finishRestElement: function (argument) {
	            this.type = Syntax.RestElement;
	            this.argument = argument;
	            this.finish();
	            return this;
	        },

	        finishReturnStatement: function (argument) {
	            this.type = Syntax.ReturnStatement;
	            this.argument = argument;
	            this.finish();
	            return this;
	        },

	        finishSequenceExpression: function (expressions) {
	            this.type = Syntax.SequenceExpression;
	            this.expressions = expressions;
	            this.finish();
	            return this;
	        },

	        finishSpreadElement: function (argument) {
	            this.type = Syntax.SpreadElement;
	            this.argument = argument;
	            this.finish();
	            return this;
	        },

	        finishSwitchCase: function (test, consequent) {
	            this.type = Syntax.SwitchCase;
	            this.test = test;
	            this.consequent = consequent;
	            this.finish();
	            return this;
	        },

	        finishSuper: function () {
	            this.type = Syntax.Super;
	            this.finish();
	            return this;
	        },

	        finishSwitchStatement: function (discriminant, cases) {
	            this.type = Syntax.SwitchStatement;
	            this.discriminant = discriminant;
	            this.cases = cases;
	            this.finish();
	            return this;
	        },

	        finishTaggedTemplateExpression: function (tag, quasi) {
	            this.type = Syntax.TaggedTemplateExpression;
	            this.tag = tag;
	            this.quasi = quasi;
	            this.finish();
	            return this;
	        },

	        finishTemplateElement: function (value, tail) {
	            this.type = Syntax.TemplateElement;
	            this.value = value;
	            this.tail = tail;
	            this.finish();
	            return this;
	        },

	        finishTemplateLiteral: function (quasis, expressions) {
	            this.type = Syntax.TemplateLiteral;
	            this.quasis = quasis;
	            this.expressions = expressions;
	            this.finish();
	            return this;
	        },

	        finishThisExpression: function () {
	            this.type = Syntax.ThisExpression;
	            this.finish();
	            return this;
	        },

	        finishThrowStatement: function (argument) {
	            this.type = Syntax.ThrowStatement;
	            this.argument = argument;
	            this.finish();
	            return this;
	        },

	        finishTryStatement: function (block, handler, finalizer) {
	            this.type = Syntax.TryStatement;
	            this.block = block;
	            this.guardedHandlers = [];
	            this.handlers = handler ? [ handler ] : [];
	            this.handler = handler;
	            this.finalizer = finalizer;
	            this.finish();
	            return this;
	        },

	        finishUnaryExpression: function (operator, argument) {
	            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;
	            this.operator = operator;
	            this.argument = argument;
	            this.prefix = true;
	            this.finish();
	            return this;
	        },

	        finishVariableDeclaration: function (declarations) {
	            this.type = Syntax.VariableDeclaration;
	            this.declarations = declarations;
	            this.kind = 'var';
	            this.finish();
	            return this;
	        },

	        finishLexicalDeclaration: function (declarations, kind) {
	            this.type = Syntax.VariableDeclaration;
	            this.declarations = declarations;
	            this.kind = kind;
	            this.finish();
	            return this;
	        },

	        finishVariableDeclarator: function (id, init) {
	            this.type = Syntax.VariableDeclarator;
	            this.id = id;
	            this.init = init;
	            this.finish();
	            return this;
	        },

	        finishWhileStatement: function (test, body) {
	            this.type = Syntax.WhileStatement;
	            this.test = test;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishWithStatement: function (object, body) {
	            this.type = Syntax.WithStatement;
	            this.object = object;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishExportSpecifier: function (local, exported) {
	            this.type = Syntax.ExportSpecifier;
	            this.exported = exported || local;
	            this.local = local;
	            this.finish();
	            return this;
	        },

	        finishImportDefaultSpecifier: function (local) {
	            this.type = Syntax.ImportDefaultSpecifier;
	            this.local = local;
	            this.finish();
	            return this;
	        },

	        finishImportNamespaceSpecifier: function (local) {
	            this.type = Syntax.ImportNamespaceSpecifier;
	            this.local = local;
	            this.finish();
	            return this;
	        },

	        finishExportNamedDeclaration: function (declaration, specifiers, src) {
	            this.type = Syntax.ExportNamedDeclaration;
	            this.declaration = declaration;
	            this.specifiers = specifiers;
	            this.source = src;
	            this.finish();
	            return this;
	        },

	        finishExportDefaultDeclaration: function (declaration) {
	            this.type = Syntax.ExportDefaultDeclaration;
	            this.declaration = declaration;
	            this.finish();
	            return this;
	        },

	        finishExportAllDeclaration: function (src) {
	            this.type = Syntax.ExportAllDeclaration;
	            this.source = src;
	            this.finish();
	            return this;
	        },

	        finishImportSpecifier: function (local, imported) {
	            this.type = Syntax.ImportSpecifier;
	            this.local = local || imported;
	            this.imported = imported;
	            this.finish();
	            return this;
	        },

	        finishImportDeclaration: function (specifiers, src) {
	            this.type = Syntax.ImportDeclaration;
	            this.specifiers = specifiers;
	            this.source = src;
	            this.finish();
	            return this;
	        }
	    };


	    function recordError(error) {
	        var e, existing;

	        for (e = 0; e < extra.errors.length; e++) {
	            existing = extra.errors[e];
	            // Prevent duplicated error.
	            /* istanbul ignore next */
	            if (existing.index === error.index && existing.message === error.message) {
	                return;
	            }
	        }

	        extra.errors.push(error);
	    }

	    function createError(line, pos, description) {
	        var error = new Error('Line ' + line + ': ' + description);
	        error.index = pos;
	        error.lineNumber = line;
	        error.column = pos - (scanning ? lineStart : lastLineStart) + 1;
	        error.description = description;
	        return error;
	    }

	    // Throw an exception

	    function throwError(messageFormat) {
	        var args, msg;

	        args = Array.prototype.slice.call(arguments, 1);
	        msg = messageFormat.replace(/%(\d)/g,
	            function (whole, idx) {
	                assert(idx < args.length, 'Message reference must be in range');
	                return args[idx];
	            }
	        );

	        throw createError(lastLineNumber, lastIndex, msg);
	    }

	    function tolerateError(messageFormat) {
	        var args, msg, error;

	        args = Array.prototype.slice.call(arguments, 1);
	        /* istanbul ignore next */
	        msg = messageFormat.replace(/%(\d)/g,
	            function (whole, idx) {
	                assert(idx < args.length, 'Message reference must be in range');
	                return args[idx];
	            }
	        );

	        error = createError(lineNumber, lastIndex, msg);
	        if (extra.errors) {
	            recordError(error);
	        } else {
	            throw error;
	        }
	    }

	    // Throw an exception because of the token.

	    function unexpectedTokenError(token, message) {
	        var value, msg = message || Messages.UnexpectedToken;

	        if (token) {
	            if (!message) {
	                msg = (token.type === Token.EOF) ? Messages.UnexpectedEOS :
	                    (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :
	                    (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :
	                    (token.type === Token.StringLiteral) ? Messages.UnexpectedString :
	                    (token.type === Token.Template) ? Messages.UnexpectedTemplate :
	                    Messages.UnexpectedToken;

	                if (token.type === Token.Keyword) {
	                    if (isFutureReservedWord(token.value)) {
	                        msg = Messages.UnexpectedReserved;
	                    } else if (strict && isStrictModeReservedWord(token.value)) {
	                        msg = Messages.StrictReservedWord;
	                    }
	                }
	            }

	            value = (token.type === Token.Template) ? token.value.raw : token.value;
	        } else {
	            value = 'ILLEGAL';
	        }

	        msg = msg.replace('%0', value);

	        return (token && typeof token.lineNumber === 'number') ?
	            createError(token.lineNumber, token.start, msg) :
	            createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);
	    }

	    function throwUnexpectedToken(token, message) {
	        throw unexpectedTokenError(token, message);
	    }

	    function tolerateUnexpectedToken(token, message) {
	        var error = unexpectedTokenError(token, message);
	        if (extra.errors) {
	            recordError(error);
	        } else {
	            throw error;
	        }
	    }

	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.

	    function expect(value) {
	        var token = lex();
	        if (token.type !== Token.Punctuator || token.value !== value) {
	            throwUnexpectedToken(token);
	        }
	    }

	    /**
	     * @name expectCommaSeparator
	     * @description Quietly expect a comma when in tolerant mode, otherwise delegates
	     * to <code>expect(value)</code>
	     * @since 2.0
	     */
	    function expectCommaSeparator() {
	        var token;

	        if (extra.errors) {
	            token = lookahead;
	            if (token.type === Token.Punctuator && token.value === ',') {
	                lex();
	            } else if (token.type === Token.Punctuator && token.value === ';') {
	                lex();
	                tolerateUnexpectedToken(token);
	            } else {
	                tolerateUnexpectedToken(token, Messages.UnexpectedToken);
	            }
	        } else {
	            expect(',');
	        }
	    }

	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.

	    function expectKeyword(keyword) {
	        var token = lex();
	        if (token.type !== Token.Keyword || token.value !== keyword) {
	            throwUnexpectedToken(token);
	        }
	    }

	    // Return true if the next token matches the specified punctuator.

	    function match(value) {
	        return lookahead.type === Token.Punctuator && lookahead.value === value;
	    }

	    // Return true if the next token matches the specified keyword

	    function matchKeyword(keyword) {
	        return lookahead.type === Token.Keyword && lookahead.value === keyword;
	    }

	    // Return true if the next token matches the specified contextual keyword
	    // (where an identifier is sometimes a keyword depending on the context)

	    function matchContextualKeyword(keyword) {
	        return lookahead.type === Token.Identifier && lookahead.value === keyword;
	    }

	    // Return true if the next token is an assignment operator

	    function matchAssign() {
	        var op;

	        if (lookahead.type !== Token.Punctuator) {
	            return false;
	        }
	        op = lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    }

	    function consumeSemicolon() {
	        // Catch the very common case first: immediately a semicolon (U+003B).
	        if (source.charCodeAt(startIndex) === 0x3B || match(';')) {
	            lex();
	            return;
	        }

	        if (hasLineTerminator) {
	            return;
	        }

	        // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.
	        lastIndex = startIndex;
	        lastLineNumber = startLineNumber;
	        lastLineStart = startLineStart;

	        if (lookahead.type !== Token.EOF && !match('}')) {
	            throwUnexpectedToken(lookahead);
	        }
	    }

	    // Cover grammar support.
	    //
	    // When an assignment expression position starts with an left parenthesis, the determination of the type
	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
	    //
	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
	    // after the outermost pair is closed. They are:
	    //
	    //   1. AssignmentExpression
	    //   2. BindingElements
	    //   3. AssignmentTargets
	    //
	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
	    // binding element or assignment target.
	    //
	    // The three productions have the relationship:
	    //
	    //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
	    //
	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
	    //
	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
	    // the CoverInitializedName check is conducted.
	    //
	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
	    // pattern. The CoverInitializedName check is deferred.
	    function isolateCoverGrammar(parser) {
	        var oldIsBindingElement = isBindingElement,
	            oldIsAssignmentTarget = isAssignmentTarget,
	            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
	            result;
	        isBindingElement = true;
	        isAssignmentTarget = true;
	        firstCoverInitializedNameError = null;
	        result = parser();
	        if (firstCoverInitializedNameError !== null) {
	            throwUnexpectedToken(firstCoverInitializedNameError);
	        }
	        isBindingElement = oldIsBindingElement;
	        isAssignmentTarget = oldIsAssignmentTarget;
	        firstCoverInitializedNameError = oldFirstCoverInitializedNameError;
	        return result;
	    }

	    function inheritCoverGrammar(parser) {
	        var oldIsBindingElement = isBindingElement,
	            oldIsAssignmentTarget = isAssignmentTarget,
	            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
	            result;
	        isBindingElement = true;
	        isAssignmentTarget = true;
	        firstCoverInitializedNameError = null;
	        result = parser();
	        isBindingElement = isBindingElement && oldIsBindingElement;
	        isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;
	        firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;
	        return result;
	    }

	    function parseArrayPattern() {
	        var node = new Node(), elements = [], rest, restNode;
	        expect('[');

	        while (!match(']')) {
	            if (match(',')) {
	                lex();
	                elements.push(null);
	            } else {
	                if (match('...')) {
	                    restNode = new Node();
	                    lex();
	                    rest = parseVariableIdentifier();
	                    elements.push(restNode.finishRestElement(rest));
	                    break;
	                } else {
	                    elements.push(parsePatternWithDefault());
	                }
	                if (!match(']')) {
	                    expect(',');
	                }
	            }

	        }

	        expect(']');

	        return node.finishArrayPattern(elements);
	    }

	    function parsePropertyPattern() {
	        var node = new Node(), key, computed = match('['), init;
	        if (lookahead.type === Token.Identifier) {
	            key = parseVariableIdentifier();
	            if (match('=')) {
	                lex();
	                init = parseAssignmentExpression();
	                return node.finishProperty(
	                    'init', key, false,
	                    new WrappingNode(key).finishAssignmentPattern(key, init), false, false);
	            } else if (!match(':')) {
	                return node.finishProperty('init', key, false, key, false, true);
	            }
	        } else {
	            key = parseObjectPropertyKey();
	        }
	        expect(':');
	        init = parsePatternWithDefault();
	        return node.finishProperty('init', key, computed, init, false, false);
	    }

	    function parseObjectPattern() {
	        var node = new Node(), properties = [];

	        expect('{');

	        while (!match('}')) {
	            properties.push(parsePropertyPattern());
	            if (!match('}')) {
	                expect(',');
	            }
	        }

	        lex();

	        return node.finishObjectPattern(properties);
	    }

	    function parsePattern() {
	        if (lookahead.type === Token.Identifier) {
	            return parseVariableIdentifier();
	        } else if (match('[')) {
	            return parseArrayPattern();
	        } else if (match('{')) {
	            return parseObjectPattern();
	        }
	        throwUnexpectedToken(lookahead);
	    }

	    function parsePatternWithDefault() {
	        var startToken = lookahead, pattern, right;
	        pattern = parsePattern();
	        if (match('=')) {
	            lex();
	            right = isolateCoverGrammar(parseAssignmentExpression);
	            pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);
	        }
	        return pattern;
	    }

	    // 11.1.4 Array Initialiser

	    function parseArrayInitialiser() {
	        var elements = [], node = new Node(), restSpread;

	        expect('[');

	        while (!match(']')) {
	            if (match(',')) {
	                lex();
	                elements.push(null);
	            } else if (match('...')) {
	                restSpread = new Node();
	                lex();
	                restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));

	                if (!match(']')) {
	                    isAssignmentTarget = isBindingElement = false;
	                    expect(',');
	                }
	                elements.push(restSpread);
	            } else {
	                elements.push(inheritCoverGrammar(parseAssignmentExpression));

	                if (!match(']')) {
	                    expect(',');
	                }
	            }
	        }

	        lex();

	        return node.finishArrayExpression(elements);
	    }

	    // 11.1.5 Object Initialiser

	    function parsePropertyFunction(node, paramInfo) {
	        var previousStrict, body;

	        isAssignmentTarget = isBindingElement = false;

	        previousStrict = strict;
	        body = isolateCoverGrammar(parseFunctionSourceElements);

	        if (strict && paramInfo.firstRestricted) {
	            tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);
	        }
	        if (strict && paramInfo.stricted) {
	            tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);
	        }

	        strict = previousStrict;
	        return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body);
	    }

	    function parsePropertyMethodFunction() {
	        var params, method, node = new Node();

	        params = parseParams();
	        method = parsePropertyFunction(node, params);

	        return method;
	    }

	    function parseObjectPropertyKey() {
	        var token, node = new Node(), expr;

	        token = lex();

	        // Note: This function is called only from parseObjectProperty(), where
	        // EOF and Punctuator tokens are already filtered out.

	        switch (token.type) {
	        case Token.StringLiteral:
	        case Token.NumericLiteral:
	            if (strict && token.octal) {
	                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);
	            }
	            return node.finishLiteral(token);
	        case Token.Identifier:
	        case Token.BooleanLiteral:
	        case Token.NullLiteral:
	        case Token.Keyword:
	            return node.finishIdentifier(token.value);
	        case Token.Punctuator:
	            if (token.value === '[') {
	                expr = isolateCoverGrammar(parseAssignmentExpression);
	                expect(']');
	                return expr;
	            }
	            break;
	        }
	        throwUnexpectedToken(token);
	    }

	    function lookaheadPropertyName() {
	        switch (lookahead.type) {
	        case Token.Identifier:
	        case Token.StringLiteral:
	        case Token.BooleanLiteral:
	        case Token.NullLiteral:
	        case Token.NumericLiteral:
	        case Token.Keyword:
	            return true;
	        case Token.Punctuator:
	            return lookahead.value === '[';
	        }
	        return false;
	    }

	    // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,
	    // it might be called at a position where there is in fact a short hand identifier pattern or a data property.
	    // This can only be determined after we consumed up to the left parentheses.
	    //
	    // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller
	    // is responsible to visit other options.
	    function tryParseMethodDefinition(token, key, computed, node) {
	        var value, options, methodNode;

	        if (token.type === Token.Identifier) {
	            // check for `get` and `set`;

	            if (token.value === 'get' && lookaheadPropertyName()) {
	                computed = match('[');
	                key = parseObjectPropertyKey();
	                methodNode = new Node();
	                expect('(');
	                expect(')');
	                value = parsePropertyFunction(methodNode, {
	                    params: [],
	                    defaults: [],
	                    stricted: null,
	                    firstRestricted: null,
	                    message: null
	                });
	                return node.finishProperty('get', key, computed, value, false, false);
	            } else if (token.value === 'set' && lookaheadPropertyName()) {
	                computed = match('[');
	                key = parseObjectPropertyKey();
	                methodNode = new Node();
	                expect('(');

	                options = {
	                    params: [],
	                    defaultCount: 0,
	                    defaults: [],
	                    firstRestricted: null,
	                    paramSet: {}
	                };
	                if (match(')')) {
	                    tolerateUnexpectedToken(lookahead);
	                } else {
	                    parseParam(options);
	                    if (options.defaultCount === 0) {
	                        options.defaults = [];
	                    }
	                }
	                expect(')');

	                value = parsePropertyFunction(methodNode, options);
	                return node.finishProperty('set', key, computed, value, false, false);
	            }
	        }

	        if (match('(')) {
	            value = parsePropertyMethodFunction();
	            return node.finishProperty('init', key, computed, value, true, false);
	        }

	        // Not a MethodDefinition.
	        return null;
	    }

	    function checkProto(key, computed, hasProto) {
	        if (computed === false && (key.type === Syntax.Identifier && key.name === '__proto__' ||
	            key.type === Syntax.Literal && key.value === '__proto__')) {
	            if (hasProto.value) {
	                tolerateError(Messages.DuplicateProtoProperty);
	            } else {
	                hasProto.value = true;
	            }
	        }
	    }

	    function parseObjectProperty(hasProto) {
	        var token = lookahead, node = new Node(), computed, key, maybeMethod, value;

	        computed = match('[');
	        key = parseObjectPropertyKey();
	        maybeMethod = tryParseMethodDefinition(token, key, computed, node);

	        if (maybeMethod) {
	            checkProto(maybeMethod.key, maybeMethod.computed, hasProto);
	            // finished
	            return maybeMethod;
	        }

	        // init property or short hand property.
	        checkProto(key, computed, hasProto);

	        if (match(':')) {
	            lex();
	            value = inheritCoverGrammar(parseAssignmentExpression);
	            return node.finishProperty('init', key, computed, value, false, false);
	        }

	        if (token.type === Token.Identifier) {
	            if (match('=')) {
	                firstCoverInitializedNameError = lookahead;
	                lex();
	                value = isolateCoverGrammar(parseAssignmentExpression);
	                return node.finishProperty('init', key, computed,
	                    new WrappingNode(token).finishAssignmentPattern(key, value), false, true);
	            }
	            return node.finishProperty('init', key, computed, key, false, true);
	        }

	        throwUnexpectedToken(lookahead);
	    }

	    function parseObjectInitialiser() {
	        var properties = [], hasProto = {value: false}, node = new Node();

	        expect('{');

	        while (!match('}')) {
	            properties.push(parseObjectProperty(hasProto));

	            if (!match('}')) {
	                expectCommaSeparator();
	            }
	        }

	        expect('}');

	        return node.finishObjectExpression(properties);
	    }

	    function reinterpretExpressionAsPattern(expr) {
	        var i;
	        switch (expr.type) {
	        case Syntax.Identifier:
	        case Syntax.MemberExpression:
	        case Syntax.RestElement:
	        case Syntax.AssignmentPattern:
	            break;
	        case Syntax.SpreadElement:
	            expr.type = Syntax.RestElement;
	            reinterpretExpressionAsPattern(expr.argument);
	            break;
	        case Syntax.ArrayExpression:
	            expr.type = Syntax.ArrayPattern;
	            for (i = 0; i < expr.elements.length; i++) {
	                if (expr.elements[i] !== null) {
	                    reinterpretExpressionAsPattern(expr.elements[i]);
	                }
	            }
	            break;
	        case Syntax.ObjectExpression:
	            expr.type = Syntax.ObjectPattern;
	            for (i = 0; i < expr.properties.length; i++) {
	                reinterpretExpressionAsPattern(expr.properties[i].value);
	            }
	            break;
	        case Syntax.AssignmentExpression:
	            expr.type = Syntax.AssignmentPattern;
	            reinterpretExpressionAsPattern(expr.left);
	            break;
	        default:
	            // Allow other node type for tolerant parsing.
	            break;
	        }
	    }

	    function parseTemplateElement(option) {
	        var node, token;

	        if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {
	            throwUnexpectedToken();
	        }

	        node = new Node();
	        token = lex();

	        return node.finishTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail);
	    }

	    function parseTemplateLiteral() {
	        var quasi, quasis, expressions, node = new Node();

	        quasi = parseTemplateElement({ head: true });
	        quasis = [ quasi ];
	        expressions = [];

	        while (!quasi.tail) {
	            expressions.push(parseExpression());
	            quasi = parseTemplateElement({ head: false });
	            quasis.push(quasi);
	        }

	        return node.finishTemplateLiteral(quasis, expressions);
	    }

	    // 11.1.6 The Grouping Operator

	    function parseGroupExpression() {
	        var expr, expressions, startToken, i;

	        expect('(');

	        if (match(')')) {
	            lex();
	            if (!match('=>')) {
	                expect('=>');
	            }
	            return {
	                type: PlaceHolders.ArrowParameterPlaceHolder,
	                params: []
	            };
	        }

	        startToken = lookahead;
	        if (match('...')) {
	            expr = parseRestElement();
	            expect(')');
	            if (!match('=>')) {
	                expect('=>');
	            }
	            return {
	                type: PlaceHolders.ArrowParameterPlaceHolder,
	                params: [expr]
	            };
	        }

	        isBindingElement = true;
	        expr = inheritCoverGrammar(parseAssignmentExpression);

	        if (match(',')) {
	            isAssignmentTarget = false;
	            expressions = [expr];

	            while (startIndex < length) {
	                if (!match(',')) {
	                    break;
	                }
	                lex();

	                if (match('...')) {
	                    if (!isBindingElement) {
	                        throwUnexpectedToken(lookahead);
	                    }
	                    expressions.push(parseRestElement());
	                    expect(')');
	                    if (!match('=>')) {
	                        expect('=>');
	                    }
	                    isBindingElement = false;
	                    for (i = 0; i < expressions.length; i++) {
	                        reinterpretExpressionAsPattern(expressions[i]);
	                    }
	                    return {
	                        type: PlaceHolders.ArrowParameterPlaceHolder,
	                        params: expressions
	                    };
	                }

	                expressions.push(inheritCoverGrammar(parseAssignmentExpression));
	            }

	            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
	        }


	        expect(')');

	        if (match('=>')) {
	            if (!isBindingElement) {
	                throwUnexpectedToken(lookahead);
	            }

	            if (expr.type === Syntax.SequenceExpression) {
	                for (i = 0; i < expr.expressions.length; i++) {
	                    reinterpretExpressionAsPattern(expr.expressions[i]);
	                }
	            } else {
	                reinterpretExpressionAsPattern(expr);
	            }

	            expr = {
	                type: PlaceHolders.ArrowParameterPlaceHolder,
	                params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]
	            };
	        }
	        isBindingElement = false;
	        return expr;
	    }


	    // 11.1 Primary Expressions

	    function parsePrimaryExpression() {
	        var type, token, expr, node;

	        if (match('(')) {
	            isBindingElement = false;
	            return inheritCoverGrammar(parseGroupExpression);
	        }

	        if (match('[')) {
	            return inheritCoverGrammar(parseArrayInitialiser);
	        }

	        if (match('{')) {
	            return inheritCoverGrammar(parseObjectInitialiser);
	        }

	        type = lookahead.type;
	        node = new Node();

	        if (type === Token.Identifier) {
	            expr = node.finishIdentifier(lex().value);
	        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
	            isAssignmentTarget = isBindingElement = false;
	            if (strict && lookahead.octal) {
	                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);
	            }
	            expr = node.finishLiteral(lex());
	        } else if (type === Token.Keyword) {
	            isAssignmentTarget = isBindingElement = false;
	            if (matchKeyword('function')) {
	                return parseFunctionExpression();
	            }
	            if (matchKeyword('this')) {
	                lex();
	                return node.finishThisExpression();
	            }
	            if (matchKeyword('class')) {
	                return parseClassExpression();
	            }
	            throwUnexpectedToken(lex());
	        } else if (type === Token.BooleanLiteral) {
	            isAssignmentTarget = isBindingElement = false;
	            token = lex();
	            token.value = (token.value === 'true');
	            expr = node.finishLiteral(token);
	        } else if (type === Token.NullLiteral) {
	            isAssignmentTarget = isBindingElement = false;
	            token = lex();
	            token.value = null;
	            expr = node.finishLiteral(token);
	        } else if (match('/') || match('/=')) {
	            isAssignmentTarget = isBindingElement = false;
	            index = startIndex;

	            if (typeof extra.tokens !== 'undefined') {
	                token = collectRegex();
	            } else {
	                token = scanRegExp();
	            }
	            lex();
	            expr = node.finishLiteral(token);
	        } else if (type === Token.Template) {
	            expr = parseTemplateLiteral();
	        } else {
	            throwUnexpectedToken(lex());
	        }

	        return expr;
	    }

	    // 11.2 Left-Hand-Side Expressions

	    function parseArguments() {
	        var args = [];

	        expect('(');

	        if (!match(')')) {
	            while (startIndex < length) {
	                args.push(isolateCoverGrammar(parseAssignmentExpression));
	                if (match(')')) {
	                    break;
	                }
	                expectCommaSeparator();
	            }
	        }

	        expect(')');

	        return args;
	    }

	    function parseNonComputedProperty() {
	        var token, node = new Node();

	        token = lex();

	        if (!isIdentifierName(token)) {
	            throwUnexpectedToken(token);
	        }

	        return node.finishIdentifier(token.value);
	    }

	    function parseNonComputedMember() {
	        expect('.');

	        return parseNonComputedProperty();
	    }

	    function parseComputedMember() {
	        var expr;

	        expect('[');

	        expr = isolateCoverGrammar(parseExpression);

	        expect(']');

	        return expr;
	    }

	    function parseNewExpression() {
	        var callee, args, node = new Node();

	        expectKeyword('new');
	        callee = isolateCoverGrammar(parseLeftHandSideExpression);
	        args = match('(') ? parseArguments() : [];

	        isAssignmentTarget = isBindingElement = false;

	        return node.finishNewExpression(callee, args);
	    }

	    function parseLeftHandSideExpressionAllowCall() {
	        var quasi, expr, args, property, startToken, previousAllowIn = state.allowIn;

	        startToken = lookahead;
	        state.allowIn = true;

	        if (matchKeyword('super') && state.inFunctionBody) {
	            expr = new Node();
	            lex();
	            expr = expr.finishSuper();
	            if (!match('(') && !match('.') && !match('[')) {
	                throwUnexpectedToken(lookahead);
	            }
	        } else {
	            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
	        }

	        for (;;) {
	            if (match('.')) {
	                isBindingElement = false;
	                isAssignmentTarget = true;
	                property = parseNonComputedMember();
	                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
	            } else if (match('(')) {
	                isBindingElement = false;
	                isAssignmentTarget = false;
	                args = parseArguments();
	                expr = new WrappingNode(startToken).finishCallExpression(expr, args);
	            } else if (match('[')) {
	                isBindingElement = false;
	                isAssignmentTarget = true;
	                property = parseComputedMember();
	                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
	            } else if (lookahead.type === Token.Template && lookahead.head) {
	                quasi = parseTemplateLiteral();
	                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
	            } else {
	                break;
	            }
	        }
	        state.allowIn = previousAllowIn;

	        return expr;
	    }

	    function parseLeftHandSideExpression() {
	        var quasi, expr, property, startToken;
	        assert(state.allowIn, 'callee of new expression always allow in keyword.');

	        startToken = lookahead;

	        if (matchKeyword('super') && state.inFunctionBody) {
	            expr = new Node();
	            lex();
	            expr = expr.finishSuper();
	            if (!match('[') && !match('.')) {
	                throwUnexpectedToken(lookahead);
	            }
	        } else {
	            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
	        }

	        for (;;) {
	            if (match('[')) {
	                isBindingElement = false;
	                isAssignmentTarget = true;
	                property = parseComputedMember();
	                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
	            } else if (match('.')) {
	                isBindingElement = false;
	                isAssignmentTarget = true;
	                property = parseNonComputedMember();
	                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
	            } else if (lookahead.type === Token.Template && lookahead.head) {
	                quasi = parseTemplateLiteral();
	                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
	            } else {
	                break;
	            }
	        }
	        return expr;
	    }

	    // 11.3 Postfix Expressions

	    function parsePostfixExpression() {
	        var expr, token, startToken = lookahead;

	        expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);

	        if (!hasLineTerminator && lookahead.type === Token.Punctuator) {
	            if (match('++') || match('--')) {
	                // 11.3.1, 11.3.2
	                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
	                    tolerateError(Messages.StrictLHSPostfix);
	                }

	                if (!isAssignmentTarget) {
	                    tolerateError(Messages.InvalidLHSInAssignment);
	                }

	                isAssignmentTarget = isBindingElement = false;

	                token = lex();
	                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);
	            }
	        }

	        return expr;
	    }

	    // 11.4 Unary Operators

	    function parseUnaryExpression() {
	        var token, expr, startToken;

	        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
	            expr = parsePostfixExpression();
	        } else if (match('++') || match('--')) {
	            startToken = lookahead;
	            token = lex();
	            expr = inheritCoverGrammar(parseUnaryExpression);
	            // 11.4.4, 11.4.5
	            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
	                tolerateError(Messages.StrictLHSPrefix);
	            }

	            if (!isAssignmentTarget) {
	                tolerateError(Messages.InvalidLHSInAssignment);
	            }
	            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
	            isAssignmentTarget = isBindingElement = false;
	        } else if (match('+') || match('-') || match('~') || match('!')) {
	            startToken = lookahead;
	            token = lex();
	            expr = inheritCoverGrammar(parseUnaryExpression);
	            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
	            isAssignmentTarget = isBindingElement = false;
	        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
	            startToken = lookahead;
	            token = lex();
	            expr = inheritCoverGrammar(parseUnaryExpression);
	            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
	            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
	                tolerateError(Messages.StrictDelete);
	            }
	            isAssignmentTarget = isBindingElement = false;
	        } else {
	            expr = parsePostfixExpression();
	        }

	        return expr;
	    }

	    function binaryPrecedence(token, allowIn) {
	        var prec = 0;

	        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
	            return 0;
	        }

	        switch (token.value) {
	        case '||':
	            prec = 1;
	            break;

	        case '&&':
	            prec = 2;
	            break;

	        case '|':
	            prec = 3;
	            break;

	        case '^':
	            prec = 4;
	            break;

	        case '&':
	            prec = 5;
	            break;

	        case '==':
	        case '!=':
	        case '===':
	        case '!==':
	            prec = 6;
	            break;

	        case '<':
	        case '>':
	        case '<=':
	        case '>=':
	        case 'instanceof':
	            prec = 7;
	            break;

	        case 'in':
	            prec = allowIn ? 7 : 0;
	            break;

	        case '<<':
	        case '>>':
	        case '>>>':
	            prec = 8;
	            break;

	        case '+':
	        case '-':
	            prec = 9;
	            break;

	        case '*':
	        case '/':
	        case '%':
	            prec = 11;
	            break;

	        default:
	            break;
	        }

	        return prec;
	    }

	    // 11.5 Multiplicative Operators
	    // 11.6 Additive Operators
	    // 11.7 Bitwise Shift Operators
	    // 11.8 Relational Operators
	    // 11.9 Equality Operators
	    // 11.10 Binary Bitwise Operators
	    // 11.11 Binary Logical Operators

	    function parseBinaryExpression() {
	        var marker, markers, expr, token, prec, stack, right, operator, left, i;

	        marker = lookahead;
	        left = inheritCoverGrammar(parseUnaryExpression);

	        token = lookahead;
	        prec = binaryPrecedence(token, state.allowIn);
	        if (prec === 0) {
	            return left;
	        }
	        isAssignmentTarget = isBindingElement = false;
	        token.prec = prec;
	        lex();

	        markers = [marker, lookahead];
	        right = isolateCoverGrammar(parseUnaryExpression);

	        stack = [left, token, right];

	        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

	            // Reduce: make a binary expression from the three topmost entries.
	            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
	                right = stack.pop();
	                operator = stack.pop().value;
	                left = stack.pop();
	                markers.pop();
	                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
	                stack.push(expr);
	            }

	            // Shift.
	            token = lex();
	            token.prec = prec;
	            stack.push(token);
	            markers.push(lookahead);
	            expr = isolateCoverGrammar(parseUnaryExpression);
	            stack.push(expr);
	        }

	        // Final reduce to clean-up the stack.
	        i = stack.length - 1;
	        expr = stack[i];
	        markers.pop();
	        while (i > 1) {
	            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
	            i -= 2;
	        }

	        return expr;
	    }


	    // 11.12 Conditional Operator

	    function parseConditionalExpression() {
	        var expr, previousAllowIn, consequent, alternate, startToken;

	        startToken = lookahead;

	        expr = inheritCoverGrammar(parseBinaryExpression);
	        if (match('?')) {
	            lex();
	            previousAllowIn = state.allowIn;
	            state.allowIn = true;
	            consequent = isolateCoverGrammar(parseAssignmentExpression);
	            state.allowIn = previousAllowIn;
	            expect(':');
	            alternate = isolateCoverGrammar(parseAssignmentExpression);

	            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
	            isAssignmentTarget = isBindingElement = false;
	        }

	        return expr;
	    }

	    // [ES6] 14.2 Arrow Function

	    function parseConciseBody() {
	        if (match('{')) {
	            return parseFunctionSourceElements();
	        }
	        return isolateCoverGrammar(parseAssignmentExpression);
	    }

	    function checkPatternParam(options, param) {
	        var i;
	        switch (param.type) {
	        case Syntax.Identifier:
	            validateParam(options, param, param.name);
	            break;
	        case Syntax.RestElement:
	            checkPatternParam(options, param.argument);
	            break;
	        case Syntax.AssignmentPattern:
	            checkPatternParam(options, param.left);
	            break;
	        case Syntax.ArrayPattern:
	            for (i = 0; i < param.elements.length; i++) {
	                if (param.elements[i] !== null) {
	                    checkPatternParam(options, param.elements[i]);
	                }
	            }
	            break;
	        default:
	            assert(param.type === Syntax.ObjectPattern, 'Invalid type');
	            for (i = 0; i < param.properties.length; i++) {
	                checkPatternParam(options, param.properties[i].value);
	            }
	            break;
	        }
	    }
	    function reinterpretAsCoverFormalsList(expr) {
	        var i, len, param, params, defaults, defaultCount, options, token;

	        defaults = [];
	        defaultCount = 0;
	        params = [expr];

	        switch (expr.type) {
	        case Syntax.Identifier:
	            break;
	        case PlaceHolders.ArrowParameterPlaceHolder:
	            params = expr.params;
	            break;
	        default:
	            return null;
	        }

	        options = {
	            paramSet: {}
	        };

	        for (i = 0, len = params.length; i < len; i += 1) {
	            param = params[i];
	            switch (param.type) {
	            case Syntax.AssignmentPattern:
	                params[i] = param.left;
	                defaults.push(param.right);
	                ++defaultCount;
	                checkPatternParam(options, param.left);
	                break;
	            default:
	                checkPatternParam(options, param);
	                params[i] = param;
	                defaults.push(null);
	                break;
	            }
	        }

	        if (options.message === Messages.StrictParamDupe) {
	            token = strict ? options.stricted : options.firstRestricted;
	            throwUnexpectedToken(token, options.message);
	        }

	        if (defaultCount === 0) {
	            defaults = [];
	        }

	        return {
	            params: params,
	            defaults: defaults,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    }

	    function parseArrowFunctionExpression(options, node) {
	        var previousStrict, body;

	        if (hasLineTerminator) {
	            tolerateUnexpectedToken(lookahead);
	        }
	        expect('=>');
	        previousStrict = strict;

	        body = parseConciseBody();

	        if (strict && options.firstRestricted) {
	            throwUnexpectedToken(options.firstRestricted, options.message);
	        }
	        if (strict && options.stricted) {
	            tolerateUnexpectedToken(options.stricted, options.message);
	        }

	        strict = previousStrict;

	        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);
	    }

	    // 11.13 Assignment Operators

	    function parseAssignmentExpression() {
	        var token, expr, right, list, startToken;

	        startToken = lookahead;
	        token = lookahead;

	        expr = parseConditionalExpression();

	        if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {
	            isAssignmentTarget = isBindingElement = false;
	            list = reinterpretAsCoverFormalsList(expr);

	            if (list) {
	                firstCoverInitializedNameError = null;
	                return parseArrowFunctionExpression(list, new WrappingNode(startToken));
	            }

	            return expr;
	        }

	        if (matchAssign()) {
	            if (!isAssignmentTarget) {
	                tolerateError(Messages.InvalidLHSInAssignment);
	            }

	            // 11.13.1
	            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
	                tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);
	            }

	            if (!match('=')) {
	                isAssignmentTarget = isBindingElement = false;
	            } else {
	                reinterpretExpressionAsPattern(expr);
	            }

	            token = lex();
	            right = isolateCoverGrammar(parseAssignmentExpression);
	            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);
	            firstCoverInitializedNameError = null;
	        }

	        return expr;
	    }

	    // 11.14 Comma Operator

	    function parseExpression() {
	        var expr, startToken = lookahead, expressions;

	        expr = isolateCoverGrammar(parseAssignmentExpression);

	        if (match(',')) {
	            expressions = [expr];

	            while (startIndex < length) {
	                if (!match(',')) {
	                    break;
	                }
	                lex();
	                expressions.push(isolateCoverGrammar(parseAssignmentExpression));
	            }

	            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
	        }

	        return expr;
	    }

	    // 12.1 Block

	    function parseStatementListItem() {
	        if (lookahead.type === Token.Keyword) {
	            switch (lookahead.value) {
	            case 'export':
	                if (sourceType !== 'module') {
	                    tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);
	                }
	                return parseExportDeclaration();
	            case 'import':
	                if (sourceType !== 'module') {
	                    tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);
	                }
	                return parseImportDeclaration();
	            case 'const':
	            case 'let':
	                return parseLexicalDeclaration({inFor: false});
	            case 'function':
	                return parseFunctionDeclaration(new Node());
	            case 'class':
	                return parseClassDeclaration();
	            }
	        }

	        return parseStatement();
	    }

	    function parseStatementList() {
	        var list = [];
	        while (startIndex < length) {
	            if (match('}')) {
	                break;
	            }
	            list.push(parseStatementListItem());
	        }

	        return list;
	    }

	    function parseBlock() {
	        var block, node = new Node();

	        expect('{');

	        block = parseStatementList();

	        expect('}');

	        return node.finishBlockStatement(block);
	    }

	    // 12.2 Variable Statement

	    function parseVariableIdentifier() {
	        var token, node = new Node();

	        token = lex();

	        if (token.type !== Token.Identifier) {
	            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {
	                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
	            } else {
	                throwUnexpectedToken(token);
	            }
	        }

	        return node.finishIdentifier(token.value);
	    }

	    function parseVariableDeclaration() {
	        var init = null, id, node = new Node();

	        id = parsePattern();

	        // 12.2.1
	        if (strict && isRestrictedWord(id.name)) {
	            tolerateError(Messages.StrictVarName);
	        }

	        if (match('=')) {
	            lex();
	            init = isolateCoverGrammar(parseAssignmentExpression);
	        } else if (id.type !== Syntax.Identifier) {
	            expect('=');
	        }

	        return node.finishVariableDeclarator(id, init);
	    }

	    function parseVariableDeclarationList() {
	        var list = [];

	        do {
	            list.push(parseVariableDeclaration());
	            if (!match(',')) {
	                break;
	            }
	            lex();
	        } while (startIndex < length);

	        return list;
	    }

	    function parseVariableStatement(node) {
	        var declarations;

	        expectKeyword('var');

	        declarations = parseVariableDeclarationList();

	        consumeSemicolon();

	        return node.finishVariableDeclaration(declarations);
	    }

	    function parseLexicalBinding(kind, options) {
	        var init = null, id, node = new Node();

	        id = parsePattern();

	        // 12.2.1
	        if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {
	            tolerateError(Messages.StrictVarName);
	        }

	        if (kind === 'const') {
	            if (!matchKeyword('in')) {
	                expect('=');
	                init = isolateCoverGrammar(parseAssignmentExpression);
	            }
	        } else if ((!options.inFor && id.type !== Syntax.Identifier) || match('=')) {
	            expect('=');
	            init = isolateCoverGrammar(parseAssignmentExpression);
	        }

	        return node.finishVariableDeclarator(id, init);
	    }

	    function parseBindingList(kind, options) {
	        var list = [];

	        do {
	            list.push(parseLexicalBinding(kind, options));
	            if (!match(',')) {
	                break;
	            }
	            lex();
	        } while (startIndex < length);

	        return list;
	    }

	    function parseLexicalDeclaration(options) {
	        var kind, declarations, node = new Node();

	        kind = lex().value;
	        assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');

	        declarations = parseBindingList(kind, options);

	        consumeSemicolon();

	        return node.finishLexicalDeclaration(declarations, kind);
	    }

	    function parseRestElement() {
	        var param, node = new Node();

	        lex();

	        if (match('{')) {
	            throwError(Messages.ObjectPatternAsRestParameter);
	        }

	        param = parseVariableIdentifier();

	        if (match('=')) {
	            throwError(Messages.DefaultRestParameter);
	        }

	        if (!match(')')) {
	            throwError(Messages.ParameterAfterRestParameter);
	        }

	        return node.finishRestElement(param);
	    }

	    // 12.3 Empty Statement

	    function parseEmptyStatement(node) {
	        expect(';');
	        return node.finishEmptyStatement();
	    }

	    // 12.4 Expression Statement

	    function parseExpressionStatement(node) {
	        var expr = parseExpression();
	        consumeSemicolon();
	        return node.finishExpressionStatement(expr);
	    }

	    // 12.5 If statement

	    function parseIfStatement(node) {
	        var test, consequent, alternate;

	        expectKeyword('if');

	        expect('(');

	        test = parseExpression();

	        expect(')');

	        consequent = parseStatement();

	        if (matchKeyword('else')) {
	            lex();
	            alternate = parseStatement();
	        } else {
	            alternate = null;
	        }

	        return node.finishIfStatement(test, consequent, alternate);
	    }

	    // 12.6 Iteration Statements

	    function parseDoWhileStatement(node) {
	        var body, test, oldInIteration;

	        expectKeyword('do');

	        oldInIteration = state.inIteration;
	        state.inIteration = true;

	        body = parseStatement();

	        state.inIteration = oldInIteration;

	        expectKeyword('while');

	        expect('(');

	        test = parseExpression();

	        expect(')');

	        if (match(';')) {
	            lex();
	        }

	        return node.finishDoWhileStatement(body, test);
	    }

	    function parseWhileStatement(node) {
	        var test, body, oldInIteration;

	        expectKeyword('while');

	        expect('(');

	        test = parseExpression();

	        expect(')');

	        oldInIteration = state.inIteration;
	        state.inIteration = true;

	        body = parseStatement();

	        state.inIteration = oldInIteration;

	        return node.finishWhileStatement(test, body);
	    }

	    function parseForStatement(node) {
	        var init, initSeq, initStartToken, test, update, left, right, kind, declarations,
	            body, oldInIteration, previousAllowIn = state.allowIn;

	        init = test = update = null;

	        expectKeyword('for');

	        expect('(');

	        if (match(';')) {
	            lex();
	        } else {
	            if (matchKeyword('var')) {
	                init = new Node();
	                lex();

	                state.allowIn = false;
	                init = init.finishVariableDeclaration(parseVariableDeclarationList());
	                state.allowIn = previousAllowIn;

	                if (init.declarations.length === 1 && matchKeyword('in')) {
	                    lex();
	                    left = init;
	                    right = parseExpression();
	                    init = null;
	                } else {
	                    expect(';');
	                }
	            } else if (matchKeyword('const') || matchKeyword('let')) {
	                init = new Node();
	                kind = lex().value;

	                state.allowIn = false;
	                declarations = parseBindingList(kind, {inFor: true});
	                state.allowIn = previousAllowIn;

	                if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {
	                    init = init.finishLexicalDeclaration(declarations, kind);
	                    lex();
	                    left = init;
	                    right = parseExpression();
	                    init = null;
	                } else {
	                    consumeSemicolon();
	                    init = init.finishLexicalDeclaration(declarations, kind);
	                }
	            } else {
	                initStartToken = lookahead;
	                state.allowIn = false;
	                init = inheritCoverGrammar(parseAssignmentExpression);
	                state.allowIn = previousAllowIn;

	                if (matchKeyword('in')) {
	                    if (!isAssignmentTarget) {
	                        tolerateError(Messages.InvalidLHSInForIn);
	                    }

	                    lex();
	                    reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = parseExpression();
	                    init = null;
	                } else {
	                    if (match(',')) {
	                        initSeq = [init];
	                        while (match(',')) {
	                            lex();
	                            initSeq.push(isolateCoverGrammar(parseAssignmentExpression));
	                        }
	                        init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);
	                    }
	                    expect(';');
	                }
	            }
	        }

	        if (typeof left === 'undefined') {

	            if (!match(';')) {
	                test = parseExpression();
	            }
	            expect(';');

	            if (!match(')')) {
	                update = parseExpression();
	            }
	        }

	        expect(')');

	        oldInIteration = state.inIteration;
	        state.inIteration = true;

	        body = isolateCoverGrammar(parseStatement);

	        state.inIteration = oldInIteration;

	        return (typeof left === 'undefined') ?
	                node.finishForStatement(init, test, update, body) :
	                node.finishForInStatement(left, right, body);
	    }

	    // 12.7 The continue statement

	    function parseContinueStatement(node) {
	        var label = null, key;

	        expectKeyword('continue');

	        // Optimize the most common form: 'continue;'.
	        if (source.charCodeAt(startIndex) === 0x3B) {
	            lex();

	            if (!state.inIteration) {
	                throwError(Messages.IllegalContinue);
	            }

	            return node.finishContinueStatement(null);
	        }

	        if (hasLineTerminator) {
	            if (!state.inIteration) {
	                throwError(Messages.IllegalContinue);
	            }

	            return node.finishContinueStatement(null);
	        }

	        if (lookahead.type === Token.Identifier) {
	            label = parseVariableIdentifier();

	            key = '$' + label.name;
	            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError(Messages.UnknownLabel, label.name);
	            }
	        }

	        consumeSemicolon();

	        if (label === null && !state.inIteration) {
	            throwError(Messages.IllegalContinue);
	        }

	        return node.finishContinueStatement(label);
	    }

	    // 12.8 The break statement

	    function parseBreakStatement(node) {
	        var label = null, key;

	        expectKeyword('break');

	        // Catch the very common case first: immediately a semicolon (U+003B).
	        if (source.charCodeAt(lastIndex) === 0x3B) {
	            lex();

	            if (!(state.inIteration || state.inSwitch)) {
	                throwError(Messages.IllegalBreak);
	            }

	            return node.finishBreakStatement(null);
	        }

	        if (hasLineTerminator) {
	            if (!(state.inIteration || state.inSwitch)) {
	                throwError(Messages.IllegalBreak);
	            }

	            return node.finishBreakStatement(null);
	        }

	        if (lookahead.type === Token.Identifier) {
	            label = parseVariableIdentifier();

	            key = '$' + label.name;
	            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError(Messages.UnknownLabel, label.name);
	            }
	        }

	        consumeSemicolon();

	        if (label === null && !(state.inIteration || state.inSwitch)) {
	            throwError(Messages.IllegalBreak);
	        }

	        return node.finishBreakStatement(label);
	    }

	    // 12.9 The return statement

	    function parseReturnStatement(node) {
	        var argument = null;

	        expectKeyword('return');

	        if (!state.inFunctionBody) {
	            tolerateError(Messages.IllegalReturn);
	        }

	        // 'return' followed by a space and an identifier is very common.
	        if (source.charCodeAt(lastIndex) === 0x20) {
	            if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {
	                argument = parseExpression();
	                consumeSemicolon();
	                return node.finishReturnStatement(argument);
	            }
	        }

	        if (hasLineTerminator) {
	            // HACK
	            return node.finishReturnStatement(null);
	        }

	        if (!match(';')) {
	            if (!match('}') && lookahead.type !== Token.EOF) {
	                argument = parseExpression();
	            }
	        }

	        consumeSemicolon();

	        return node.finishReturnStatement(argument);
	    }

	    // 12.10 The with statement

	    function parseWithStatement(node) {
	        var object, body;

	        if (strict) {
	            tolerateError(Messages.StrictModeWith);
	        }

	        expectKeyword('with');

	        expect('(');

	        object = parseExpression();

	        expect(')');

	        body = parseStatement();

	        return node.finishWithStatement(object, body);
	    }

	    // 12.10 The swith statement

	    function parseSwitchCase() {
	        var test, consequent = [], statement, node = new Node();

	        if (matchKeyword('default')) {
	            lex();
	            test = null;
	        } else {
	            expectKeyword('case');
	            test = parseExpression();
	        }
	        expect(':');

	        while (startIndex < length) {
	            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
	                break;
	            }
	            statement = parseStatementListItem();
	            consequent.push(statement);
	        }

	        return node.finishSwitchCase(test, consequent);
	    }

	    function parseSwitchStatement(node) {
	        var discriminant, cases, clause, oldInSwitch, defaultFound;

	        expectKeyword('switch');

	        expect('(');

	        discriminant = parseExpression();

	        expect(')');

	        expect('{');

	        cases = [];

	        if (match('}')) {
	            lex();
	            return node.finishSwitchStatement(discriminant, cases);
	        }

	        oldInSwitch = state.inSwitch;
	        state.inSwitch = true;
	        defaultFound = false;

	        while (startIndex < length) {
	            if (match('}')) {
	                break;
	            }
	            clause = parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    throwError(Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }

	        state.inSwitch = oldInSwitch;

	        expect('}');

	        return node.finishSwitchStatement(discriminant, cases);
	    }

	    // 12.13 The throw statement

	    function parseThrowStatement(node) {
	        var argument;

	        expectKeyword('throw');

	        if (hasLineTerminator) {
	            throwError(Messages.NewlineAfterThrow);
	        }

	        argument = parseExpression();

	        consumeSemicolon();

	        return node.finishThrowStatement(argument);
	    }

	    // 12.14 The try statement

	    function parseCatchClause() {
	        var param, body, node = new Node();

	        expectKeyword('catch');

	        expect('(');
	        if (match(')')) {
	            throwUnexpectedToken(lookahead);
	        }

	        param = parsePattern();

	        // 12.14.1
	        if (strict && isRestrictedWord(param.name)) {
	            tolerateError(Messages.StrictCatchVariable);
	        }

	        expect(')');
	        body = parseBlock();
	        return node.finishCatchClause(param, body);
	    }

	    function parseTryStatement(node) {
	        var block, handler = null, finalizer = null;

	        expectKeyword('try');

	        block = parseBlock();

	        if (matchKeyword('catch')) {
	            handler = parseCatchClause();
	        }

	        if (matchKeyword('finally')) {
	            lex();
	            finalizer = parseBlock();
	        }

	        if (!handler && !finalizer) {
	            throwError(Messages.NoCatchOrFinally);
	        }

	        return node.finishTryStatement(block, handler, finalizer);
	    }

	    // 12.15 The debugger statement

	    function parseDebuggerStatement(node) {
	        expectKeyword('debugger');

	        consumeSemicolon();

	        return node.finishDebuggerStatement();
	    }

	    // 12 Statements

	    function parseStatement() {
	        var type = lookahead.type,
	            expr,
	            labeledBody,
	            key,
	            node;

	        if (type === Token.EOF) {
	            throwUnexpectedToken(lookahead);
	        }

	        if (type === Token.Punctuator && lookahead.value === '{') {
	            return parseBlock();
	        }
	        isAssignmentTarget = isBindingElement = true;
	        node = new Node();

	        if (type === Token.Punctuator) {
	            switch (lookahead.value) {
	            case ';':
	                return parseEmptyStatement(node);
	            case '(':
	                return parseExpressionStatement(node);
	            default:
	                break;
	            }
	        } else if (type === Token.Keyword) {
	            switch (lookahead.value) {
	            case 'break':
	                return parseBreakStatement(node);
	            case 'continue':
	                return parseContinueStatement(node);
	            case 'debugger':
	                return parseDebuggerStatement(node);
	            case 'do':
	                return parseDoWhileStatement(node);
	            case 'for':
	                return parseForStatement(node);
	            case 'function':
	                return parseFunctionDeclaration(node);
	            case 'if':
	                return parseIfStatement(node);
	            case 'return':
	                return parseReturnStatement(node);
	            case 'switch':
	                return parseSwitchStatement(node);
	            case 'throw':
	                return parseThrowStatement(node);
	            case 'try':
	                return parseTryStatement(node);
	            case 'var':
	                return parseVariableStatement(node);
	            case 'while':
	                return parseWhileStatement(node);
	            case 'with':
	                return parseWithStatement(node);
	            default:
	                break;
	            }
	        }

	        expr = parseExpression();

	        // 12.12 Labelled Statements
	        if ((expr.type === Syntax.Identifier) && match(':')) {
	            lex();

	            key = '$' + expr.name;
	            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError(Messages.Redeclaration, 'Label', expr.name);
	            }

	            state.labelSet[key] = true;
	            labeledBody = parseStatement();
	            delete state.labelSet[key];
	            return node.finishLabeledStatement(expr, labeledBody);
	        }

	        consumeSemicolon();

	        return node.finishExpressionStatement(expr);
	    }

	    // 13 Function Definition

	    function parseFunctionSourceElements() {
	        var statement, body = [], token, directive, firstRestricted,
	            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesisCount,
	            node = new Node();

	        expect('{');

	        while (startIndex < length) {
	            if (lookahead.type !== Token.StringLiteral) {
	                break;
	            }
	            token = lookahead;

	            statement = parseStatementListItem();
	            body.push(statement);
	            if (statement.expression.type !== Syntax.Literal) {
	                // this is not directive
	                break;
	            }
	            directive = source.slice(token.start + 1, token.end - 1);
	            if (directive === 'use strict') {
	                strict = true;
	                if (firstRestricted) {
	                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
	                }
	            } else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }

	        oldLabelSet = state.labelSet;
	        oldInIteration = state.inIteration;
	        oldInSwitch = state.inSwitch;
	        oldInFunctionBody = state.inFunctionBody;
	        oldParenthesisCount = state.parenthesizedCount;

	        state.labelSet = {};
	        state.inIteration = false;
	        state.inSwitch = false;
	        state.inFunctionBody = true;
	        state.parenthesizedCount = 0;

	        while (startIndex < length) {
	            if (match('}')) {
	                break;
	            }
	            body.push(parseStatementListItem());
	        }

	        expect('}');

	        state.labelSet = oldLabelSet;
	        state.inIteration = oldInIteration;
	        state.inSwitch = oldInSwitch;
	        state.inFunctionBody = oldInFunctionBody;
	        state.parenthesizedCount = oldParenthesisCount;

	        return node.finishBlockStatement(body);
	    }

	    function validateParam(options, param, name) {
	        var key = '$' + name;
	        if (strict) {
	            if (isRestrictedWord(name)) {
	                options.stricted = param;
	                options.message = Messages.StrictParamName;
	            }
	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = Messages.StrictParamDupe;
	            }
	        } else if (!options.firstRestricted) {
	            if (isRestrictedWord(name)) {
	                options.firstRestricted = param;
	                options.message = Messages.StrictParamName;
	            } else if (isStrictModeReservedWord(name)) {
	                options.firstRestricted = param;
	                options.message = Messages.StrictReservedWord;
	            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.firstRestricted = param;
	                options.message = Messages.StrictParamDupe;
	            }
	        }
	        options.paramSet[key] = true;
	    }

	    function parseParam(options) {
	        var token, param, def;

	        token = lookahead;
	        if (token.value === '...') {
	            param = parseRestElement();
	            validateParam(options, param.argument, param.argument.name);
	            options.params.push(param);
	            options.defaults.push(null);
	            return false;
	        }

	        param = parsePatternWithDefault();
	        validateParam(options, token, token.value);

	        if (param.type === Syntax.AssignmentPattern) {
	            def = param.right;
	            param = param.left;
	            ++options.defaultCount;
	        }

	        options.params.push(param);
	        options.defaults.push(def);

	        return !match(')');
	    }

	    function parseParams(firstRestricted) {
	        var options;

	        options = {
	            params: [],
	            defaultCount: 0,
	            defaults: [],
	            firstRestricted: firstRestricted
	        };

	        expect('(');

	        if (!match(')')) {
	            options.paramSet = {};
	            while (startIndex < length) {
	                if (!parseParam(options)) {
	                    break;
	                }
	                expect(',');
	            }
	        }

	        expect(')');

	        if (options.defaultCount === 0) {
	            options.defaults = [];
	        }

	        return {
	            params: options.params,
	            defaults: options.defaults,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    }

	    function parseFunctionDeclaration(node, identifierIsOptional) {
	        var id = null, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict;

	        expectKeyword('function');
	        if (!identifierIsOptional || !match('(')) {
	            token = lookahead;
	            id = parseVariableIdentifier();
	            if (strict) {
	                if (isRestrictedWord(token.value)) {
	                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
	                }
	            } else {
	                if (isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictFunctionName;
	                } else if (isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictReservedWord;
	                }
	            }
	        }

	        tmp = parseParams(firstRestricted);
	        params = tmp.params;
	        defaults = tmp.defaults;
	        stricted = tmp.stricted;
	        firstRestricted = tmp.firstRestricted;
	        if (tmp.message) {
	            message = tmp.message;
	        }

	        previousStrict = strict;
	        body = parseFunctionSourceElements();
	        if (strict && firstRestricted) {
	            throwUnexpectedToken(firstRestricted, message);
	        }
	        if (strict && stricted) {
	            tolerateUnexpectedToken(stricted, message);
	        }
	        strict = previousStrict;

	        return node.finishFunctionDeclaration(id, params, defaults, body);
	    }

	    function parseFunctionExpression() {
	        var token, id = null, stricted, firstRestricted, message, tmp,
	            params = [], defaults = [], body, previousStrict, node = new Node();

	        expectKeyword('function');

	        if (!match('(')) {
	            token = lookahead;
	            id = parseVariableIdentifier();
	            if (strict) {
	                if (isRestrictedWord(token.value)) {
	                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
	                }
	            } else {
	                if (isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictFunctionName;
	                } else if (isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictReservedWord;
	                }
	            }
	        }

	        tmp = parseParams(firstRestricted);
	        params = tmp.params;
	        defaults = tmp.defaults;
	        stricted = tmp.stricted;
	        firstRestricted = tmp.firstRestricted;
	        if (tmp.message) {
	            message = tmp.message;
	        }

	        previousStrict = strict;
	        body = parseFunctionSourceElements();
	        if (strict && firstRestricted) {
	            throwUnexpectedToken(firstRestricted, message);
	        }
	        if (strict && stricted) {
	            tolerateUnexpectedToken(stricted, message);
	        }
	        strict = previousStrict;

	        return node.finishFunctionExpression(id, params, defaults, body);
	    }


	    function parseClassBody() {
	        var classBody, token, isStatic, hasConstructor = false, body, method, computed, key;

	        classBody = new Node();

	        expect('{');
	        body = [];
	        while (!match('}')) {
	            if (match(';')) {
	                lex();
	            } else {
	                method = new Node();
	                token = lookahead;
	                isStatic = false;
	                computed = match('[');
	                key = parseObjectPropertyKey();
	                if (key.name === 'static' && lookaheadPropertyName()) {
	                    token = lookahead;
	                    isStatic = true;
	                    computed = match('[');
	                    key = parseObjectPropertyKey();
	                }
	                method = tryParseMethodDefinition(token, key, computed, method);
	                if (method) {
	                    method['static'] = isStatic;
	                    if (method.kind === 'init') {
	                        method.kind = 'method';
	                    }
	                    if (!isStatic) {
	                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {
	                            if (method.kind !== 'method' || !method.method || method.value.generator) {
	                                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);
	                            }
	                            if (hasConstructor) {
	                                throwUnexpectedToken(token, Messages.DuplicateConstructor);
	                            } else {
	                                hasConstructor = true;
	                            }
	                            method.kind = 'constructor';
	                        }
	                    } else {
	                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {
	                            throwUnexpectedToken(token, Messages.StaticPrototype);
	                        }
	                    }
	                    method.type = Syntax.MethodDefinition;
	                    delete method.method;
	                    delete method.shorthand;
	                    body.push(method);
	                } else {
	                    throwUnexpectedToken(lookahead);
	                }
	            }
	        }
	        lex();
	        return classBody.finishClassBody(body);
	    }

	    function parseClassDeclaration(identifierIsOptional) {
	        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
	        strict = true;

	        expectKeyword('class');

	        if (!identifierIsOptional || lookahead.type === Token.Identifier) {
	            id = parseVariableIdentifier();
	        }

	        if (matchKeyword('extends')) {
	            lex();
	            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
	        }
	        classBody = parseClassBody();
	        strict = previousStrict;

	        return classNode.finishClassDeclaration(id, superClass, classBody);
	    }

	    function parseClassExpression() {
	        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
	        strict = true;

	        expectKeyword('class');

	        if (lookahead.type === Token.Identifier) {
	            id = parseVariableIdentifier();
	        }

	        if (matchKeyword('extends')) {
	            lex();
	            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
	        }
	        classBody = parseClassBody();
	        strict = previousStrict;

	        return classNode.finishClassExpression(id, superClass, classBody);
	    }

	    // Modules grammar from:
	    // people.mozilla.org/~jorendorff/es6-draft.html

	    function parseModuleSpecifier() {
	        var node = new Node();

	        if (lookahead.type !== Token.StringLiteral) {
	            throwError(Messages.InvalidModuleSpecifier);
	        }
	        return node.finishLiteral(lex());
	    }

	    function parseExportSpecifier() {
	        var exported, local, node = new Node(), def;
	        if (matchKeyword('default')) {
	            // export {default} from 'something';
	            def = new Node();
	            lex();
	            local = def.finishIdentifier('default');
	        } else {
	            local = parseVariableIdentifier();
	        }
	        if (matchContextualKeyword('as')) {
	            lex();
	            exported = parseNonComputedProperty();
	        }
	        return node.finishExportSpecifier(local, exported);
	    }

	    function parseExportNamedDeclaration(node) {
	        var declaration = null,
	            isExportFromIdentifier,
	            src = null, specifiers = [];

	        // non-default export
	        if (lookahead.type === Token.Keyword) {
	            // covers:
	            // export var f = 1;
	            switch (lookahead.value) {
	                case 'let':
	                case 'const':
	                case 'var':
	                case 'class':
	                case 'function':
	                    declaration = parseStatementListItem();
	                    return node.finishExportNamedDeclaration(declaration, specifiers, null);
	            }
	        }

	        expect('{');
	        if (!match('}')) {
	            do {
	                isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');
	                specifiers.push(parseExportSpecifier());
	            } while (match(',') && lex());
	        }
	        expect('}');

	        if (matchContextualKeyword('from')) {
	            // covering:
	            // export {default} from 'foo';
	            // export {foo} from 'foo';
	            lex();
	            src = parseModuleSpecifier();
	            consumeSemicolon();
	        } else if (isExportFromIdentifier) {
	            // covering:
	            // export {default}; // missing fromClause
	            throwError(lookahead.value ?
	                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
	        } else {
	            // cover
	            // export {foo};
	            consumeSemicolon();
	        }
	        return node.finishExportNamedDeclaration(declaration, specifiers, src);
	    }

	    function parseExportDefaultDeclaration(node) {
	        var declaration = null,
	            expression = null;

	        // covers:
	        // export default ...
	        expectKeyword('default');

	        if (matchKeyword('function')) {
	            // covers:
	            // export default function foo () {}
	            // export default function () {}
	            declaration = parseFunctionDeclaration(new Node(), true);
	            return node.finishExportDefaultDeclaration(declaration);
	        }
	        if (matchKeyword('class')) {
	            declaration = parseClassDeclaration(true);
	            return node.finishExportDefaultDeclaration(declaration);
	        }

	        if (matchContextualKeyword('from')) {
	            throwError(Messages.UnexpectedToken, lookahead.value);
	        }

	        // covers:
	        // export default {};
	        // export default [];
	        // export default (1 + 2);
	        if (match('{')) {
	            expression = parseObjectInitialiser();
	        } else if (match('[')) {
	            expression = parseArrayInitialiser();
	        } else {
	            expression = parseAssignmentExpression();
	        }
	        consumeSemicolon();
	        return node.finishExportDefaultDeclaration(expression);
	    }

	    function parseExportAllDeclaration(node) {
	        var src;

	        // covers:
	        // export * from 'foo';
	        expect('*');
	        if (!matchContextualKeyword('from')) {
	            throwError(lookahead.value ?
	                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
	        }
	        lex();
	        src = parseModuleSpecifier();
	        consumeSemicolon();

	        return node.finishExportAllDeclaration(src);
	    }

	    function parseExportDeclaration() {
	        var node = new Node();
	        if (state.inFunctionBody) {
	            throwError(Messages.IllegalExportDeclaration);
	        }

	        expectKeyword('export');

	        if (matchKeyword('default')) {
	            return parseExportDefaultDeclaration(node);
	        }
	        if (match('*')) {
	            return parseExportAllDeclaration(node);
	        }
	        return parseExportNamedDeclaration(node);
	    }

	    function parseImportSpecifier() {
	        // import {<foo as bar>} ...;
	        var local, imported, node = new Node();

	        imported = parseNonComputedProperty();
	        if (matchContextualKeyword('as')) {
	            lex();
	            local = parseVariableIdentifier();
	        }

	        return node.finishImportSpecifier(local, imported);
	    }

	    function parseNamedImports() {
	        var specifiers = [];
	        // {foo, bar as bas}
	        expect('{');
	        if (!match('}')) {
	            do {
	                specifiers.push(parseImportSpecifier());
	            } while (match(',') && lex());
	        }
	        expect('}');
	        return specifiers;
	    }

	    function parseImportDefaultSpecifier() {
	        // import <foo> ...;
	        var local, node = new Node();

	        local = parseNonComputedProperty();

	        return node.finishImportDefaultSpecifier(local);
	    }

	    function parseImportNamespaceSpecifier() {
	        // import <* as foo> ...;
	        var local, node = new Node();

	        expect('*');
	        if (!matchContextualKeyword('as')) {
	            throwError(Messages.NoAsAfterImportNamespace);
	        }
	        lex();
	        local = parseNonComputedProperty();

	        return node.finishImportNamespaceSpecifier(local);
	    }

	    function parseImportDeclaration() {
	        var specifiers, src, node = new Node();

	        if (state.inFunctionBody) {
	            throwError(Messages.IllegalImportDeclaration);
	        }

	        expectKeyword('import');
	        specifiers = [];

	        if (lookahead.type === Token.StringLiteral) {
	            // covers:
	            // import 'foo';
	            src = parseModuleSpecifier();
	            consumeSemicolon();
	            return node.finishImportDeclaration(specifiers, src);
	        }

	        if (!matchKeyword('default') && isIdentifierName(lookahead)) {
	            // covers:
	            // import foo
	            // import foo, ...
	            specifiers.push(parseImportDefaultSpecifier());
	            if (match(',')) {
	                lex();
	            }
	        }
	        if (match('*')) {
	            // covers:
	            // import foo, * as foo
	            // import * as foo
	            specifiers.push(parseImportNamespaceSpecifier());
	        } else if (match('{')) {
	            // covers:
	            // import foo, {bar}
	            // import {bar}
	            specifiers = specifiers.concat(parseNamedImports());
	        }

	        if (!matchContextualKeyword('from')) {
	            throwError(lookahead.value ?
	                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
	        }
	        lex();
	        src = parseModuleSpecifier();
	        consumeSemicolon();

	        return node.finishImportDeclaration(specifiers, src);
	    }

	    // 14 Program

	    function parseScriptBody() {
	        var statement, body = [], token, directive, firstRestricted;

	        while (startIndex < length) {
	            token = lookahead;
	            if (token.type !== Token.StringLiteral) {
	                break;
	            }

	            statement = parseStatementListItem();
	            body.push(statement);
	            if (statement.expression.type !== Syntax.Literal) {
	                // this is not directive
	                break;
	            }
	            directive = source.slice(token.start + 1, token.end - 1);
	            if (directive === 'use strict') {
	                strict = true;
	                if (firstRestricted) {
	                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
	                }
	            } else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }

	        while (startIndex < length) {
	            statement = parseStatementListItem();
	            /* istanbul ignore if */
	            if (typeof statement === 'undefined') {
	                break;
	            }
	            body.push(statement);
	        }
	        return body;
	    }

	    function parseProgram() {
	        var body, node;

	        peek();
	        node = new Node();

	        body = parseScriptBody();
	        return node.finishProgram(body);
	    }

	    function filterTokenLocation() {
	        var i, entry, token, tokens = [];

	        for (i = 0; i < extra.tokens.length; ++i) {
	            entry = extra.tokens[i];
	            token = {
	                type: entry.type,
	                value: entry.value
	            };
	            if (entry.regex) {
	                token.regex = {
	                    pattern: entry.regex.pattern,
	                    flags: entry.regex.flags
	                };
	            }
	            if (extra.range) {
	                token.range = entry.range;
	            }
	            if (extra.loc) {
	                token.loc = entry.loc;
	            }
	            tokens.push(token);
	        }

	        extra.tokens = tokens;
	    }

	    function tokenize(code, options) {
	        var toString,
	            tokens;

	        toString = String;
	        if (typeof code !== 'string' && !(code instanceof String)) {
	            code = toString(code);
	        }

	        source = code;
	        index = 0;
	        lineNumber = (source.length > 0) ? 1 : 0;
	        lineStart = 0;
	        startIndex = index;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;
	        length = source.length;
	        lookahead = null;
	        state = {
	            allowIn: true,
	            labelSet: {},
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            lastCommentStart: -1,
	            curlyStack: []
	        };

	        extra = {};

	        // Options matching.
	        options = options || {};

	        // Of course we collect tokens here.
	        options.tokens = true;
	        extra.tokens = [];
	        extra.tokenize = true;
	        // The following two fields are necessary to compute the Regex tokens.
	        extra.openParenToken = -1;
	        extra.openCurlyToken = -1;

	        extra.range = (typeof options.range === 'boolean') && options.range;
	        extra.loc = (typeof options.loc === 'boolean') && options.loc;

	        if (typeof options.comment === 'boolean' && options.comment) {
	            extra.comments = [];
	        }
	        if (typeof options.tolerant === 'boolean' && options.tolerant) {
	            extra.errors = [];
	        }

	        try {
	            peek();
	            if (lookahead.type === Token.EOF) {
	                return extra.tokens;
	            }

	            lex();
	            while (lookahead.type !== Token.EOF) {
	                try {
	                    lex();
	                } catch (lexError) {
	                    if (extra.errors) {
	                        recordError(lexError);
	                        // We have to break on the first error
	                        // to avoid infinite loops.
	                        break;
	                    } else {
	                        throw lexError;
	                    }
	                }
	            }

	            filterTokenLocation();
	            tokens = extra.tokens;
	            if (typeof extra.comments !== 'undefined') {
	                tokens.comments = extra.comments;
	            }
	            if (typeof extra.errors !== 'undefined') {
	                tokens.errors = extra.errors;
	            }
	        } catch (e) {
	            throw e;
	        } finally {
	            extra = {};
	        }
	        return tokens;
	    }

	    function parse(code, options) {
	        var program, toString;

	        toString = String;
	        if (typeof code !== 'string' && !(code instanceof String)) {
	            code = toString(code);
	        }

	        source = code;
	        index = 0;
	        lineNumber = (source.length > 0) ? 1 : 0;
	        lineStart = 0;
	        startIndex = index;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;
	        length = source.length;
	        lookahead = null;
	        state = {
	            allowIn: true,
	            labelSet: {},
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            lastCommentStart: -1,
	            curlyStack: []
	        };
	        sourceType = 'script';
	        strict = false;

	        extra = {};
	        if (typeof options !== 'undefined') {
	            extra.range = (typeof options.range === 'boolean') && options.range;
	            extra.loc = (typeof options.loc === 'boolean') && options.loc;
	            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

	            if (extra.loc && options.source !== null && options.source !== undefined) {
	                extra.source = toString(options.source);
	            }

	            if (typeof options.tokens === 'boolean' && options.tokens) {
	                extra.tokens = [];
	            }
	            if (typeof options.comment === 'boolean' && options.comment) {
	                extra.comments = [];
	            }
	            if (typeof options.tolerant === 'boolean' && options.tolerant) {
	                extra.errors = [];
	            }
	            if (extra.attachComment) {
	                extra.range = true;
	                extra.comments = [];
	                extra.bottomRightStack = [];
	                extra.trailingComments = [];
	                extra.leadingComments = [];
	            }
	            if (options.sourceType === 'module') {
	                // very restrictive condition for now
	                sourceType = options.sourceType;
	                strict = true;
	            }
	        }

	        try {
	            program = parseProgram();
	            if (typeof extra.comments !== 'undefined') {
	                program.comments = extra.comments;
	            }
	            if (typeof extra.tokens !== 'undefined') {
	                filterTokenLocation();
	                program.tokens = extra.tokens;
	            }
	            if (typeof extra.errors !== 'undefined') {
	                program.errors = extra.errors;
	            }
	        } catch (e) {
	            throw e;
	        } finally {
	            extra = {};
	        }

	        return program;
	    }

	    // Sync with *.json manifests.
	    exports.version = '2.2.0';

	    exports.tokenize = tokenize;

	    exports.parse = parse;

	    // Deep copy.
	    /* istanbul ignore next */
	    exports.Syntax = (function () {
	        var name, types = {};

	        if (typeof Object.create === 'function') {
	            types = Object.create(null);
	        }

	        for (name in Syntax) {
	            if (Syntax.hasOwnProperty(name)) {
	                types[name] = Syntax[name];
	            }
	        }

	        if (typeof Object.freeze === 'function') {
	            Object.freeze(types);
	        }

	        return types;
	    }());

	}));
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
	//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
	//[5]   	Name	   ::=   	NameStartChar (NameChar)*
	var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]///\u10000-\uEFFFF
	var nameChar = new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\u00B7\u0300-\u036F\\ux203F-\u2040]");
	var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\:'+nameStartChar.source+nameChar.source+'*)?$');
	//var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
	//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

	//S_TAG,	S_ATTR,	S_EQ,	S_V
	//S_ATTR_S,	S_E,	S_S,	S_C
	var S_TAG = 0;//tag name offerring
	var S_ATTR = 1;//attr name offerring 
	var S_ATTR_S=2;//attr name end and space offer
	var S_EQ = 3;//=space?
	var S_V = 4;//attr value(no quot value only)
	var S_E = 5;//attr value end and no space(quot end)
	var S_S = 6;//(attr value end || tag end ) && (space offer)
	var S_C = 7;//closed el<el />

	function XMLReader(){
		
	}

	XMLReader.prototype = {
		parse:function(source,defaultNSMap,entityMap){
			var domBuilder = this.domBuilder;
			domBuilder.startDocument();
			_copy(defaultNSMap ,defaultNSMap = {})
			parse(source,defaultNSMap,entityMap,
					domBuilder,this.errorHandler);
			domBuilder.endDocument();
		}
	}
	function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){
	  function fixedFromCharCode(code) {
			// String.prototype.fromCharCode does not supports
			// > 2 bytes unicode chars directly
			if (code > 0xffff) {
				code -= 0x10000;
				var surrogate1 = 0xd800 + (code >> 10)
					, surrogate2 = 0xdc00 + (code & 0x3ff);

				return String.fromCharCode(surrogate1, surrogate2);
			} else {
				return String.fromCharCode(code);
			}
		}
		function entityReplacer(a){
			var k = a.slice(1,-1);
			if(k in entityMap){
				return entityMap[k]; 
			}else if(k.charAt(0) === '#'){
				return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))
			}else{
				errorHandler.error('entity not found:'+a);
				return a;
			}
		}
		function appendText(end){//has some bugs
			var xt = source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);
			locator&&position(start);
			domBuilder.characters(xt,0,end-start);
			start = end
		}
		function position(start,m){
			while(start>=endPos && (m = linePattern.exec(source))){
				startPos = m.index;
				endPos = startPos + m[0].length;
				locator.lineNumber++;
				//console.log('line++:',locator,startPos,endPos)
			}
			locator.columnNumber = start-startPos+1;
		}
		var startPos = 0;
		var endPos = 0;
		var linePattern = /.+(?:\r\n?|\n)|.*$/g
		var locator = domBuilder.locator;
		
		var parseStack = [{currentNSMap:defaultNSMapCopy}]
		var closeMap = {};
		var start = 0;
		while(true){
			var i = source.indexOf('<',start);
			if(i<0){
				if(!source.substr(start).match(/^\s*$/)){
					var doc = domBuilder.document;
	    			var text = doc.createTextNode(source.substr(start));
	    			doc.appendChild(text);
	    			domBuilder.currentElement = text;
				}
				return;
			}
			if(i>start){
				appendText(i);
			}
			switch(source.charAt(i+1)){
			case '/':
				var end = source.indexOf('>',i+3);
				var tagName = source.substring(i+2,end);
				var config = parseStack.pop();
				var localNSMap = config.localNSMap;
				
		        if(config.tagName != tagName){
		            errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName );
		        }
				domBuilder.endElement(config.uri,config.localName,tagName);
				if(localNSMap){
					for(var prefix in localNSMap){
						domBuilder.endPrefixMapping(prefix) ;
					}
				}
				end++;
				break;
				// end elment
			case '?':// <?...?>
				locator&&position(i);
				end = parseInstruction(source,i,domBuilder);
				break;
			case '!':// <!doctype,<![CDATA,<!--
				locator&&position(i);
				end = parseDCC(source,i,domBuilder,errorHandler);
				break;
			default:
				try{
					locator&&position(i);
					
					var el = new ElementAttributes();
					
					//elStartEnd
					var end = parseElementStartPart(source,i,el,entityReplacer,errorHandler);
					var len = el.length;
					//position fixed
					if(len && locator){
						var backup = copyLocator(locator,{});
						for(var i = 0;i<len;i++){
							var a = el[i];
							position(a.offset);
							a.offset = copyLocator(locator,{});
						}
						copyLocator(backup,locator);
					}
					if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){
						el.closed = true;
						if(!entityMap.nbsp){
							errorHandler.warning('unclosed xml attribute');
						}
					}
					appendElement(el,domBuilder,parseStack);
					
					
					if(el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed){
						end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)
					}else{
						end++;
					}
				}catch(e){
					errorHandler.error('element parse error: '+e);
					end = -1;
				}

			}
			if(end<0){
				//TODO: 这里有可能sax回退，有位置错误风险
				appendText(i+1);
			}else{
				start = end;
			}
		}
	}
	function copyLocator(f,t){
		t.lineNumber = f.lineNumber;
		t.columnNumber = f.columnNumber;
		return t;
		
	}

	/**
	 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
	 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
	 */
	function parseElementStartPart(source,start,el,entityReplacer,errorHandler){
		var attrName;
		var value;
		var p = ++start;
		var s = S_TAG;//status
		while(true){
			var c = source.charAt(p);
			switch(c){
			case '=':
				if(s === S_ATTR){//attrName
					attrName = source.slice(start,p);
					s = S_EQ;
				}else if(s === S_ATTR_S){
					s = S_EQ;
				}else{
					//fatalError: equal must after attrName or space after attrName
					throw new Error('attribute equal must after attrName');
				}
				break;
			case '\'':
			case '"':
				if(s === S_EQ){//equal
					start = p+1;
					p = source.indexOf(c,start)
					if(p>0){
						value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
						el.add(attrName,value,start-1);
						s = S_E;
					}else{
						//fatalError: no end quot match
						throw new Error('attribute value no end \''+c+'\' match');
					}
				}else if(s == S_V){
					value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					//console.log(attrName,value,start,p)
					el.add(attrName,value,start);
					//console.dir(el)
					errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');
					start = p+1;
					s = S_E
				}else{
					//fatalError: no equal before
					throw new Error('attribute value must after "="');
				}
				break;
			case '/':
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));
				case S_E:
				case S_S:
				case S_C:
					s = S_C;
					el.closed = true;
				case S_V:
				case S_ATTR:
				case S_ATTR_S:
					break;
				//case S_EQ:
				default:
					throw new Error("attribute invalid close char('/')")
				}
				break;
			case ''://end document
				//throw new Error('unexpected end of input')
				errorHandler.error('unexpected end of input');
			case '>':
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));
				case S_E:
				case S_S:
				case S_C:
					break;//normal
				case S_V://Compatible state
				case S_ATTR:
					value = source.slice(start,p);
					if(value.slice(-1) === '/'){
						el.closed  = true;
						value = value.slice(0,-1)
					}
				case S_ATTR_S:
					if(s === S_ATTR_S){
						value = attrName;
					}
					if(s == S_V){
						errorHandler.warning('attribute "'+value+'" missed quot(")!!');
						el.add(attrName,value.replace(/&#?\w+;/g,entityReplacer),start)
					}else{
						errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')
						el.add(value,value,start)
					}
					break;
				case S_EQ:
					throw new Error('attribute value missed!!');
				}
	//			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
				return p;
			/*xml space '\x20' | #x9 | #xD | #xA; */
			case '\u0080':
				c = ' ';
			default:
				if(c<= ' '){//space
					switch(s){
					case S_TAG:
						el.setTagName(source.slice(start,p));//tagName
						s = S_S;
						break;
					case S_ATTR:
						attrName = source.slice(start,p)
						s = S_ATTR_S;
						break;
					case S_V:
						var value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
						errorHandler.warning('attribute "'+value+'" missed quot(")!!');
						el.add(attrName,value,start)
					case S_E:
						s = S_S;
						break;
					//case S_S:
					//case S_EQ:
					//case S_ATTR_S:
					//	void();break;
					//case S_C:
						//ignore warning
					}
				}else{//not space
	//S_TAG,	S_ATTR,	S_EQ,	S_V
	//S_ATTR_S,	S_E,	S_S,	S_C
					switch(s){
					//case S_TAG:void();break;
					//case S_ATTR:void();break;
					//case S_V:void();break;
					case S_ATTR_S:
						errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead!!')
						el.add(attrName,attrName,start);
						start = p;
						s = S_ATTR;
						break;
					case S_E:
						errorHandler.warning('attribute space is required"'+attrName+'"!!')
					case S_S:
						s = S_ATTR;
						start = p;
						break;
					case S_EQ:
						s = S_V;
						start = p;
						break;
					case S_C:
						throw new Error("elements closed character '/' and '>' must be connected to");
					}
				}
			}
			p++;
		}
	}
	/**
	 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
	 */
	function appendElement(el,domBuilder,parseStack){
		var tagName = el.tagName;
		var localNSMap = null;
		var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
		var i = el.length;
		while(i--){
			var a = el[i];
			var qName = a.qName;
			var value = a.value;
			var nsp = qName.indexOf(':');
			if(nsp>0){
				var prefix = a.prefix = qName.slice(0,nsp);
				var localName = qName.slice(nsp+1);
				var nsPrefix = prefix === 'xmlns' && localName
			}else{
				localName = qName;
				prefix = null
				nsPrefix = qName === 'xmlns' && ''
			}
			//can not set prefix,because prefix !== ''
			a.localName = localName ;
			//prefix == null for no ns prefix attribute 
			if(nsPrefix !== false){//hack!!
				if(localNSMap == null){
					localNSMap = {}
					//console.log(currentNSMap,0)
					_copy(currentNSMap,currentNSMap={})
					//console.log(currentNSMap,1)
				}
				currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
				a.uri = 'http://www.w3.org/2000/xmlns/'
				domBuilder.startPrefixMapping(nsPrefix, value) 
			}
		}
		var i = el.length;
		while(i--){
			a = el[i];
			var prefix = a.prefix;
			if(prefix){//no prefix attribute has no namespace
				if(prefix === 'xml'){
					a.uri = 'http://www.w3.org/XML/1998/namespace';
				}if(prefix !== 'xmlns'){
					a.uri = currentNSMap[prefix]
					
					//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
				}
			}
		}
		var nsp = tagName.indexOf(':');
		if(nsp>0){
			prefix = el.prefix = tagName.slice(0,nsp);
			localName = el.localName = tagName.slice(nsp+1);
		}else{
			prefix = null;//important!!
			localName = el.localName = tagName;
		}
		//no prefix element has default namespace
		var ns = el.uri = currentNSMap[prefix || ''];
		domBuilder.startElement(ns,localName,tagName,el);
		//endPrefixMapping and startPrefixMapping have not any help for dom builder
		//localNSMap = null
		if(el.closed){
			domBuilder.endElement(ns,localName,tagName);
			if(localNSMap){
				for(prefix in localNSMap){
					domBuilder.endPrefixMapping(prefix) 
				}
			}
		}else{
			el.currentNSMap = currentNSMap;
			el.localNSMap = localNSMap;
			parseStack.push(el);
		}
	}
	function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){
		if(/^(?:script|textarea)$/i.test(tagName)){
			var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);
			var text = source.substring(elStartEnd+1,elEndStart);
			if(/[&<]/.test(text)){
				if(/^script$/i.test(tagName)){
					//if(!/\]\]>/.test(text)){
						//lexHandler.startCDATA();
						domBuilder.characters(text,0,text.length);
						//lexHandler.endCDATA();
						return elEndStart;
					//}
				}//}else{//text area
					text = text.replace(/&#?\w+;/g,entityReplacer);
					domBuilder.characters(text,0,text.length);
					return elEndStart;
				//}
				
			}
		}
		return elStartEnd+1;
	}
	function fixSelfClosed(source,elStartEnd,tagName,closeMap){
		//if(tagName in closeMap){
		var pos = closeMap[tagName];
		if(pos == null){
			//console.log(tagName)
			pos = closeMap[tagName] = source.lastIndexOf('</'+tagName+'>')
		}
		return pos<elStartEnd;
		//} 
	}
	function _copy(source,target){
		for(var n in source){target[n] = source[n]}
	}
	function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'
		var next= source.charAt(start+2)
		switch(next){
		case '-':
			if(source.charAt(start + 3) === '-'){
				var end = source.indexOf('-->',start+4);
				//append comment source.substring(4,end)//<!--
				if(end>start){
					domBuilder.comment(source,start+4,end-start-4);
					return end+3;
				}else{
					errorHandler.error("Unclosed comment");
					return -1;
				}
			}else{
				//error
				return -1;
			}
		default:
			if(source.substr(start+3,6) == 'CDATA['){
				var end = source.indexOf(']]>',start+9);
				domBuilder.startCDATA();
				domBuilder.characters(source,start+9,end-start-9);
				domBuilder.endCDATA() 
				return end+3;
			}
			//<!DOCTYPE
			//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) 
			var matchs = split(source,start);
			var len = matchs.length;
			if(len>1 && /!doctype/i.test(matchs[0][0])){
				var name = matchs[1][0];
				var pubid = len>3 && /^public$/i.test(matchs[2][0]) && matchs[3][0]
				var sysid = len>4 && matchs[4][0];
				var lastMatch = matchs[len-1]
				domBuilder.startDTD(name,pubid && pubid.replace(/^(['"])(.*?)\1$/,'$2'),
						sysid && sysid.replace(/^(['"])(.*?)\1$/,'$2'));
				domBuilder.endDTD();
				
				return lastMatch.index+lastMatch[0].length
			}
		}
		return -1;
	}



	function parseInstruction(source,start,domBuilder){
		var end = source.indexOf('?>',start);
		if(end){
			var match = source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
			if(match){
				var len = match[0].length;
				domBuilder.processingInstruction(match[1], match[2]) ;
				return end+2;
			}else{//error
				return -1;
			}
		}
		return -1;
	}

	/**
	 * @param source
	 */
	function ElementAttributes(source){
		
	}
	ElementAttributes.prototype = {
		setTagName:function(tagName){
			if(!tagNamePattern.test(tagName)){
				throw new Error('invalid tagName:'+tagName)
			}
			this.tagName = tagName
		},
		add:function(qName,value,offset){
			if(!tagNamePattern.test(qName)){
				throw new Error('invalid attribute:'+qName)
			}
			this[this.length++] = {qName:qName,value:value,offset:offset}
		},
		length:0,
		getLocalName:function(i){return this[i].localName},
		getOffset:function(i){return this[i].offset},
		getQName:function(i){return this[i].qName},
		getURI:function(i){return this[i].uri},
		getValue:function(i){return this[i].value}
	//	,getIndex:function(uri, localName)){
	//		if(localName){
	//			
	//		}else{
	//			var qName = uri
	//		}
	//	},
	//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
	//	getType:function(uri,localName){}
	//	getType:function(i){},
	}




	function _set_proto_(thiz,parent){
		thiz.__proto__ = parent;
		return thiz;
	}
	if(!(_set_proto_({},_set_proto_.prototype) instanceof _set_proto_)){
		_set_proto_ = function(thiz,parent){
			function p(){};
			p.prototype = parent;
			p = new p();
			for(parent in thiz){
				p[parent] = thiz[parent];
			}
			return p;
		}
	}

	function split(source,start){
		var match;
		var buf = [];
		var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
		reg.lastIndex = start;
		reg.exec(source);//skip <
		while(match = reg.exec(source)){
			buf.push(match);
			if(match[1])return buf;
		}
	}

	if(true){
		exports.XMLReader = XMLReader;
	}



/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * DOM Level 2
	 * Object DOMException
	 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
	 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
	 */

	function copy(src,dest){
		for(var p in src){
			dest[p] = src[p];
		}
	}
	/**
	^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
	^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
	 */
	function _extends(Class,Super){
		var pt = Class.prototype;
		if(Object.create){
			var ppt = Object.create(Super.prototype)
			pt.__proto__ = ppt;
		}
		if(!(pt instanceof Super)){
			function t(){};
			t.prototype = Super.prototype;
			t = new t();
			copy(pt,t);
			Class.prototype = pt = t;
		}
		if(pt.constructor != Class){
			if(typeof Class != 'function'){
				console.error("unknow Class:"+Class)
			}
			pt.constructor = Class
		}
	}
	var htmlns = 'http://www.w3.org/1999/xhtml' ;
	// Node Types
	var NodeType = {}
	var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
	var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
	var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
	var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
	var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
	var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
	var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
	var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
	var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
	var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
	var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
	var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

	// ExceptionCode
	var ExceptionCode = {}
	var ExceptionMessage = {};
	var INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
	var DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
	var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
	var WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
	var INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
	var NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
	var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
	var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
	var NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
	var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
	//level2
	var INVALID_STATE_ERR        	= ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
	var SYNTAX_ERR               	= ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
	var INVALID_MODIFICATION_ERR 	= ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
	var NAMESPACE_ERR            	= ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
	var INVALID_ACCESS_ERR       	= ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);


	function DOMException(code, message) {
		if(message instanceof Error){
			var error = message;
		}else{
			error = this;
			Error.call(this, ExceptionMessage[code]);
			this.message = ExceptionMessage[code];
			if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
		}
		error.code = code;
		if(message) this.message = this.message + ": " + message;
		return error;
	};
	DOMException.prototype = Error.prototype;
	copy(ExceptionCode,DOMException)
	/**
	 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
	 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
	 * The items in the NodeList are accessible via an integral index, starting from 0.
	 */
	function NodeList() {
	};
	NodeList.prototype = {
		/**
		 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
		 * @standard level1
		 */
		length:0, 
		/**
		 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
		 * @standard level1
		 * @param index  unsigned long 
		 *   Index into the collection.
		 * @return Node
		 * 	The node at the indexth position in the NodeList, or null if that is not a valid index. 
		 */
		item: function(index) {
			return this[index] || null;
		}
	};
	function LiveNodeList(node,refresh){
		this._node = node;
		this._refresh = refresh
		_updateLiveList(this);
	}
	function _updateLiveList(list){
		var inc = list._node._inc || list._node.ownerDocument._inc;
		if(list._inc != inc){
			var ls = list._refresh(list._node);
			//console.log(ls.length)
			__set__(list,'length',ls.length);
			copy(ls,list);
			list._inc = inc;
		}
	}
	LiveNodeList.prototype.item = function(i){
		_updateLiveList(this);
		return this[i];
	}

	_extends(LiveNodeList,NodeList);
	/**
	 * 
	 * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.
	 * NamedNodeMap objects in the DOM are live.
	 * used for attributes or DocumentType entities 
	 */
	function NamedNodeMap() {
	};

	function _findNodeIndex(list,node){
		var i = list.length;
		while(i--){
			if(list[i] === node){return i}
		}
	}

	function _addNamedNode(el,list,newAttr,oldAttr){
		if(oldAttr){
			list[_findNodeIndex(list,oldAttr)] = newAttr;
		}else{
			list[list.length++] = newAttr;
		}
		if(el){
			newAttr.ownerElement = el;
			var doc = el.ownerDocument;
			if(doc){
				oldAttr && _onRemoveAttribute(doc,el,oldAttr);
				_onAddAttribute(doc,el,newAttr);
			}
		}
	}
	function _removeNamedNode(el,list,attr){
		var i = _findNodeIndex(list,attr);
		if(i>=0){
			var lastIndex = list.length-1
			while(i<lastIndex){
				list[i] = list[++i]
			}
			list.length = lastIndex;
			if(el){
				var doc = el.ownerDocument;
				if(doc){
					_onRemoveAttribute(doc,el,attr);
					attr.ownerElement = null;
				}
			}
		}else{
			throw DOMException(NOT_FOUND_ERR,new Error())
		}
	}
	NamedNodeMap.prototype = {
		length:0,
		item:NodeList.prototype.item,
		getNamedItem: function(key) {
	//		if(key.indexOf(':')>0 || key == 'xmlns'){
	//			return null;
	//		}
			var i = this.length;
			while(i--){
				var attr = this[i];
				if(attr.nodeName == key){
					return attr;
				}
			}
		},
		setNamedItem: function(attr) {
			var el = attr.ownerElement;
			if(el && el!=this._ownerElement){
				throw new DOMException(INUSE_ATTRIBUTE_ERR);
			}
			var oldAttr = this.getNamedItem(attr.nodeName);
			_addNamedNode(this._ownerElement,this,attr,oldAttr);
			return oldAttr;
		},
		/* returns Node */
		setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
			var el = attr.ownerElement, oldAttr;
			if(el && el!=this._ownerElement){
				throw new DOMException(INUSE_ATTRIBUTE_ERR);
			}
			oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
			_addNamedNode(this._ownerElement,this,attr,oldAttr);
			return oldAttr;
		},

		/* returns Node */
		removeNamedItem: function(key) {
			var attr = this.getNamedItem(key);
			_removeNamedNode(this._ownerElement,this,attr);
			return attr;
			
			
		},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
		
		//for level2
		removeNamedItemNS:function(namespaceURI,localName){
			var attr = this.getNamedItemNS(namespaceURI,localName);
			_removeNamedNode(this._ownerElement,this,attr);
			return attr;
		},
		getNamedItemNS: function(namespaceURI, localName) {
			var i = this.length;
			while(i--){
				var node = this[i];
				if(node.localName == localName && node.namespaceURI == namespaceURI){
					return node;
				}
			}
			return null;
		}
	};
	/**
	 * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490
	 */
	function DOMImplementation(/* Object */ features) {
		this._features = {};
		if (features) {
			for (var feature in features) {
				 this._features = features[feature];
			}
		}
	};

	DOMImplementation.prototype = {
		hasFeature: function(/* string */ feature, /* string */ version) {
			var versions = this._features[feature.toLowerCase()];
			if (versions && (!version || version in versions)) {
				return true;
			} else {
				return false;
			}
		},
		// Introduced in DOM Level 2:
		createDocument:function(namespaceURI,  qualifiedName, doctype){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR
			var doc = new Document();
			doc.doctype = doctype;
			if(doctype){
				doc.appendChild(doctype);
			}
			doc.implementation = this;
			doc.childNodes = new NodeList();
			if(qualifiedName){
				var root = doc.createElementNS(namespaceURI,qualifiedName);
				doc.appendChild(root);
			}
			return doc;
		},
		// Introduced in DOM Level 2:
		createDocumentType:function(qualifiedName, publicId, systemId){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR
			var node = new DocumentType();
			node.name = qualifiedName;
			node.nodeName = qualifiedName;
			node.publicId = publicId;
			node.systemId = systemId;
			// Introduced in DOM Level 2:
			//readonly attribute DOMString        internalSubset;
			
			//TODO:..
			//  readonly attribute NamedNodeMap     entities;
			//  readonly attribute NamedNodeMap     notations;
			return node;
		}
	};


	/**
	 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
	 */

	function Node() {
	};

	Node.prototype = {
		firstChild : null,
		lastChild : null,
		previousSibling : null,
		nextSibling : null,
		attributes : null,
		parentNode : null,
		childNodes : null,
		ownerDocument : null,
		nodeValue : null,
		namespaceURI : null,
		prefix : null,
		localName : null,
		// Modified in DOM Level 2:
		insertBefore:function(newChild, refChild){//raises 
			return _insertBefore(this,newChild,refChild);
		},
		replaceChild:function(newChild, oldChild){//raises 
			this.insertBefore(newChild,oldChild);
			if(oldChild){
				this.removeChild(oldChild);
			}
		},
		removeChild:function(oldChild){
			return _removeChild(this,oldChild);
		},
		appendChild:function(newChild){
			return this.insertBefore(newChild,null);
		},
		hasChildNodes:function(){
			return this.firstChild != null;
		},
		cloneNode:function(deep){
			return cloneNode(this.ownerDocument||this,this,deep);
		},
		// Modified in DOM Level 2:
		normalize:function(){
			var child = this.firstChild;
			while(child){
				var next = child.nextSibling;
				if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
					this.removeChild(next);
					child.appendData(next.data);
				}else{
					child.normalize();
					child = next;
				}
			}
		},
	  	// Introduced in DOM Level 2:
		isSupported:function(feature, version){
			return this.ownerDocument.implementation.hasFeature(feature,version);
		},
	    // Introduced in DOM Level 2:
	    hasAttributes:function(){
	    	return this.attributes.length>0;
	    },
	    lookupPrefix:function(namespaceURI){
	    	var el = this;
	    	while(el){
	    		var map = el._nsMap;
	    		//console.dir(map)
	    		if(map){
	    			for(var n in map){
	    				if(map[n] == namespaceURI){
	    					return n;
	    				}
	    			}
	    		}
	    		el = el.nodeType == 2?el.ownerDocument : el.parentNode;
	    	}
	    	return null;
	    },
	    // Introduced in DOM Level 3:
	    lookupNamespaceURI:function(prefix){
	    	var el = this;
	    	while(el){
	    		var map = el._nsMap;
	    		//console.dir(map)
	    		if(map){
	    			if(prefix in map){
	    				return map[prefix] ;
	    			}
	    		}
	    		el = el.nodeType == 2?el.ownerDocument : el.parentNode;
	    	}
	    	return null;
	    },
	    // Introduced in DOM Level 3:
	    isDefaultNamespace:function(namespaceURI){
	    	var prefix = this.lookupPrefix(namespaceURI);
	    	return prefix == null;
	    }
	};


	function _xmlEncoder(c){
		return c == '<' && '&lt;' ||
	         c == '>' && '&gt;' ||
	         c == '&' && '&amp;' ||
	         c == '"' && '&quot;' ||
	         '&#'+c.charCodeAt()+';'
	}


	copy(NodeType,Node);
	copy(NodeType,Node.prototype);

	/**
	 * @param callback return true for continue,false for break
	 * @return boolean true: break visit;
	 */
	function _visitNode(node,callback){
		if(callback(node)){
			return true;
		}
		if(node = node.firstChild){
			do{
				if(_visitNode(node,callback)){return true}
	        }while(node=node.nextSibling)
	    }
	}



	function Document(){
	}
	function _onAddAttribute(doc,el,newAttr){
		doc && doc._inc++;
		var ns = newAttr.namespaceURI ;
		if(ns == 'http://www.w3.org/2000/xmlns/'){
			//update namespace
			el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value
		}
	}
	function _onRemoveAttribute(doc,el,newAttr,remove){
		doc && doc._inc++;
		var ns = newAttr.namespaceURI ;
		if(ns == 'http://www.w3.org/2000/xmlns/'){
			//update namespace
			delete el._nsMap[newAttr.prefix?newAttr.localName:'']
		}
	}
	function _onUpdateChild(doc,el,newChild){
		if(doc && doc._inc){
			doc._inc++;
			//update childNodes
			var cs = el.childNodes;
			if(newChild){
				cs[cs.length++] = newChild;
			}else{
				//console.log(1)
				var child = el.firstChild;
				var i = 0;
				while(child){
					cs[i++] = child;
					child =child.nextSibling;
				}
				cs.length = i;
			}
		}
	}

	/**
	 * attributes;
	 * children;
	 * 
	 * writeable properties:
	 * nodeValue,Attr:value,CharacterData:data
	 * prefix
	 */
	function _removeChild(parentNode,child){
		var previous = child.previousSibling;
		var next = child.nextSibling;
		if(previous){
			previous.nextSibling = next;
		}else{
			parentNode.firstChild = next
		}
		if(next){
			next.previousSibling = previous;
		}else{
			parentNode.lastChild = previous;
		}
		_onUpdateChild(parentNode.ownerDocument,parentNode);
		return child;
	}
	/**
	 * preformance key(refChild == null)
	 */
	function _insertBefore(parentNode,newChild,nextChild){
		var cp = newChild.parentNode;
		if(cp){
			cp.removeChild(newChild);//remove and update
		}
		if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
			var newFirst = newChild.firstChild;
			if (newFirst == null) {
				return newChild;
			}
			var newLast = newChild.lastChild;
		}else{
			newFirst = newLast = newChild;
		}
		var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;

		newFirst.previousSibling = pre;
		newLast.nextSibling = nextChild;
		
		
		if(pre){
			pre.nextSibling = newFirst;
		}else{
			parentNode.firstChild = newFirst;
		}
		if(nextChild == null){
			parentNode.lastChild = newLast;
		}else{
			nextChild.previousSibling = newLast;
		}
		do{
			newFirst.parentNode = parentNode;
		}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
		_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);
		//console.log(parentNode.lastChild.nextSibling == null)
		if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
			newChild.firstChild = newChild.lastChild = null;
		}
		return newChild;
	}
	function _appendSingleChild(parentNode,newChild){
		var cp = newChild.parentNode;
		if(cp){
			var pre = parentNode.lastChild;
			cp.removeChild(newChild);//remove and update
			var pre = parentNode.lastChild;
		}
		var pre = parentNode.lastChild;
		newChild.parentNode = parentNode;
		newChild.previousSibling = pre;
		newChild.nextSibling = null;
		if(pre){
			pre.nextSibling = newChild;
		}else{
			parentNode.firstChild = newChild;
		}
		parentNode.lastChild = newChild;
		_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);
		return newChild;
		//console.log("__aa",parentNode.lastChild.nextSibling == null)
	}
	Document.prototype = {
		//implementation : null,
		nodeName :  '#document',
		nodeType :  DOCUMENT_NODE,
		doctype :  null,
		documentElement :  null,
		_inc : 1,
		
		insertBefore :  function(newChild, refChild){//raises 
			if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
				var child = newChild.firstChild;
				while(child){
					var next = child.nextSibling;
					this.insertBefore(child,refChild);
					child = next;
				}
				return newChild;
			}
			if(this.documentElement == null && newChild.nodeType == 1){
				this.documentElement = newChild;
			}
			
			return _insertBefore(this,newChild,refChild),(newChild.ownerDocument = this),newChild;
		},
		removeChild :  function(oldChild){
			if(this.documentElement == oldChild){
				this.documentElement = null;
			}
			return _removeChild(this,oldChild);
		},
		// Introduced in DOM Level 2:
		importNode : function(importedNode,deep){
			return importNode(this,importedNode,deep);
		},
		// Introduced in DOM Level 2:
		getElementById :	function(id){
			var rtv = null;
			_visitNode(this.documentElement,function(node){
				if(node.nodeType == 1){
					if(node.getAttribute('id') == id){
						rtv = node;
						return true;
					}
				}
			})
			return rtv;
		},
		
		//document factory method:
		createElement :	function(tagName){
			var node = new Element();
			node.ownerDocument = this;
			node.nodeName = tagName;
			node.tagName = tagName;
			node.childNodes = new NodeList();
			var attrs	= node.attributes = new NamedNodeMap();
			attrs._ownerElement = node;
			return node;
		},
		createDocumentFragment :	function(){
			var node = new DocumentFragment();
			node.ownerDocument = this;
			node.childNodes = new NodeList();
			return node;
		},
		createTextNode :	function(data){
			var node = new Text();
			node.ownerDocument = this;
			node.appendData(data)
			return node;
		},
		createComment :	function(data){
			var node = new Comment();
			node.ownerDocument = this;
			node.appendData(data)
			return node;
		},
		createCDATASection :	function(data){
			var node = new CDATASection();
			node.ownerDocument = this;
			node.appendData(data)
			return node;
		},
		createProcessingInstruction :	function(target,data){
			var node = new ProcessingInstruction();
			node.ownerDocument = this;
			node.tagName = node.target = target;
			node.nodeValue= node.data = data;
			return node;
		},
		createAttribute :	function(name){
			var node = new Attr();
			node.ownerDocument	= this;
			node.name = name;
			node.nodeName	= name;
			node.localName = name;
			node.specified = true;
			return node;
		},
		createEntityReference :	function(name){
			var node = new EntityReference();
			node.ownerDocument	= this;
			node.nodeName	= name;
			return node;
		},
		// Introduced in DOM Level 2:
		createElementNS :	function(namespaceURI,qualifiedName){
			var node = new Element();
			var pl = qualifiedName.split(':');
			var attrs	= node.attributes = new NamedNodeMap();
			node.childNodes = new NodeList();
			node.ownerDocument = this;
			node.nodeName = qualifiedName;
			node.tagName = qualifiedName;
			node.namespaceURI = namespaceURI;
			if(pl.length == 2){
				node.prefix = pl[0];
				node.localName = pl[1];
			}else{
				//el.prefix = null;
				node.localName = qualifiedName;
			}
			attrs._ownerElement = node;
			return node;
		},
		// Introduced in DOM Level 2:
		createAttributeNS :	function(namespaceURI,qualifiedName){
			var node = new Attr();
			var pl = qualifiedName.split(':');
			node.ownerDocument = this;
			node.nodeName = qualifiedName;
			node.name = qualifiedName;
			node.namespaceURI = namespaceURI;
			node.specified = true;
			if(pl.length == 2){
				node.prefix = pl[0];
				node.localName = pl[1];
			}else{
				//el.prefix = null;
				node.localName = qualifiedName;
			}
			return node;
		}
	};
	_extends(Document,Node);


	function Element() {
		this._nsMap = {};
	};
	Element.prototype = {
		nodeType : ELEMENT_NODE,
		hasAttribute : function(name){
			return this.getAttributeNode(name)!=null;
		},
		getAttribute : function(name){
			var attr = this.getAttributeNode(name);
			return attr && attr.value || '';
		},
		getAttributeNode : function(name){
			return this.attributes.getNamedItem(name);
		},
		setAttribute : function(name, value){
			var attr = this.ownerDocument.createAttribute(name);
			attr.value = attr.nodeValue = "" + value;
			this.setAttributeNode(attr)
		},
		removeAttribute : function(name){
			var attr = this.getAttributeNode(name)
			attr && this.removeAttributeNode(attr);
		},
		
		//four real opeartion method
		appendChild:function(newChild){
			if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
				return this.insertBefore(newChild,null);
			}else{
				return _appendSingleChild(this,newChild);
			}
		},
		setAttributeNode : function(newAttr){
			return this.attributes.setNamedItem(newAttr);
		},
		setAttributeNodeNS : function(newAttr){
			return this.attributes.setNamedItemNS(newAttr);
		},
		removeAttributeNode : function(oldAttr){
			return this.attributes.removeNamedItem(oldAttr.nodeName);
		},
		//get real attribute name,and remove it by removeAttributeNode
		removeAttributeNS : function(namespaceURI, localName){
			var old = this.getAttributeNodeNS(namespaceURI, localName);
			old && this.removeAttributeNode(old);
		},
		
		hasAttributeNS : function(namespaceURI, localName){
			return this.getAttributeNodeNS(namespaceURI, localName)!=null;
		},
		getAttributeNS : function(namespaceURI, localName){
			var attr = this.getAttributeNodeNS(namespaceURI, localName);
			return attr && attr.value || '';
		},
		setAttributeNS : function(namespaceURI, qualifiedName, value){
			var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
			attr.value = attr.nodeValue = value;
			this.setAttributeNode(attr)
		},
		getAttributeNodeNS : function(namespaceURI, localName){
			return this.attributes.getNamedItemNS(namespaceURI, localName);
		},
		
		getElementsByTagName : function(tagName){
			return new LiveNodeList(this,function(base){
				var ls = [];
				_visitNode(base,function(node){
					if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
						ls.push(node);
					}
				});
				return ls;
			});
		},
		getElementsByTagNameNS : function(namespaceURI, localName){
			return new LiveNodeList(this,function(base){
				var ls = [];
				_visitNode(base,function(node){
					if(node !== base && node.nodeType === ELEMENT_NODE && node.namespaceURI === namespaceURI && (localName === '*' || node.localName == localName)){
						ls.push(node);
					}
				});
				return ls;
			});
		}
	};
	Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
	Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


	_extends(Element,Node);
	function Attr() {
	};
	Attr.prototype.nodeType = ATTRIBUTE_NODE;
	_extends(Attr,Node);


	function CharacterData() {
	};
	CharacterData.prototype = {
		data : '',
		substringData : function(offset, count) {
			return this.data.substring(offset, offset+count);
		},
		appendData: function(text) {
			text = this.data+text;
			this.nodeValue = this.data = text;
			this.length = text.length;
		},
		insertData: function(offset,text) {
			this.replaceData(offset,0,text);
		
		},
		appendChild:function(newChild){
			//if(!(newChild instanceof CharacterData)){
				throw new Error(ExceptionMessage[3])
			//}
			return Node.prototype.appendChild.apply(this,arguments)
		},
		deleteData: function(offset, count) {
			this.replaceData(offset,count,"");
		},
		replaceData: function(offset, count, text) {
			var start = this.data.substring(0,offset);
			var end = this.data.substring(offset+count);
			text = start + text + end;
			this.nodeValue = this.data = text;
			this.length = text.length;
		}
	}
	_extends(CharacterData,Node);
	function Text() {
	};
	Text.prototype = {
		nodeName : "#text",
		nodeType : TEXT_NODE,
		splitText : function(offset) {
			var text = this.data;
			var newText = text.substring(offset);
			text = text.substring(0, offset);
			this.data = this.nodeValue = text;
			this.length = text.length;
			var newNode = this.ownerDocument.createTextNode(newText);
			if(this.parentNode){
				this.parentNode.insertBefore(newNode, this.nextSibling);
			}
			return newNode;
		}
	}
	_extends(Text,CharacterData);
	function Comment() {
	};
	Comment.prototype = {
		nodeName : "#comment",
		nodeType : COMMENT_NODE
	}
	_extends(Comment,CharacterData);

	function CDATASection() {
	};
	CDATASection.prototype = {
		nodeName : "#cdata-section",
		nodeType : CDATA_SECTION_NODE
	}
	_extends(CDATASection,CharacterData);


	function DocumentType() {
	};
	DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
	_extends(DocumentType,Node);

	function Notation() {
	};
	Notation.prototype.nodeType = NOTATION_NODE;
	_extends(Notation,Node);

	function Entity() {
	};
	Entity.prototype.nodeType = ENTITY_NODE;
	_extends(Entity,Node);

	function EntityReference() {
	};
	EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
	_extends(EntityReference,Node);

	function DocumentFragment() {
	};
	DocumentFragment.prototype.nodeName =	"#document-fragment";
	DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
	_extends(DocumentFragment,Node);


	function ProcessingInstruction() {
	}
	ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
	_extends(ProcessingInstruction,Node);
	function XMLSerializer(){}
	XMLSerializer.prototype.serializeToString = function(node){
		var buf = [];
		serializeToString(node,buf);
		return buf.join('');
	}
	Node.prototype.toString =function(){
		return XMLSerializer.prototype.serializeToString(this);
	}
	function serializeToString(node,buf){
		switch(node.nodeType){
		case ELEMENT_NODE:
			var attrs = node.attributes;
			var len = attrs.length;
			var child = node.firstChild;
			var nodeName = node.tagName;
			var isHTML = htmlns === node.namespaceURI
			buf.push('<',nodeName);
			for(var i=0;i<len;i++){
				serializeToString(attrs.item(i),buf,isHTML);
			}
			if(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){
				buf.push('>');
				//if is cdata child node
				if(isHTML && /^script$/i.test(nodeName)){
					if(child){
						buf.push(child.data);
					}
				}else{
					while(child){
						serializeToString(child,buf);
						child = child.nextSibling;
					}
				}
				buf.push('</',nodeName,'>');
			}else{
				buf.push('/>');
			}
			return;
		case DOCUMENT_NODE:
		case DOCUMENT_FRAGMENT_NODE:
			var child = node.firstChild;
			while(child){
				serializeToString(child,buf);
				child = child.nextSibling;
			}
			return;
		case ATTRIBUTE_NODE:
			return buf.push(' ',node.name,'="',node.value.replace(/[<&"]/g,_xmlEncoder),'"');
		case TEXT_NODE:
			return buf.push(node.data.replace(/[<&]/g,_xmlEncoder));
		case CDATA_SECTION_NODE:
			return buf.push( '<![CDATA[',node.data,']]>');
		case COMMENT_NODE:
			return buf.push( "<!--",node.data,"-->");
		case DOCUMENT_TYPE_NODE:
			var pubid = node.publicId;
			var sysid = node.systemId;
			buf.push('<!DOCTYPE ',node.name);
			if(pubid){
				buf.push(' PUBLIC "',pubid);
				if (sysid && sysid!='.') {
					buf.push( '" "',sysid);
				}
				buf.push('">');
			}else if(sysid && sysid!='.'){
				buf.push(' SYSTEM "',sysid,'">');
			}else{
				var sub = node.internalSubset;
				if(sub){
					buf.push(" [",sub,"]");
				}
				buf.push(">");
			}
			return;
		case PROCESSING_INSTRUCTION_NODE:
			return buf.push( "<?",node.target," ",node.data,"?>");
		case ENTITY_REFERENCE_NODE:
			return buf.push( '&',node.nodeName,';');
		//case ENTITY_NODE:
		//case NOTATION_NODE:
		default:
			buf.push('??',node.nodeName);
		}
	}
	function importNode(doc,node,deep){
		var node2;
		switch (node.nodeType) {
		case ELEMENT_NODE:
			node2 = node.cloneNode(false);
			node2.ownerDocument = doc;
			//var attrs = node2.attributes;
			//var len = attrs.length;
			//for(var i=0;i<len;i++){
				//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
			//}
		case DOCUMENT_FRAGMENT_NODE:
			break;
		case ATTRIBUTE_NODE:
			deep = true;
			break;
		//case ENTITY_REFERENCE_NODE:
		//case PROCESSING_INSTRUCTION_NODE:
		////case TEXT_NODE:
		//case CDATA_SECTION_NODE:
		//case COMMENT_NODE:
		//	deep = false;
		//	break;
		//case DOCUMENT_NODE:
		//case DOCUMENT_TYPE_NODE:
		//cannot be imported.
		//case ENTITY_NODE:
		//case NOTATION_NODE：
		//can not hit in level3
		//default:throw e;
		}
		if(!node2){
			node2 = node.cloneNode(false);//false
		}
		node2.ownerDocument = doc;
		node2.parentNode = null;
		if(deep){
			var child = node.firstChild;
			while(child){
				node2.appendChild(importNode(doc,child,deep));
				child = child.nextSibling;
			}
		}
		return node2;
	}
	//
	//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
	//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
	function cloneNode(doc,node,deep){
		var node2 = new node.constructor();
		for(var n in node){
			var v = node[n];
			if(typeof v != 'object' ){
				if(v != node2[n]){
					node2[n] = v;
				}
			}
		}
		if(node.childNodes){
			node2.childNodes = new NodeList();
		}
		node2.ownerDocument = doc;
		switch (node2.nodeType) {
		case ELEMENT_NODE:
			var attrs	= node.attributes;
			var attrs2	= node2.attributes = new NamedNodeMap();
			var len = attrs.length
			attrs2._ownerElement = node2;
			for(var i=0;i<len;i++){
				node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
			}
			break;;
		case ATTRIBUTE_NODE:
			deep = true;
		}
		if(deep){
			var child = node.firstChild;
			while(child){
				node2.appendChild(cloneNode(doc,child,deep));
				child = child.nextSibling;
			}
		}
		return node2;
	}

	function __set__(object,key,value){
		object[key] = value
	}
	//do dynamic
	try{
		if(Object.defineProperty){
			Object.defineProperty(LiveNodeList.prototype,'length',{
				get:function(){
					_updateLiveList(this);
					return this.$$length;
				}
			});
			Object.defineProperty(Node.prototype,'textContent',{
				get:function(){
					return getTextContent(this);
				},
				set:function(data){
					switch(this.nodeType){
					case 1:
					case 11:
						while(this.firstChild){
							this.removeChild(this.firstChild);
						}
						if(data || String(data)){
							this.appendChild(this.ownerDocument.createTextNode(data));
						}
						break;
					default:
						//TODO:
						this.data = data;
						this.value = value;
						this.nodeValue = data;
					}
				}
			})
			
			function getTextContent(node){
				switch(node.nodeType){
				case 1:
				case 11:
					var buf = [];
					node = node.firstChild;
					while(node){
						if(node.nodeType!==7 && node.nodeType !==8){
							buf.push(getTextContent(node));
						}
						node = node.nextSibling;
					}
					return buf.join('');
				default:
					return node.nodeValue;
				}
			}
			__set__ = function(object,key,value){
				//console.log(value)
				object['$$'+key] = value
			}
		}
	}catch(e){//ie8
	}

	if(true){
		exports.DOMImplementation = DOMImplementation;
		exports.XMLSerializer = XMLSerializer;
	}


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	
	var indexOf = [].indexOf;

	module.exports = function(arr, obj){
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	var at, // The index of the current character
	    ch, // The current character
	    escapee = {
	        '"':  '"',
	        '\\': '\\',
	        '/':  '/',
	        b:    '\b',
	        f:    '\f',
	        n:    '\n',
	        r:    '\r',
	        t:    '\t'
	    },
	    text,

	    error = function (m) {
	        // Call error when something is wrong.
	        throw {
	            name:    'SyntaxError',
	            message: m,
	            at:      at,
	            text:    text
	        };
	    },
	    
	    next = function (c) {
	        // If a c parameter is provided, verify that it matches the current character.
	        if (c && c !== ch) {
	            error("Expected '" + c + "' instead of '" + ch + "'");
	        }
	        
	        // Get the next character. When there are no more characters,
	        // return the empty string.
	        
	        ch = text.charAt(at);
	        at += 1;
	        return ch;
	    },
	    
	    number = function () {
	        // Parse a number value.
	        var number,
	            string = '';
	        
	        if (ch === '-') {
	            string = '-';
	            next('-');
	        }
	        while (ch >= '0' && ch <= '9') {
	            string += ch;
	            next();
	        }
	        if (ch === '.') {
	            string += '.';
	            while (next() && ch >= '0' && ch <= '9') {
	                string += ch;
	            }
	        }
	        if (ch === 'e' || ch === 'E') {
	            string += ch;
	            next();
	            if (ch === '-' || ch === '+') {
	                string += ch;
	                next();
	            }
	            while (ch >= '0' && ch <= '9') {
	                string += ch;
	                next();
	            }
	        }
	        number = +string;
	        if (!isFinite(number)) {
	            error("Bad number");
	        } else {
	            return number;
	        }
	    },
	    
	    string = function () {
	        // Parse a string value.
	        var hex,
	            i,
	            string = '',
	            uffff;
	        
	        // When parsing for string values, we must look for " and \ characters.
	        if (ch === '"') {
	            while (next()) {
	                if (ch === '"') {
	                    next();
	                    return string;
	                } else if (ch === '\\') {
	                    next();
	                    if (ch === 'u') {
	                        uffff = 0;
	                        for (i = 0; i < 4; i += 1) {
	                            hex = parseInt(next(), 16);
	                            if (!isFinite(hex)) {
	                                break;
	                            }
	                            uffff = uffff * 16 + hex;
	                        }
	                        string += String.fromCharCode(uffff);
	                    } else if (typeof escapee[ch] === 'string') {
	                        string += escapee[ch];
	                    } else {
	                        break;
	                    }
	                } else {
	                    string += ch;
	                }
	            }
	        }
	        error("Bad string");
	    },

	    white = function () {

	// Skip whitespace.

	        while (ch && ch <= ' ') {
	            next();
	        }
	    },

	    word = function () {

	// true, false, or null.

	        switch (ch) {
	        case 't':
	            next('t');
	            next('r');
	            next('u');
	            next('e');
	            return true;
	        case 'f':
	            next('f');
	            next('a');
	            next('l');
	            next('s');
	            next('e');
	            return false;
	        case 'n':
	            next('n');
	            next('u');
	            next('l');
	            next('l');
	            return null;
	        }
	        error("Unexpected '" + ch + "'");
	    },

	    value,  // Place holder for the value function.

	    array = function () {

	// Parse an array value.

	        var array = [];

	        if (ch === '[') {
	            next('[');
	            white();
	            if (ch === ']') {
	                next(']');
	                return array;   // empty array
	            }
	            while (ch) {
	                array.push(value());
	                white();
	                if (ch === ']') {
	                    next(']');
	                    return array;
	                }
	                next(',');
	                white();
	            }
	        }
	        error("Bad array");
	    },

	    object = function () {

	// Parse an object value.

	        var key,
	            object = {};

	        if (ch === '{') {
	            next('{');
	            white();
	            if (ch === '}') {
	                next('}');
	                return object;   // empty object
	            }
	            while (ch) {
	                key = string();
	                white();
	                next(':');
	                if (Object.hasOwnProperty.call(object, key)) {
	                    error('Duplicate key "' + key + '"');
	                }
	                object[key] = value();
	                white();
	                if (ch === '}') {
	                    next('}');
	                    return object;
	                }
	                next(',');
	                white();
	            }
	        }
	        error("Bad object");
	    };

	value = function () {

	// Parse a JSON value. It could be an object, an array, a string, a number,
	// or a word.

	    white();
	    switch (ch) {
	    case '{':
	        return object();
	    case '[':
	        return array();
	    case '"':
	        return string();
	    case '-':
	        return number();
	    default:
	        return ch >= '0' && ch <= '9' ? number() : word();
	    }
	};

	// Return the json_parse function. It will have access to all of the above
	// functions and variables.

	module.exports = function (source, reviver) {
	    var result;
	    
	    text = source;
	    at = 0;
	    ch = ' ';
	    result = value();
	    white();
	    if (ch) {
	        error("Syntax error");
	    }

	    // If there is a reviver function, we recursively walk the new structure,
	    // passing each name/value pair to the reviver function for possible
	    // transformation, starting with a temporary root object that holds the result
	    // in an empty key. If there is not a reviver function, we simply return the
	    // result.

	    return typeof reviver === 'function' ? (function walk(holder, key) {
	        var k, v, value = holder[key];
	        if (value && typeof value === 'object') {
	            for (k in value) {
	                if (Object.prototype.hasOwnProperty.call(value, k)) {
	                    v = walk(value, k);
	                    if (v !== undefined) {
	                        value[k] = v;
	                    } else {
	                        delete value[k];
	                    }
	                }
	            }
	        }
	        return reviver.call(holder, key, value);
	    }({'': result}, '')) : result;
	};


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
	    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
	    gap,
	    indent,
	    meta = {    // table of character substitutions
	        '\b': '\\b',
	        '\t': '\\t',
	        '\n': '\\n',
	        '\f': '\\f',
	        '\r': '\\r',
	        '"' : '\\"',
	        '\\': '\\\\'
	    },
	    rep;

	function quote(string) {
	    // If the string contains no control characters, no quote characters, and no
	    // backslash characters, then we can safely slap some quotes around it.
	    // Otherwise we must also replace the offending characters with safe escape
	    // sequences.
	    
	    escapable.lastIndex = 0;
	    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
	        var c = meta[a];
	        return typeof c === 'string' ? c :
	            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
	    }) + '"' : '"' + string + '"';
	}

	function str(key, holder) {
	    // Produce a string from holder[key].
	    var i,          // The loop counter.
	        k,          // The member key.
	        v,          // The member value.
	        length,
	        mind = gap,
	        partial,
	        value = holder[key];
	    
	    // If the value has a toJSON method, call it to obtain a replacement value.
	    if (value && typeof value === 'object' &&
	            typeof value.toJSON === 'function') {
	        value = value.toJSON(key);
	    }
	    
	    // If we were called with a replacer function, then call the replacer to
	    // obtain a replacement value.
	    if (typeof rep === 'function') {
	        value = rep.call(holder, key, value);
	    }
	    
	    // What happens next depends on the value's type.
	    switch (typeof value) {
	        case 'string':
	            return quote(value);
	        
	        case 'number':
	            // JSON numbers must be finite. Encode non-finite numbers as null.
	            return isFinite(value) ? String(value) : 'null';
	        
	        case 'boolean':
	        case 'null':
	            // If the value is a boolean or null, convert it to a string. Note:
	            // typeof null does not produce 'null'. The case is included here in
	            // the remote chance that this gets fixed someday.
	            return String(value);
	            
	        case 'object':
	            if (!value) return 'null';
	            gap += indent;
	            partial = [];
	            
	            // Array.isArray
	            if (Object.prototype.toString.apply(value) === '[object Array]') {
	                length = value.length;
	                for (i = 0; i < length; i += 1) {
	                    partial[i] = str(i, value) || 'null';
	                }
	                
	                // Join all of the elements together, separated with commas, and
	                // wrap them in brackets.
	                v = partial.length === 0 ? '[]' : gap ?
	                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
	                    '[' + partial.join(',') + ']';
	                gap = mind;
	                return v;
	            }
	            
	            // If the replacer is an array, use it to select the members to be
	            // stringified.
	            if (rep && typeof rep === 'object') {
	                length = rep.length;
	                for (i = 0; i < length; i += 1) {
	                    k = rep[i];
	                    if (typeof k === 'string') {
	                        v = str(k, value);
	                        if (v) {
	                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
	                        }
	                    }
	                }
	            }
	            else {
	                // Otherwise, iterate through all of the keys in the object.
	                for (k in value) {
	                    if (Object.prototype.hasOwnProperty.call(value, k)) {
	                        v = str(k, value);
	                        if (v) {
	                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
	                        }
	                    }
	                }
	            }
	            
	        // Join all of the member texts together, separated with commas,
	        // and wrap them in braces.

	        v = partial.length === 0 ? '{}' : gap ?
	            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
	            '{' + partial.join(',') + '}';
	        gap = mind;
	        return v;
	    }
	}

	module.exports = function (value, replacer, space) {
	    var i;
	    gap = '';
	    indent = '';
	    
	    // If the space parameter is a number, make an indent string containing that
	    // many spaces.
	    if (typeof space === 'number') {
	        for (i = 0; i < space; i += 1) {
	            indent += ' ';
	        }
	    }
	    // If the space parameter is a string, it will be used as the indent string.
	    else if (typeof space === 'string') {
	        indent = space;
	    }

	    // If there is a replacer, it must be a function or an array.
	    // Otherwise, throw an error.
	    rep = replacer;
	    if (replacer && typeof replacer !== 'function'
	    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
	        throw new Error('JSON.stringify');
	    }
	    
	    // Make a fake root object containing our value under the key of ''.
	    // Return the result of stringifying the value.
	    return str('', {'': value});
	};


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(140);


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var asap = __webpack_require__(147)

	module.exports = Promise;
	function Promise(fn) {
	  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new')
	  if (typeof fn !== 'function') throw new TypeError('not a function')
	  var state = null
	  var value = null
	  var deferreds = []
	  var self = this

	  this.then = function(onFulfilled, onRejected) {
	    return new self.constructor(function(resolve, reject) {
	      handle(new Handler(onFulfilled, onRejected, resolve, reject))
	    })
	  }

	  function handle(deferred) {
	    if (state === null) {
	      deferreds.push(deferred)
	      return
	    }
	    asap(function() {
	      var cb = state ? deferred.onFulfilled : deferred.onRejected
	      if (cb === null) {
	        (state ? deferred.resolve : deferred.reject)(value)
	        return
	      }
	      var ret
	      try {
	        ret = cb(value)
	      }
	      catch (e) {
	        deferred.reject(e)
	        return
	      }
	      deferred.resolve(ret)
	    })
	  }

	  function resolve(newValue) {
	    try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
	      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.')
	      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
	        var then = newValue.then
	        if (typeof then === 'function') {
	          doResolve(then.bind(newValue), resolve, reject)
	          return
	        }
	      }
	      state = true
	      value = newValue
	      finale()
	    } catch (e) { reject(e) }
	  }

	  function reject(newValue) {
	    state = false
	    value = newValue
	    finale()
	  }

	  function finale() {
	    for (var i = 0, len = deferreds.length; i < len; i++)
	      handle(deferreds[i])
	    deferreds = null
	  }

	  doResolve(fn, resolve, reject)
	}


	function Handler(onFulfilled, onRejected, resolve, reject){
	  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null
	  this.onRejected = typeof onRejected === 'function' ? onRejected : null
	  this.resolve = resolve
	  this.reject = reject
	}

	/**
	 * Take a potentially misbehaving resolver function and make sure
	 * onFulfilled and onRejected are only called once.
	 *
	 * Makes no guarantees about asynchrony.
	 */
	function doResolve(fn, onFulfilled, onRejected) {
	  var done = false;
	  try {
	    fn(function (value) {
	      if (done) return
	      done = true
	      onFulfilled(value)
	    }, function (reason) {
	      if (done) return
	      done = true
	      onRejected(reason)
	    })
	  } catch (ex) {
	    if (done) return
	    done = true
	    onRejected(ex)
	  }
	}


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(128)
	var asap = __webpack_require__(147)

	module.exports = Promise
	Promise.prototype.done = function (onFulfilled, onRejected) {
	  var self = arguments.length ? this.then.apply(this, arguments) : this
	  self.then(null, function (err) {
	    asap(function () {
	      throw err
	    })
	  })
	}

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//This file contains the ES6 extensions to the core Promises/A+ API

	var Promise = __webpack_require__(128)
	var asap = __webpack_require__(147)

	module.exports = Promise

	/* Static Functions */

	function ValuePromise(value) {
	  this.then = function (onFulfilled) {
	    if (typeof onFulfilled !== 'function') return this
	    return new Promise(function (resolve, reject) {
	      asap(function () {
	        try {
	          resolve(onFulfilled(value))
	        } catch (ex) {
	          reject(ex);
	        }
	      })
	    })
	  }
	}
	ValuePromise.prototype = Promise.prototype

	var TRUE = new ValuePromise(true)
	var FALSE = new ValuePromise(false)
	var NULL = new ValuePromise(null)
	var UNDEFINED = new ValuePromise(undefined)
	var ZERO = new ValuePromise(0)
	var EMPTYSTRING = new ValuePromise('')

	Promise.resolve = function (value) {
	  if (value instanceof Promise) return value

	  if (value === null) return NULL
	  if (value === undefined) return UNDEFINED
	  if (value === true) return TRUE
	  if (value === false) return FALSE
	  if (value === 0) return ZERO
	  if (value === '') return EMPTYSTRING

	  if (typeof value === 'object' || typeof value === 'function') {
	    try {
	      var then = value.then
	      if (typeof then === 'function') {
	        return new Promise(then.bind(value))
	      }
	    } catch (ex) {
	      return new Promise(function (resolve, reject) {
	        reject(ex)
	      })
	    }
	  }

	  return new ValuePromise(value)
	}

	Promise.all = function (arr) {
	  var args = Array.prototype.slice.call(arr)

	  return new Promise(function (resolve, reject) {
	    if (args.length === 0) return resolve([])
	    var remaining = args.length
	    function res(i, val) {
	      try {
	        if (val && (typeof val === 'object' || typeof val === 'function')) {
	          var then = val.then
	          if (typeof then === 'function') {
	            then.call(val, function (val) { res(i, val) }, reject)
	            return
	          }
	        }
	        args[i] = val
	        if (--remaining === 0) {
	          resolve(args);
	        }
	      } catch (ex) {
	        reject(ex)
	      }
	    }
	    for (var i = 0; i < args.length; i++) {
	      res(i, args[i])
	    }
	  })
	}

	Promise.reject = function (value) {
	  return new Promise(function (resolve, reject) { 
	    reject(value);
	  });
	}

	Promise.race = function (values) {
	  return new Promise(function (resolve, reject) { 
	    values.forEach(function(value){
	      Promise.resolve(value).then(resolve, reject);
	    })
	  });
	}

	/* Prototype Methods */

	Promise.prototype['catch'] = function (onRejected) {
	  return this.then(null, onRejected);
	}


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//This file contains then/promise specific extensions that are only useful for node.js interop

	var Promise = __webpack_require__(128)
	var asap = __webpack_require__(147)

	module.exports = Promise

	/* Static Functions */

	Promise.denodeify = function (fn, argumentCount) {
	  argumentCount = argumentCount || Infinity
	  return function () {
	    var self = this
	    var args = Array.prototype.slice.call(arguments)
	    return new Promise(function (resolve, reject) {
	      while (args.length && args.length > argumentCount) {
	        args.pop()
	      }
	      args.push(function (err, res) {
	        if (err) reject(err)
	        else resolve(res)
	      })
	      var res = fn.apply(self, args)
	      if (res && (typeof res === 'object' || typeof res === 'function') && typeof res.then === 'function') {
	        resolve(res)
	      }
	    })
	  }
	}
	Promise.nodeify = function (fn) {
	  return function () {
	    var args = Array.prototype.slice.call(arguments)
	    var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null
	    var ctx = this
	    try {
	      return fn.apply(this, arguments).nodeify(callback, ctx)
	    } catch (ex) {
	      if (callback === null || typeof callback == 'undefined') {
	        return new Promise(function (resolve, reject) { reject(ex) })
	      } else {
	        asap(function () {
	          callback.call(ctx, ex)
	        })
	      }
	    }
	  }
	}

	Promise.prototype.nodeify = function (callback, ctx) {
	  if (typeof callback != 'function') return this

	  this.then(function (value) {
	    asap(function () {
	      callback.call(ctx, null, value)
	    })
	  }, function (err) {
	    asap(function () {
	      callback.call(ctx, err)
	    })
	  })
	}


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	module.exports = Readable;

	/*<replacement>*/
	var processNextTick = __webpack_require__(141);
	/*</replacement>*/


	/*<replacement>*/
	var isArray = __webpack_require__(142);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(77).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(143).EventEmitter;

	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/



	/*<replacement>*/
	var Stream;
	(function (){try{
	  Stream = __webpack_require__(138);
	}catch(_){}finally{
	  if (!Stream)
	    Stream = __webpack_require__(143).EventEmitter;
	}}())
	/*</replacement>*/

	var Buffer = __webpack_require__(77).Buffer;

	/*<replacement>*/
	var util = __webpack_require__(145);
	util.inherits = __webpack_require__(118);
	/*</replacement>*/



	/*<replacement>*/
	var debug = __webpack_require__(139);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/

	var StringDecoder;

	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(134);

	  options = options || {};

	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(144).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  var Duplex = __webpack_require__(134);

	  if (!(this instanceof Readable))
	    return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  if (options && typeof options.read === 'function')
	    this._read = options.read;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;

	  if (!state.objectMode && typeof chunk === 'string') {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	Readable.prototype.isPaused = function() {
	  return this._readableState.flowing === false;
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);

	      if (!addToFront)
	        state.reading = false;

	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);

	        if (state.needReadable)
	          emitReadable(stream);
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}



	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(144).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;

	  if (state.objectMode)
	    return n === 0 ? 0 : 1;

	  if (n === null || isNaN(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }

	  if (n <= 0)
	    return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else {
	      return state.length;
	    }
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;

	  if (typeof n !== 'number' || n > 0)
	    state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }

	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);

	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;

	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;

	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);

	  if (ret !== null)
	    this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!(Buffer.isBuffer(chunk)) &&
	      typeof chunk !== 'string' &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}


	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      processNextTick(emitReadable_, stream);
	    else
	      emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}


	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    processNextTick(maybeReadMore_, stream, state);
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    processNextTick(endFn);
	  else
	    src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }

	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];



	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}


	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;

	    if (!dest)
	      dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        processNextTick(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    processNextTick(resume_, stream, state);
	  }
	}

	function resume_(stream, state) {
	  if (!state.reading) {
	    debug('resume read 0');
	    stream.read(0);
	  }

	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}

	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined))
	      return;
	    else if (!state.objectMode && (!chunk || !chunk.length))
	      return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }; }(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};



	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;

	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    processNextTick(endReadableNT, state, stream);
	  }
	}

	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(72)))

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.

	'use strict';

	module.exports = Writable;

	/*<replacement>*/
	var processNextTick = __webpack_require__(141);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(77).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;


	/*<replacement>*/
	var util = __webpack_require__(145);
	util.inherits = __webpack_require__(118);
	/*</replacement>*/



	/*<replacement>*/
	var Stream;
	(function (){try{
	  Stream = __webpack_require__(138);
	}catch(_){}finally{
	  if (!Stream)
	    Stream = __webpack_require__(143).EventEmitter;
	}}())
	/*</replacement>*/

	var Buffer = __webpack_require__(77).Buffer;

	util.inherits(Writable, Stream);

	function nop() {}

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	  this.next = null;
	}

	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(134);

	  options = options || {};

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	WritableState.prototype.getBuffer = function writableStateGetBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};

	(function (){try {
	Object.defineProperty(WritableState.prototype, 'buffer', {
	  get: __webpack_require__(146)(function() {
	    return this.getBuffer();
	  }, '_writableState.buffer is deprecated. Use ' +
	      '_writableState.getBuffer() instead.')
	});
	}catch(_){}}());


	function Writable(options) {
	  var Duplex = __webpack_require__(134);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  if (options) {
	    if (typeof options.write === 'function')
	      this._write = options.write;

	    if (typeof options.writev === 'function')
	      this._writev = options.writev;
	  }

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};


	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  processNextTick(cb, er);
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;

	  if (!(Buffer.isBuffer(chunk)) &&
	      typeof chunk !== 'string' &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    processNextTick(cb, er);
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;

	  if (typeof cb !== 'function')
	    cb = nop;

	  if (state.ended)
	    writeAfterEnd(this, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function() {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function() {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.bufferedRequest)
	      clearBuffer(this, state);
	  }
	};

	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string')
	    encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64',
	'ucs2', 'ucs-2','utf16le', 'utf-16le', 'raw']
	.indexOf((encoding + '').toLowerCase()) > -1))
	    throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      typeof chunk === 'string') {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);

	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;

	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync)
	    processNextTick(cb, er);
	  else
	    cb(er);

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);

	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      processNextTick(afterWrite, stream, state, finished, cb);
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}


	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;

	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var buffer = [];
	    var cbs = [];
	    while (entry) {
	      cbs.push(entry.callback);
	      buffer.push(entry);
	      entry = entry.next;
	    }

	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    doWrite(stream, state, true, state.length, buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });

	    // Clear buffer
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }

	    if (entry === null)
	      state.lastBufferedRequest = null;
	  }
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;

	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (chunk !== null && chunk !== undefined)
	    this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};


	function needFinish(state) {
	  return (state.ending &&
	          state.length === 0 &&
	          state.bufferedRequest === null &&
	          !state.finished &&
	          !state.writing);
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else {
	      prefinish(stream, state);
	    }
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      processNextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	'use strict';

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/


	module.exports = Duplex;

	/*<replacement>*/
	var processNextTick = __webpack_require__(141);
	/*</replacement>*/



	/*<replacement>*/
	var util = __webpack_require__(145);
	util.inherits = __webpack_require__(118);
	/*</replacement>*/

	var Readable = __webpack_require__(132);
	var Writable = __webpack_require__(133);

	util.inherits(Duplex, Readable);

	var keys = objectKeys(Writable.prototype);
	for (var v = 0; v < keys.length; v++) {
	  var method = keys[v];
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	}

	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false)
	    this.readable = false;

	  if (options && options.writable === false)
	    this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  processNextTick(onEndNT, this);
	}

	function onEndNT(self) {
	  self.end();
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	'use strict';

	module.exports = Transform;

	var Duplex = __webpack_require__(134);

	/*<replacement>*/
	var util = __webpack_require__(145);
	util.inherits = __webpack_require__(118);
	/*</replacement>*/

	util.inherits(Transform, Duplex);


	function TransformState(stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (data !== null && data !== undefined)
	    stream.push(data);

	  if (cb)
	    cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}


	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  if (options) {
	    if (typeof options.transform === 'function')
	      this._transform = options.transform;

	    if (typeof options.flush === 'function')
	      this._flush = options.flush;
	  }

	  this.once('prefinish', function() {
	    if (typeof this._flush === 'function')
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}

	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;

	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};


	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	'use strict';

	module.exports = PassThrough;

	var Transform = __webpack_require__(135);

	/*<replacement>*/
	var util = __webpack_require__(145);
	util.inherits = __webpack_require__(118);
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Stream;

	var EE = __webpack_require__(143).EventEmitter;
	var inherits = __webpack_require__(155);

	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(150);
	Stream.Writable = __webpack_require__(151);
	Stream.Duplex = __webpack_require__(152);
	Stream.Transform = __webpack_require__(153);
	Stream.PassThrough = __webpack_require__(154);

	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;



	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.

	function Stream() {
	  EE.call(this);
	}

	Stream.prototype.pipe = function(dest, options) {
	  var source = this;

	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }

	  source.on('data', ondata);

	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }

	  dest.on('drain', ondrain);

	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }

	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    dest.end();
	  }


	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    if (typeof dest.destroy === 'function') dest.destroy();
	  }

	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }

	  source.on('error', onerror);
	  dest.on('error', onerror);

	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);

	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);

	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);

	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);

	    dest.removeListener('close', cleanup);
	  }

	  source.on('end', cleanup);
	  source.on('close', cleanup);

	  dest.on('close', cleanup);

	  dest.emit('pipe', source);

	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/* (ignored) */

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Stringify = __webpack_require__(148);
	var Parse = __webpack_require__(149);


	// Declare internals

	var internals = {};


	module.exports = {
	    stringify: Stringify,
	    parse: Parse
	};


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	module.exports = nextTick;

	function nextTick(fn) {
	  var args = new Array(arguments.length - 1);
	  var i = 0;
	  while (i < args.length) {
	    args[i++] = arguments[i];
	  }
	  process.nextTick(function afterTick() {
	    fn.apply(null, args);
	  });
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(72)))

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        len = arguments.length;
	        args = new Array(len - 1);
	        for (i = 1; i < len; i++)
	          args[i - 1] = arguments[i];
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    len = arguments.length;
	    args = new Array(len - 1);
	    for (i = 1; i < len; i++)
	      args[i - 1] = arguments[i];

	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    var m;
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  var ret;
	  if (!emitter._events || !emitter._events[type])
	    ret = 0;
	  else if (isFunction(emitter._events[type]))
	    ret = 1;
	  else
	    ret = emitter._events[type].length;
	  return ret;
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Buffer = __webpack_require__(77).Buffer;

	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};


	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	function isBuffer(arg) {
	  return Buffer.isBuffer(arg);
	}
	exports.isBuffer = isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(77).Buffer))

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module exports.
	 */

	module.exports = deprecate;

	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */

	function deprecate (fn, msg) {
	  if (config('noDeprecation')) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (config('throwDeprecation')) {
	        throw new Error(msg);
	      } else if (config('traceDeprecation')) {
	        console.trace(msg);
	      } else {
	        console.warn(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	}

	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */

	function config (name) {
	  if (!global.localStorage) return false;
	  var val = global.localStorage[name];
	  if (null == val) return false;
	  return String(val).toLowerCase() === 'true';
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, setImmediate) {
	// Use the fastest possible means to execute a task in a future turn
	// of the event loop.

	// linked list of tasks (single, with head node)
	var head = {task: void 0, next: null};
	var tail = head;
	var flushing = false;
	var requestFlush = void 0;
	var isNodeJS = false;

	function flush() {
	    /* jshint loopfunc: true */

	    while (head.next) {
	        head = head.next;
	        var task = head.task;
	        head.task = void 0;
	        var domain = head.domain;

	        if (domain) {
	            head.domain = void 0;
	            domain.enter();
	        }

	        try {
	            task();

	        } catch (e) {
	            if (isNodeJS) {
	                // In node, uncaught exceptions are considered fatal errors.
	                // Re-throw them synchronously to interrupt flushing!

	                // Ensure continuation if the uncaught exception is suppressed
	                // listening "uncaughtException" events (as domains does).
	                // Continue in next event to avoid tick recursion.
	                if (domain) {
	                    domain.exit();
	                }
	                setTimeout(flush, 0);
	                if (domain) {
	                    domain.enter();
	                }

	                throw e;

	            } else {
	                // In browsers, uncaught exceptions are not fatal.
	                // Re-throw them asynchronously to avoid slow-downs.
	                setTimeout(function() {
	                   throw e;
	                }, 0);
	            }
	        }

	        if (domain) {
	            domain.exit();
	        }
	    }

	    flushing = false;
	}

	if (typeof process !== "undefined" && process.nextTick) {
	    // Node.js before 0.9. Note that some fake-Node environments, like the
	    // Mocha test runner, introduce a `process` global without a `nextTick`.
	    isNodeJS = true;

	    requestFlush = function () {
	        process.nextTick(flush);
	    };

	} else if (typeof setImmediate === "function") {
	    // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
	    if (typeof window !== "undefined") {
	        requestFlush = setImmediate.bind(window, flush);
	    } else {
	        requestFlush = function () {
	            setImmediate(flush);
	        };
	    }

	} else if (typeof MessageChannel !== "undefined") {
	    // modern browsers
	    // http://www.nonblocking.io/2011/06/windownexttick.html
	    var channel = new MessageChannel();
	    channel.port1.onmessage = flush;
	    requestFlush = function () {
	        channel.port2.postMessage(0);
	    };

	} else {
	    // old browsers
	    requestFlush = function () {
	        setTimeout(flush, 0);
	    };
	}

	function asap(task) {
	    tail = tail.next = {
	        task: task,
	        domain: isNodeJS && process.domain,
	        next: null
	    };

	    if (!flushing) {
	        flushing = true;
	        requestFlush();
	    }
	};

	module.exports = asap;


	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(72), __webpack_require__(162).setImmediate))

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Utils = __webpack_require__(156);


	// Declare internals

	var internals = {
	    delimiter: '&',
	    arrayPrefixGenerators: {
	        brackets: function (prefix, key) {
	            return prefix + '[]';
	        },
	        indices: function (prefix, key) {
	            return prefix + '[' + key + ']';
	        },
	        repeat: function (prefix, key) {
	            return prefix;
	        }
	    }
	};


	internals.stringify = function (obj, prefix, generateArrayPrefix) {

	    if (Utils.isBuffer(obj)) {
	        obj = obj.toString();
	    }
	    else if (obj instanceof Date) {
	        obj = obj.toISOString();
	    }
	    else if (obj === null) {
	        obj = '';
	    }

	    if (typeof obj === 'string' ||
	        typeof obj === 'number' ||
	        typeof obj === 'boolean') {

	        return [encodeURIComponent(prefix) + '=' + encodeURIComponent(obj)];
	    }

	    var values = [];

	    if (typeof obj === 'undefined') {
	        return values;
	    }

	    var objKeys = Object.keys(obj);
	    for (var i = 0, il = objKeys.length; i < il; ++i) {
	        var key = objKeys[i];
	        if (Array.isArray(obj)) {
	            values = values.concat(internals.stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix));
	        }
	        else {
	            values = values.concat(internals.stringify(obj[key], prefix + '[' + key + ']', generateArrayPrefix));
	        }
	    }

	    return values;
	};


	module.exports = function (obj, options) {

	    options = options || {};
	    var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;

	    var keys = [];

	    if (typeof obj !== 'object' ||
	        obj === null) {

	        return '';
	    }

	    var arrayFormat;
	    if (options.arrayFormat in internals.arrayPrefixGenerators) {
	        arrayFormat = options.arrayFormat;
	    }
	    else if ('indices' in options) {
	        arrayFormat = options.indices ? 'indices' : 'repeat';
	    }
	    else {
	        arrayFormat = 'indices';
	    }

	    var generateArrayPrefix = internals.arrayPrefixGenerators[arrayFormat];

	    var objKeys = Object.keys(obj);
	    for (var i = 0, il = objKeys.length; i < il; ++i) {
	        var key = objKeys[i];
	        keys = keys.concat(internals.stringify(obj[key], key, generateArrayPrefix));
	    }

	    return keys.join(delimiter);
	};


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Utils = __webpack_require__(156);


	// Declare internals

	var internals = {
	    delimiter: '&',
	    depth: 5,
	    arrayLimit: 20,
	    parameterLimit: 1000
	};


	internals.parseValues = function (str, options) {

	    var obj = {};
	    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);

	    for (var i = 0, il = parts.length; i < il; ++i) {
	        var part = parts[i];
	        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;

	        if (pos === -1) {
	            obj[Utils.decode(part)] = '';
	        }
	        else {
	            var key = Utils.decode(part.slice(0, pos));
	            var val = Utils.decode(part.slice(pos + 1));

	            if (!Object.prototype.hasOwnProperty.call(obj, key)) {
	                obj[key] = val;
	            }
	            else {
	                obj[key] = [].concat(obj[key]).concat(val);
	            }
	        }
	    }

	    return obj;
	};


	internals.parseObject = function (chain, val, options) {

	    if (!chain.length) {
	        return val;
	    }

	    var root = chain.shift();

	    var obj = {};
	    if (root === '[]') {
	        obj = [];
	        obj = obj.concat(internals.parseObject(chain, val, options));
	    }
	    else {
	        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
	        var index = parseInt(cleanRoot, 10);
	        var indexString = '' + index;
	        if (!isNaN(index) &&
	            root !== cleanRoot &&
	            indexString === cleanRoot &&
	            index >= 0 &&
	            index <= options.arrayLimit) {

	            obj = [];
	            obj[index] = internals.parseObject(chain, val, options);
	        }
	        else {
	            obj[cleanRoot] = internals.parseObject(chain, val, options);
	        }
	    }

	    return obj;
	};


	internals.parseKeys = function (key, val, options) {

	    if (!key) {
	        return;
	    }

	    // The regex chunks

	    var parent = /^([^\[\]]*)/;
	    var child = /(\[[^\[\]]*\])/g;

	    // Get the parent

	    var segment = parent.exec(key);

	    // Don't allow them to overwrite object prototype properties

	    if (Object.prototype.hasOwnProperty(segment[1])) {
	        return;
	    }

	    // Stash the parent if it exists

	    var keys = [];
	    if (segment[1]) {
	        keys.push(segment[1]);
	    }

	    // Loop through children appending to the array until we hit depth

	    var i = 0;
	    while ((segment = child.exec(key)) !== null && i < options.depth) {

	        ++i;
	        if (!Object.prototype.hasOwnProperty(segment[1].replace(/\[|\]/g, ''))) {
	            keys.push(segment[1]);
	        }
	    }

	    // If there's a remainder, just add whatever is left

	    if (segment) {
	        keys.push('[' + key.slice(segment.index) + ']');
	    }

	    return internals.parseObject(keys, val, options);
	};


	module.exports = function (str, options) {

	    if (str === '' ||
	        str === null ||
	        typeof str === 'undefined') {

	        return {};
	    }

	    options = options || {};
	    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;
	    options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;
	    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;
	    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;

	    var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;
	    var obj = {};

	    // Iterate over the keys and setup the new object

	    var keys = Object.keys(tempObj);
	    for (var i = 0, il = keys.length; i < il; ++i) {
	        var key = keys[i];
	        var newObj = internals.parseKeys(key, tempObj[key], options);
	        obj = Utils.merge(obj, newObj);
	    }

	    return Utils.compact(obj);
	};


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(158);
	exports.Stream = __webpack_require__(138);
	exports.Readable = exports;
	exports.Writable = __webpack_require__(157);
	exports.Duplex = __webpack_require__(159);
	exports.Transform = __webpack_require__(160);
	exports.PassThrough = __webpack_require__(161);


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(157)


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(159)


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(160)


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(161)


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules


	// Declare internals

	var internals = {};


	exports.arrayToObject = function (source) {

	    var obj = {};
	    for (var i = 0, il = source.length; i < il; ++i) {
	        if (typeof source[i] !== 'undefined') {

	            obj[i] = source[i];
	        }
	    }

	    return obj;
	};


	exports.merge = function (target, source) {

	    if (!source) {
	        return target;
	    }

	    if (typeof source !== 'object') {
	        if (Array.isArray(target)) {
	            target.push(source);
	        }
	        else {
	            target[source] = true;
	        }

	        return target;
	    }

	    if (typeof target !== 'object') {
	        target = [target].concat(source);
	        return target;
	    }

	    if (Array.isArray(target) &&
	        !Array.isArray(source)) {

	        target = exports.arrayToObject(target);
	    }

	    var keys = Object.keys(source);
	    for (var k = 0, kl = keys.length; k < kl; ++k) {
	        var key = keys[k];
	        var value = source[key];

	        if (!target[key]) {
	            target[key] = value;
	        }
	        else {
	            target[key] = exports.merge(target[key], value);
	        }
	    }

	    return target;
	};


	exports.decode = function (str) {

	    try {
	        return decodeURIComponent(str.replace(/\+/g, ' '));
	    } catch (e) {
	        return str;
	    }
	};


	exports.compact = function (obj, refs) {

	    if (typeof obj !== 'object' ||
	        obj === null) {

	        return obj;
	    }

	    refs = refs || [];
	    var lookup = refs.indexOf(obj);
	    if (lookup !== -1) {
	        return refs[lookup];
	    }

	    refs.push(obj);

	    if (Array.isArray(obj)) {
	        var compacted = [];

	        for (var i = 0, il = obj.length; i < il; ++i) {
	            if (typeof obj[i] !== 'undefined') {
	                compacted.push(obj[i]);
	            }
	        }

	        return compacted;
	    }

	    var keys = Object.keys(obj);
	    for (i = 0, il = keys.length; i < il; ++i) {
	        var key = keys[i];
	        obj[key] = exports.compact(obj[key], refs);
	    }

	    return obj;
	};


	exports.isRegExp = function (obj) {
	    return Object.prototype.toString.call(obj) === '[object RegExp]';
	};


	exports.isBuffer = function (obj) {

	    if (obj === null ||
	        typeof obj === 'undefined') {

	        return false;
	    }

	    return !!(obj.constructor &&
	        obj.constructor.isBuffer &&
	        obj.constructor.isBuffer(obj));
	};


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.

	module.exports = Writable;

	/*<replacement>*/
	var Buffer = __webpack_require__(77).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;


	/*<replacement>*/
	var util = __webpack_require__(166);
	util.inherits = __webpack_require__(167);
	/*</replacement>*/

	var Stream = __webpack_require__(138);

	util.inherits(Writable, Stream);

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}

	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(159);

	  options = options || {};

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.buffer = [];

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	function Writable(options) {
	  var Duplex = __webpack_require__(159);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};


	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;

	  if (!util.isFunction(cb))
	    cb = function() {};

	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function() {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function() {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.buffer.length)
	      clearBuffer(this, state);
	  }
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;

	  if (state.writing || state.corked)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, false, len, chunk, encoding, cb);

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      state.pendingcb--;
	      cb(er);
	    });
	  else {
	    state.pendingcb--;
	    cb(er);
	  }

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);

	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.buffer.length) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}


	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;

	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++)
	      cbs.push(state.buffer[c].callback);

	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });

	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);

	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }

	    if (c < state.buffer.length)
	      state.buffer = state.buffer.slice(c);
	    else
	      state.buffer.length = 0;
	  }

	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));

	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;

	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (!util.isNullOrUndefined(chunk))
	    this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};


	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else
	      prefinish(stream, state);
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(72)))

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Readable;

	/*<replacement>*/
	var isArray = __webpack_require__(165);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(77).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(143).EventEmitter;

	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	var Stream = __webpack_require__(138);

	/*<replacement>*/
	var util = __webpack_require__(166);
	util.inherits = __webpack_require__(167);
	/*</replacement>*/

	var StringDecoder;


	/*<replacement>*/
	var debug = __webpack_require__(163);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/


	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(159);

	  options = options || {};

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;


	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(164).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  var Duplex = __webpack_require__(159);

	  if (!(this instanceof Readable))
	    return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;

	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);

	      if (!addToFront)
	        state.reading = false;

	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);

	        if (state.needReadable)
	          emitReadable(stream);
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}



	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(164).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;

	  if (state.objectMode)
	    return n === 0 ? 0 : 1;

	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }

	  if (n <= 0)
	    return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;

	  if (!util.isNumber(n) || n > 0)
	    state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }

	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);

	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;

	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;

	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);

	  if (!util.isNull(ret))
	    this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}


	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      process.nextTick(function() {
	        emitReadable_(stream);
	      });
	    else
	      emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}


	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }

	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];



	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}


	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;

	    if (!dest)
	      dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process.nextTick(function() {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(function() {
	      resume_(stream, state);
	    });
	  }
	}

	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}

	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length)
	      return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};



	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;

	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(72)))

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	module.exports = Duplex;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/


	/*<replacement>*/
	var util = __webpack_require__(166);
	util.inherits = __webpack_require__(167);
	/*</replacement>*/

	var Readable = __webpack_require__(158);
	var Writable = __webpack_require__(157);

	util.inherits(Duplex, Readable);

	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});

	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false)
	    this.readable = false;

	  if (options && options.writable === false)
	    this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(72)))

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.


	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	module.exports = Transform;

	var Duplex = __webpack_require__(159);

	/*<replacement>*/
	var util = __webpack_require__(166);
	util.inherits = __webpack_require__(167);
	/*</replacement>*/

	util.inherits(Transform, Duplex);


	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (!util.isNullOrUndefined(data))
	    stream.push(data);

	  if (cb)
	    cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}


	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(options, this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  this.once('prefinish', function() {
	    if (util.isFunction(this._flush))
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}

	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;

	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};


	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	module.exports = PassThrough;

	var Transform = __webpack_require__(160);

	/*<replacement>*/
	var util = __webpack_require__(166);
	util.inherits = __webpack_require__(167);
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(72).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(162).setImmediate, __webpack_require__(162).clearImmediate))

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/* (ignored) */

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Buffer = __webpack_require__(77).Buffer;

	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};


	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	function isBuffer(arg) {
	  return Buffer.isBuffer(arg);
	}
	exports.isBuffer = isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(77).Buffer))

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ }
/******/ ]);